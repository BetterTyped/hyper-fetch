"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/msw";
exports.ids = ["vendor-chunks/msw"];
exports.modules = {

/***/ "(ssr)/../../node_modules/msw/lib/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/msw/lib/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  GraphQLHandler: () => GraphQLHandler,\n  MockedRequest: () => MockedRequest,\n  RESTMethods: () => RESTMethods,\n  RequestHandler: () => RequestHandler,\n  RestHandler: () => RestHandler,\n  SetupApi: () => SetupApi,\n  SetupWorkerApi: () => SetupWorkerApi,\n  cleanUrl: () => cleanUrl,\n  compose: () => compose,\n  context: () => context_exports,\n  createResponseComposition: () => createResponseComposition,\n  defaultContext: () => defaultContext,\n  defaultResponse: () => defaultResponse,\n  graphql: () => graphql,\n  graphqlContext: () => graphqlContext,\n  handleRequest: () => handleRequest,\n  matchRequestUrl: () => matchRequestUrl,\n  response: () => response,\n  rest: () => rest,\n  restContext: () => restContext,\n  setupWorker: () => setupWorker\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/context/index.ts\nvar context_exports = {};\n__export(context_exports, {\n  body: () => body,\n  cookie: () => cookie,\n  data: () => data,\n  delay: () => delay,\n  errors: () => errors,\n  extensions: () => extensions,\n  fetch: () => fetch,\n  json: () => json,\n  set: () => set,\n  status: () => status,\n  text: () => text,\n  xml: () => xml\n});\n\n// node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json\nvar codes_default = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"103\": \"Early Hints\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a Teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Too Early\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n};\n\n// src/context/status.ts\nvar status = (statusCode, statusText) => {\n  return (res) => {\n    res.status = statusCode;\n    res.statusText = statusText || codes_default[String(statusCode)];\n    return res;\n  };\n};\n\n// src/context/set.ts\nvar import_headers_polyfill = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.js\");\nfunction set(...args) {\n  return (res) => {\n    const [name, value] = args;\n    if (typeof name === \"string\") {\n      res.headers.append(name, value);\n    } else {\n      const headers = (0, import_headers_polyfill.objectToHeaders)(name);\n      headers.forEach((value2, name2) => {\n        res.headers.append(name2, value2);\n      });\n    }\n    return res;\n  };\n}\n\n// src/context/cookie.ts\nvar cookieUtils = __toESM(__webpack_require__(/*! cookie */ \"(ssr)/../../node_modules/cookie/index.js\"));\nvar cookie = (name, value, options) => {\n  return (res) => {\n    const serializedCookie = cookieUtils.serialize(name, value, options);\n    res.headers.append(\"Set-Cookie\", serializedCookie);\n    if (typeof document !== \"undefined\") {\n      document.cookie = serializedCookie;\n    }\n    return res;\n  };\n};\n\n// src/context/body.ts\nvar body = (value) => {\n  return (res) => {\n    res.body = value;\n    return res;\n  };\n};\n\n// src/utils/internal/jsonParse.ts\nfunction jsonParse(value) {\n  try {\n    return JSON.parse(value);\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/internal/isObject.ts\nfunction isObject(value) {\n  return value != null && typeof value === \"object\" && !Array.isArray(value);\n}\n\n// src/utils/internal/mergeRight.ts\nfunction mergeRight(left, right) {\n  return Object.entries(right).reduce((result, [key, rightValue]) => {\n    const leftValue = result[key];\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue);\n      return result;\n    }\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue);\n      return result;\n    }\n    result[key] = rightValue;\n    return result;\n  }, Object.assign({}, left));\n}\n\n// src/context/json.ts\nvar json = (body2) => {\n  return (res) => {\n    res.headers.set(\"Content-Type\", \"application/json\");\n    res.body = JSON.stringify(body2);\n    return res;\n  };\n};\n\n// src/context/data.ts\nvar data = (payload) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { data: payload });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/extensions.ts\nvar extensions = (payload) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { extensions: payload });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/delay.ts\nvar import_is_node_process = __webpack_require__(/*! is-node-process */ \"(ssr)/../../node_modules/is-node-process/lib/index.js\");\nvar SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;\nvar MIN_SERVER_RESPONSE_TIME = 100;\nvar MAX_SERVER_RESPONSE_TIME = 400;\nvar NODE_SERVER_RESPONSE_TIME = 5;\nvar getRandomServerResponseTime = () => {\n  if ((0, import_is_node_process.isNodeProcess)()) {\n    return NODE_SERVER_RESPONSE_TIME;\n  }\n  return Math.floor(\n    Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME\n  );\n};\nvar delay = (durationOrMode) => {\n  return (res) => {\n    let delayTime;\n    if (typeof durationOrMode === \"string\") {\n      switch (durationOrMode) {\n        case \"infinite\": {\n          delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;\n          break;\n        }\n        case \"real\": {\n          delayTime = getRandomServerResponseTime();\n          break;\n        }\n        default: {\n          throw new Error(\n            `Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`\n          );\n        }\n      }\n    } else if (typeof durationOrMode === \"undefined\") {\n      delayTime = getRandomServerResponseTime();\n    } else {\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\n          `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`\n        );\n      }\n      delayTime = durationOrMode;\n    }\n    res.delay = delayTime;\n    return res;\n  };\n};\n\n// src/context/errors.ts\nvar errors = (errorsList) => {\n  return (res) => {\n    if (errorsList == null) {\n      return res;\n    }\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { errors: errorsList });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/fetch.ts\nvar import_is_node_process2 = __webpack_require__(/*! is-node-process */ \"(ssr)/../../node_modules/is-node-process/lib/index.js\");\nvar import_headers_polyfill2 = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.js\");\nvar useFetch = (0, import_is_node_process2.isNodeProcess)() ? (input, init) => Promise.resolve().then(() => __toESM(__webpack_require__(/*! node-fetch */ \"(ssr)/../../node_modules/node-fetch/lib/index.mjs\"))).then(\n  ({ default: nodeFetch }) => nodeFetch(input, init)\n) : globalThis.fetch;\nvar augmentRequestInit = (requestInit) => {\n  const headers = new import_headers_polyfill2.Headers(requestInit.headers);\n  headers.set(\"x-msw-bypass\", \"true\");\n  return {\n    ...requestInit,\n    headers: headers.all()\n  };\n};\nvar createFetchRequestParameters = (input) => {\n  const { body: body2, method } = input;\n  const requestParameters = {\n    ...input,\n    body: void 0\n  };\n  if ([\"GET\", \"HEAD\"].includes(method)) {\n    return requestParameters;\n  }\n  if (typeof body2 === \"object\" || typeof body2 === \"number\" || typeof body2 === \"boolean\") {\n    requestParameters.body = JSON.stringify(body2);\n  } else {\n    requestParameters.body = body2;\n  }\n  return requestParameters;\n};\nvar fetch = (input, requestInit = {}) => {\n  if (typeof input === \"string\") {\n    return useFetch(input, augmentRequestInit(requestInit));\n  }\n  const requestParameters = createFetchRequestParameters(input);\n  const derivedRequestInit = augmentRequestInit(requestParameters);\n  return useFetch(input.url.href, derivedRequestInit);\n};\n\n// src/context/text.ts\nvar text = (body2) => {\n  return (res) => {\n    res.headers.set(\"Content-Type\", \"text/plain\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/context/xml.ts\nvar xml = (body2) => {\n  return (res) => {\n    res.headers.set(\"Content-Type\", \"text/xml\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/utils/internal/checkGlobals.ts\nvar import_outvariant2 = __webpack_require__(/*! outvariant */ \"(ssr)/../../node_modules/outvariant/lib/index.js\");\n\n// src/utils/internal/devUtils.ts\nvar import_outvariant = __webpack_require__(/*! outvariant */ \"(ssr)/../../node_modules/outvariant/lib/index.js\");\nvar LIBRARY_PREFIX = \"[MSW]\";\nfunction formatMessage(message, ...positionals) {\n  const interpolatedMessage = (0, import_outvariant.format)(message, ...positionals);\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`;\n}\nfunction warn(message, ...positionals) {\n  console.warn(formatMessage(message, ...positionals));\n}\nfunction error(message, ...positionals) {\n  console.error(formatMessage(message, ...positionals));\n}\nvar devUtils = {\n  formatMessage,\n  warn,\n  error\n};\n\n// src/utils/internal/checkGlobals.ts\nfunction checkGlobals() {\n  (0, import_outvariant2.invariant)(\n    typeof URL !== \"undefined\",\n    devUtils.formatMessage(\n      `Global \"URL\" class is not defined. This likely means that you're running MSW in an environment that doesn't support all Node.js standard API (e.g. React Native). If that's the case, please use an appropriate polyfill for the \"URL\" class, like \"react-native-url-polyfill\".`\n    )\n  );\n}\n\n// src/setupWorker/setupWorker.ts\nvar import_outvariant5 = __webpack_require__(/*! outvariant */ \"(ssr)/../../node_modules/outvariant/lib/index.js\");\nvar import_is_node_process3 = __webpack_require__(/*! is-node-process */ \"(ssr)/../../node_modules/is-node-process/lib/index.js\");\n\n// src/setupWorker/start/createStartHandler.ts\nvar import_until4 = __webpack_require__(/*! @open-draft/until */ \"(ssr)/../../node_modules/@open-draft/until/lib/index.js\");\n\n// src/setupWorker/start/utils/getWorkerInstance.ts\nvar import_until = __webpack_require__(/*! @open-draft/until */ \"(ssr)/../../node_modules/@open-draft/until/lib/index.js\");\n\n// src/setupWorker/start/utils/getWorkerByRegistration.ts\nfunction getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker) {\n  const allStates = [\n    registration.active,\n    registration.installing,\n    registration.waiting\n  ];\n  const relevantStates = allStates.filter((state) => {\n    return state != null;\n  });\n  const worker = relevantStates.find((worker2) => {\n    return findWorker(worker2.scriptURL, absoluteWorkerUrl);\n  });\n  return worker || null;\n}\n\n// src/utils/url/getAbsoluteWorkerUrl.ts\nfunction getAbsoluteWorkerUrl(workerUrl) {\n  return new URL(workerUrl, location.href).href;\n}\n\n// src/setupWorker/start/utils/getWorkerInstance.ts\nvar getWorkerInstance = async (url, options = {}, findWorker) => {\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n  const mockRegistrations = await navigator.serviceWorker.getRegistrations().then(\n    (registrations) => registrations.filter(\n      (registration) => getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker)\n    )\n  );\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    location.reload();\n  }\n  const [existingRegistration] = mockRegistrations;\n  if (existingRegistration) {\n    return existingRegistration.update().then(() => {\n      return [\n        getWorkerByRegistration(\n          existingRegistration,\n          absoluteWorkerUrl,\n          findWorker\n        ),\n        existingRegistration\n      ];\n    });\n  }\n  const [error2, instance] = await (0, import_until.until)(\n    async () => {\n      const registration = await navigator.serviceWorker.register(url, options);\n      return [\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n        registration\n      ];\n    }\n  );\n  if (error2) {\n    const isWorkerMissing = error2.message.includes(\"(404)\");\n    if (isWorkerMissing) {\n      const scopeUrl = new URL((options == null ? void 0 : options.scope) || \"/\", location.href);\n      throw new Error(\n        devUtils.formatMessage(`Failed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`)\n      );\n    }\n    throw new Error(\n      devUtils.formatMessage(\n        \"Failed to register the Service Worker:\\n\\n%s\",\n        error2.message\n      )\n    );\n  }\n  return instance;\n};\n\n// src/setupWorker/start/utils/printStartMessage.ts\nfunction printStartMessage(args = {}) {\n  if (args.quiet) {\n    return;\n  }\n  const message = args.message || \"Mocking enabled.\";\n  console.groupCollapsed(\n    `%c${devUtils.formatMessage(message)}`,\n    \"color:orangered;font-weight:bold;\"\n  );\n  console.log(\n    \"%cDocumentation: %chttps://mswjs.io/docs\",\n    \"font-weight:bold\",\n    \"font-weight:normal\"\n  );\n  console.log(\"Found an issue? https://github.com/mswjs/msw/issues\");\n  if (args.workerUrl) {\n    console.log(\"Worker script URL:\", args.workerUrl);\n  }\n  if (args.workerScope) {\n    console.log(\"Worker scope:\", args.workerScope);\n  }\n  console.groupEnd();\n}\n\n// src/setupWorker/start/utils/enableMocking.ts\nasync function enableMocking(context, options) {\n  var _a, _b;\n  context.workerChannel.send(\"MOCK_ACTIVATE\");\n  await context.events.once(\"MOCKING_ENABLED\");\n  if (context.isMockingEnabled) {\n    devUtils.warn(\n      `Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`\n    );\n    return;\n  }\n  context.isMockingEnabled = true;\n  printStartMessage({\n    quiet: options.quiet,\n    workerScope: (_a = context.registration) == null ? void 0 : _a.scope,\n    workerUrl: (_b = context.worker) == null ? void 0 : _b.scriptURL\n  });\n}\n\n// src/setupWorker/start/utils/createMessageChannel.ts\nvar WorkerChannel = class {\n  constructor(port) {\n    this.port = port;\n  }\n  postMessage(event, ...rest2) {\n    const [data2, transfer] = rest2;\n    this.port.postMessage({ type: event, data: data2 }, { transfer });\n  }\n};\n\n// src/utils/NetworkError.ts\nvar NetworkError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"NetworkError\";\n  }\n};\n\n// src/utils/request/parseWorkerRequest.ts\nvar import_interceptors2 = __webpack_require__(/*! @mswjs/interceptors */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/index.js\");\nvar import_headers_polyfill5 = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.js\");\n\n// src/utils/request/MockedRequest.ts\nvar cookieUtils3 = __toESM(__webpack_require__(/*! cookie */ \"(ssr)/../../node_modules/cookie/index.js\"));\nvar import_cookies = __webpack_require__(/*! @mswjs/cookies */ \"(ssr)/../../node_modules/@mswjs/cookies/lib/index.js\");\nvar import_interceptors = __webpack_require__(/*! @mswjs/interceptors */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/index.js\");\nvar import_bufferUtils = __webpack_require__(/*! @mswjs/interceptors/lib/utils/bufferUtils.js */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/utils/bufferUtils.js\");\nvar import_headers_polyfill4 = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.js\");\n\n// src/utils/request/getRequestCookies.ts\nvar cookieUtils2 = __toESM(__webpack_require__(/*! cookie */ \"(ssr)/../../node_modules/cookie/index.js\"));\nfunction getAllCookies() {\n  return cookieUtils2.parse(document.cookie);\n}\nfunction getRequestCookies(request) {\n  if (typeof document === \"undefined\" || typeof location === \"undefined\") {\n    return {};\n  }\n  switch (request.credentials) {\n    case \"same-origin\": {\n      return location.origin === request.url.origin ? getAllCookies() : {};\n    }\n    case \"include\": {\n      return getAllCookies();\n    }\n    default: {\n      return {};\n    }\n  }\n}\n\n// src/utils/internal/parseMultipartData.ts\nvar import_headers_polyfill3 = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.js\");\nfunction parseContentHeaders(headersString) {\n  var _a, _b;\n  const headers = (0, import_headers_polyfill3.stringToHeaders)(headersString);\n  const contentType = headers.get(\"content-type\") || \"text/plain\";\n  const disposition = headers.get(\"content-disposition\");\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.');\n  }\n  const directives = disposition.split(\";\").reduce((acc, chunk) => {\n    const [name2, ...rest2] = chunk.trim().split(\"=\");\n    acc[name2] = rest2.join(\"=\");\n    return acc;\n  }, {});\n  const name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);\n  const filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);\n  return {\n    name,\n    filename,\n    contentType\n  };\n}\nfunction parseMultipartData(data2, headers) {\n  const contentType = headers == null ? void 0 : headers.get(\"content-type\");\n  if (!contentType) {\n    return void 0;\n  }\n  const [, ...directives] = contentType.split(/; */);\n  const boundary = directives.filter((d) => d.startsWith(\"boundary=\")).map((s) => s.replace(/^boundary=/, \"\"))[0];\n  if (!boundary) {\n    return void 0;\n  }\n  const boundaryRegExp = new RegExp(`--+${boundary}`);\n  const fields = data2.split(boundaryRegExp).filter((chunk) => chunk.startsWith(\"\\r\\n\") && chunk.endsWith(\"\\r\\n\")).map((chunk) => chunk.trimStart().replace(/\\r\\n$/, \"\"));\n  if (!fields.length) {\n    return void 0;\n  }\n  const parsedBody = {};\n  try {\n    for (const field2 of fields) {\n      const [contentHeaders, ...rest2] = field2.split(\"\\r\\n\\r\\n\");\n      const contentBody = rest2.join(\"\\r\\n\\r\\n\");\n      const { contentType: contentType2, filename, name } = parseContentHeaders(contentHeaders);\n      const value = filename === void 0 ? contentBody : new File([contentBody], filename, { type: contentType2 });\n      const parsedValue = parsedBody[name];\n      if (parsedValue === void 0) {\n        parsedBody[name] = value;\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value];\n      } else {\n        parsedBody[name] = [parsedValue, value];\n      }\n    }\n    return parsedBody;\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/request/parseBody.ts\nfunction parseBody(body2, headers) {\n  var _a;\n  if (!body2) {\n    return body2;\n  }\n  const contentType = ((_a = headers == null ? void 0 : headers.get(\"content-type\")) == null ? void 0 : _a.toLowerCase()) || \"\";\n  const hasMultipartContent = contentType.startsWith(\"multipart/form-data\");\n  if (hasMultipartContent && typeof body2 !== \"object\") {\n    return parseMultipartData(body2.toString(), headers) || body2;\n  }\n  const hasJsonContent = contentType.includes(\"json\");\n  if (hasJsonContent && typeof body2 !== \"object\") {\n    return jsonParse(body2.toString()) || body2;\n  }\n  return body2;\n}\n\n// src/utils/internal/isStringEqual.ts\nfunction isStringEqual(actual, expected) {\n  return actual.toLowerCase() === expected.toLowerCase();\n}\n\n// src/utils/request/MockedRequest.ts\nvar MockedRequest = class extends import_interceptors.IsomorphicRequest {\n  constructor(url, init = {}) {\n    super(url, init);\n    if (init.id) {\n      this.id = init.id;\n    }\n    this.cache = init.cache || \"default\";\n    this.destination = init.destination || \"\";\n    this.integrity = init.integrity || \"\";\n    this.keepalive = init.keepalive || false;\n    this.mode = init.mode || \"cors\";\n    this.priority = init.priority || \"auto\";\n    this.redirect = init.redirect || \"follow\";\n    this.referrer = init.referrer || \"\";\n    this.referrerPolicy = init.referrerPolicy || \"no-referrer\";\n    this.cookies = init.cookies || this.getCookies();\n  }\n  get body() {\n    const text2 = (0, import_bufferUtils.decodeBuffer)(this[\"_body\"]);\n    const body2 = parseBody(text2, this.headers);\n    if (isStringEqual(this.method, \"GET\") && body2 === \"\") {\n      return void 0;\n    }\n    return body2;\n  }\n  passthrough() {\n    return {\n      status: 101,\n      statusText: \"Continue\",\n      headers: new import_headers_polyfill4.Headers(),\n      body: null,\n      passthrough: true,\n      once: false\n    };\n  }\n  getCookies() {\n    var _a;\n    const requestCookiesString = this.headers.get(\"cookie\");\n    const ownCookies = requestCookiesString ? cookieUtils3.parse(requestCookiesString) : {};\n    import_cookies.store.hydrate();\n    const cookiesFromStore = Array.from(\n      (_a = import_cookies.store.get({ ...this, url: this.url.href })) == null ? void 0 : _a.entries()\n    ).reduce((cookies, [name, { value }]) => {\n      return Object.assign(cookies, { [name.trim()]: value });\n    }, {});\n    const cookiesFromDocument = getRequestCookies(this);\n    const forwardedCookies = {\n      ...cookiesFromDocument,\n      ...cookiesFromStore\n    };\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append(\"cookie\", `${name}=${value}`);\n    }\n    return {\n      ...forwardedCookies,\n      ...ownCookies\n    };\n  }\n};\n\n// src/utils/request/parseWorkerRequest.ts\nfunction parseWorkerRequest(rawRequest) {\n  const url = new URL(rawRequest.url);\n  const headers = new import_headers_polyfill5.Headers(rawRequest.headers);\n  return new MockedRequest(url, {\n    ...rawRequest,\n    body: (0, import_interceptors2.encodeBuffer)(rawRequest.body || \"\"),\n    headers\n  });\n}\n\n// src/utils/handleRequest.ts\nvar import_until2 = __webpack_require__(/*! @open-draft/until */ \"(ssr)/../../node_modules/@open-draft/until/lib/index.js\");\n\n// src/utils/getResponse.ts\nvar getResponse = async (request, handlers, resolutionContext) => {\n  const relevantHandlers = handlers.filter((handler) => {\n    return handler.test(request, resolutionContext);\n  });\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  const result = await relevantHandlers.reduce(async (executionResult, handler) => {\n    const previousResults = await executionResult;\n    if (!!(previousResults == null ? void 0 : previousResults.response)) {\n      return executionResult;\n    }\n    const result2 = await handler.run(request, resolutionContext);\n    if (result2 === null || result2.handler.shouldSkip) {\n      return null;\n    }\n    if (!result2.response) {\n      return {\n        request: result2.request,\n        handler: result2.handler,\n        response: void 0,\n        parsedResult: result2.parsedResult\n      };\n    }\n    if (result2.response.once) {\n      handler.markAsSkipped(true);\n    }\n    return result2;\n  }, Promise.resolve(null));\n  if (!result) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response\n  };\n};\n\n// src/utils/request/onUnhandledRequest.ts\nvar import_js_levenshtein = __toESM(__webpack_require__(/*! js-levenshtein */ \"(ssr)/../../node_modules/js-levenshtein/index.js\"));\n\n// src/utils/internal/parseGraphQLRequest.ts\nvar import_graphql = __webpack_require__(/*! graphql */ \"(ssr)/../../node_modules/graphql/index.mjs\");\n\n// src/utils/request/getPublicUrlFromRequest.ts\nvar getPublicUrlFromRequest = (request) => {\n  return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(\n    request.url.pathname,\n    `${request.url.protocol}//${request.url.host}`\n  ).href;\n};\n\n// src/utils/internal/parseGraphQLRequest.ts\nfunction parseDocumentNode(node) {\n  var _a;\n  const operationDef = node.definitions.find((def) => {\n    return def.kind === \"OperationDefinition\";\n  });\n  return {\n    operationType: operationDef == null ? void 0 : operationDef.operation,\n    operationName: (_a = operationDef == null ? void 0 : operationDef.name) == null ? void 0 : _a.value\n  };\n}\nfunction parseQuery(query) {\n  try {\n    const ast = (0, import_graphql.parse)(query);\n    return parseDocumentNode(ast);\n  } catch (error2) {\n    return error2;\n  }\n}\nfunction extractMultipartVariables(variables, map, files) {\n  const operations = { variables };\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`);\n    }\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split(\".\").reverse();\n      const paths = reversedPaths.reverse();\n      let target = operations;\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`);\n        }\n        target = target[path];\n      }\n      target[lastPath] = files[key];\n    }\n  }\n  return operations.variables;\n}\nfunction getGraphQLInput(request) {\n  var _a, _b;\n  switch (request.method) {\n    case \"GET\": {\n      const query = request.url.searchParams.get(\"query\");\n      const variables = request.url.searchParams.get(\"variables\") || \"\";\n      return {\n        query,\n        variables: jsonParse(variables)\n      };\n    }\n    case \"POST\": {\n      if ((_a = request.body) == null ? void 0 : _a.query) {\n        const { query, variables } = request.body;\n        return {\n          query,\n          variables\n        };\n      }\n      if ((_b = request.body) == null ? void 0 : _b.operations) {\n        const { operations, map, ...files } = request.body;\n        const parsedOperations = jsonParse(\n          operations\n        ) || {};\n        if (!parsedOperations.query) {\n          return null;\n        }\n        const parsedMap = jsonParse(map || \"\") || {};\n        const variables = parsedOperations.variables ? extractMultipartVariables(\n          parsedOperations.variables,\n          parsedMap,\n          files\n        ) : {};\n        return {\n          query: parsedOperations.query,\n          variables\n        };\n      }\n    }\n    default:\n      return null;\n  }\n}\nfunction parseGraphQLRequest(request) {\n  const input = getGraphQLInput(request);\n  if (!input || !input.query) {\n    return void 0;\n  }\n  const { query, variables } = input;\n  const parsedResult = parseQuery(query);\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s',\n        request.method,\n        requestPublicUrl,\n        parsedResult.message\n      )\n    );\n  }\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables\n  };\n}\n\n// src/utils/logging/getStatusCodeColor.ts\nfunction getStatusCodeColor(status2) {\n  if (status2 < 300) {\n    return \"#69AB32\" /* Success */;\n  }\n  if (status2 < 400) {\n    return \"#F0BB4B\" /* Warning */;\n  }\n  return \"#E95F5D\" /* Danger */;\n}\n\n// src/utils/logging/getTimestamp.ts\nfunction getTimestamp() {\n  const now = new Date();\n  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map((chunk) => chunk.slice(0, 2)).map((chunk) => chunk.padStart(2, \"0\")).join(\":\");\n}\n\n// src/utils/logging/prepareRequest.ts\nfunction prepareRequest(request) {\n  return {\n    ...request,\n    body: request.body,\n    headers: request.headers.all()\n  };\n}\n\n// src/utils/logging/prepareResponse.ts\nvar import_headers_polyfill6 = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.js\");\nfunction prepareResponse(res) {\n  const responseHeaders = (0, import_headers_polyfill6.objectToHeaders)(res.headers);\n  const parsedBody = parseBody(res.body, responseHeaders);\n  return {\n    ...res,\n    body: parsedBody\n  };\n}\n\n// src/utils/matching/matchRequestUrl.ts\nvar import_path_to_regexp = __webpack_require__(/*! path-to-regexp */ \"(ssr)/../../node_modules/msw/node_modules/path-to-regexp/dist.es2015/index.js\");\nvar import_getCleanUrl = __webpack_require__(/*! @mswjs/interceptors/lib/utils/getCleanUrl.js */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/utils/getCleanUrl.js\");\n\n// src/utils/url/cleanUrl.ts\nvar REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g;\nfunction getSearchParams(path) {\n  return new URL(`/${path}`, \"http://localhost\").searchParams;\n}\nfunction cleanUrl(path) {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, \"\");\n}\n\n// src/utils/url/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n}\n\n// src/utils/url/getAbsoluteUrl.ts\nfunction getAbsoluteUrl(path, baseUrl) {\n  if (isAbsoluteUrl(path)) {\n    return path;\n  }\n  if (path.startsWith(\"*\")) {\n    return path;\n  }\n  const origin = baseUrl || typeof document !== \"undefined\" && document.baseURI;\n  return origin ? decodeURI(new URL(encodeURI(path), origin).href) : path;\n}\n\n// src/utils/matching/normalizePath.ts\nfunction normalizePath(path, baseUrl) {\n  if (path instanceof RegExp) {\n    return path;\n  }\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);\n  return cleanUrl(maybeAbsoluteUrl);\n}\n\n// src/utils/matching/matchRequestUrl.ts\nfunction coercePath(path) {\n  return path.replace(\n    /([:a-zA-Z_-]*)(\\*{1,2})+/g,\n    (_, parameterName, wildcard) => {\n      const expression = \"(.*)\";\n      if (!parameterName) {\n        return expression;\n      }\n      return parameterName.startsWith(\":\") ? `${parameterName}${wildcard}` : `${parameterName}${expression}`;\n    }\n  ).replace(/([^\\/])(:)(?=\\d+)/, \"$1\\\\$2\").replace(/^([^\\/]+)(:)(?=\\/\\/)/, \"$1\\\\$2\");\n}\nfunction matchRequestUrl(url, path, baseUrl) {\n  const normalizedPath = normalizePath(path, baseUrl);\n  const cleanPath = typeof normalizedPath === \"string\" ? coercePath(normalizedPath) : normalizedPath;\n  const cleanUrl2 = (0, import_getCleanUrl.getCleanUrl)(url);\n  const result = (0, import_path_to_regexp.match)(cleanPath, { decode: decodeURIComponent })(cleanUrl2);\n  const params = result && result.params || {};\n  return {\n    matches: result !== false,\n    params\n  };\n}\n\n// src/handlers/RequestHandler.ts\nvar import_headers_polyfill8 = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.js\");\n\n// src/response.ts\nvar import_headers_polyfill7 = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.js\");\n\n// src/utils/internal/compose.ts\nfunction compose(...fns) {\n  return (...args) => {\n    return fns.reduceRight((leftFn, rightFn) => {\n      return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);\n    }, args[0]);\n  };\n}\n\n// src/response.ts\nvar defaultResponse = {\n  status: 200,\n  statusText: \"OK\",\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false\n};\nvar defaultResponseTransformers = [];\nfunction createResponseComposition(responseOverrides, defaultTransformers = defaultResponseTransformers) {\n  return async (...transformers) => {\n    const initialResponse = Object.assign(\n      {},\n      defaultResponse,\n      {\n        headers: new import_headers_polyfill7.Headers({\n          \"x-powered-by\": \"msw\"\n        })\n      },\n      responseOverrides\n    );\n    const resolvedTransformers = [\n      ...defaultTransformers,\n      ...transformers\n    ].filter(Boolean);\n    const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;\n    return resolvedResponse;\n  };\n}\nvar response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({ once: true }),\n  networkError(message) {\n    throw new NetworkError(message);\n  }\n});\n\n// src/utils/internal/getCallFrame.ts\nvar SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/;\nvar BUILD_FRAME = /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/;\nfunction getCallFrame(error2) {\n  const stack = error2.stack;\n  if (!stack) {\n    return;\n  }\n  const frames = stack.split(\"\\n\").slice(1);\n  const declarationFrame = frames.find((frame) => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame));\n  });\n  if (!declarationFrame) {\n    return;\n  }\n  const declarationPath = declarationFrame.replace(/\\s*at [^()]*\\(([^)]+)\\)/, \"$1\").replace(/^@/, \"\");\n  return declarationPath;\n}\n\n// src/utils/internal/isIterable.ts\nfunction isIterable(fn) {\n  if (!fn) {\n    return false;\n  }\n  return typeof fn[Symbol.iterator] == \"function\";\n}\n\n// src/handlers/RequestHandler.ts\nvar defaultContext = {\n  status,\n  set,\n  delay,\n  fetch\n};\nvar RequestHandler = class {\n  constructor(options) {\n    this.shouldSkip = false;\n    this.ctx = options.ctx || defaultContext;\n    this.resolver = options.resolver;\n    const callFrame = getCallFrame(new Error());\n    this.info = {\n      ...options.info,\n      callFrame\n    };\n  }\n  parse(_request, _resolutionContext) {\n    return null;\n  }\n  test(request, resolutionContext) {\n    return this.predicate(\n      request,\n      this.parse(request, resolutionContext),\n      resolutionContext\n    );\n  }\n  getPublicRequest(request, _parsedResult) {\n    return request;\n  }\n  markAsSkipped(shouldSkip = true) {\n    this.shouldSkip = shouldSkip;\n  }\n  async run(request, resolutionContext) {\n    if (this.shouldSkip) {\n      return null;\n    }\n    const parsedResult = this.parse(request, resolutionContext);\n    const shouldIntercept = this.predicate(\n      request,\n      parsedResult,\n      resolutionContext\n    );\n    if (!shouldIntercept) {\n      return null;\n    }\n    const publicRequest = this.getPublicRequest(request, parsedResult);\n    const executeResolver = this.wrapResolver(this.resolver);\n    const mockedResponse = await executeResolver(\n      publicRequest,\n      response,\n      this.ctx\n    );\n    return this.createExecutionResult(\n      parsedResult,\n      publicRequest,\n      mockedResponse\n    );\n  }\n  wrapResolver(resolver) {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || await resolver(req, res, ctx);\n      if (isIterable(result)) {\n        const { value, done } = result[Symbol.iterator]().next();\n        const nextResponse = await value;\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult;\n        }\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result;\n        }\n        this.resolverGeneratorResult = nextResponse;\n        return nextResponse;\n      }\n      return result;\n    };\n  }\n  createExecutionResult(parsedResult, request, response2) {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response2 || null\n    };\n  }\n};\n\n// src/handlers/RestHandler.ts\nvar RESTMethods = /* @__PURE__ */ ((RESTMethods2) => {\n  RESTMethods2[\"HEAD\"] = \"HEAD\";\n  RESTMethods2[\"GET\"] = \"GET\";\n  RESTMethods2[\"POST\"] = \"POST\";\n  RESTMethods2[\"PUT\"] = \"PUT\";\n  RESTMethods2[\"PATCH\"] = \"PATCH\";\n  RESTMethods2[\"OPTIONS\"] = \"OPTIONS\";\n  RESTMethods2[\"DELETE\"] = \"DELETE\";\n  return RESTMethods2;\n})(RESTMethods || {});\nvar restContext = {\n  ...defaultContext,\n  cookie,\n  body,\n  text,\n  json,\n  xml\n};\nvar RestRequest = class extends MockedRequest {\n  constructor(request, params) {\n    super(request.url, {\n      ...request,\n      body: request[\"_body\"]\n    });\n    this.params = params;\n    this.id = request.id;\n  }\n};\nvar RestHandler = class extends RequestHandler {\n  constructor(method, path, resolver) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method\n      },\n      ctx: restContext,\n      resolver\n    });\n    this.checkRedundantQueryParameters();\n  }\n  checkRedundantQueryParameters() {\n    const { method, path } = this.info;\n    if (path instanceof RegExp) {\n      return;\n    }\n    const url = cleanUrl(path);\n    if (url === path) {\n      return;\n    }\n    const searchParams = getSearchParams(path);\n    const queryParams = [];\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName);\n    });\n    devUtils.warn(\n      `Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`\n    );\n  }\n  parse(request, resolutionContext) {\n    return matchRequestUrl(\n      request.url,\n      this.info.path,\n      resolutionContext == null ? void 0 : resolutionContext.baseUrl\n    );\n  }\n  getPublicRequest(request, parsedResult) {\n    return new RestRequest(request, parsedResult.params || {});\n  }\n  predicate(request, parsedResult) {\n    const matchesMethod = this.info.method instanceof RegExp ? this.info.method.test(request.method) : isStringEqual(this.info.method, request.method);\n    return matchesMethod && parsedResult.matches;\n  }\n  log(request, response2) {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    console.groupCollapsed(\n      devUtils.formatMessage(\"%s %s %s (%c%s%c)\"),\n      getTimestamp(),\n      request.method,\n      publicUrl,\n      `color:${statusColor}`,\n      `${response2.status} ${response2.statusText}`,\n      \"color:inherit\"\n    );\n    console.log(\"Request\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/context/field.ts\nvar import_outvariant3 = __webpack_require__(/*! outvariant */ \"(ssr)/../../node_modules/outvariant/lib/index.js\");\nvar field = (fieldName, fieldValue) => {\n  return (res) => {\n    validateFieldName(fieldName);\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { [fieldName]: fieldValue });\n    return json(nextBody)(res);\n  };\n};\nfunction validateFieldName(fieldName) {\n  (0, import_outvariant3.invariant)(\n    fieldName.trim() !== \"\",\n    devUtils.formatMessage(\n      \"Failed to set a custom field on a GraphQL response: field name cannot be empty.\"\n    )\n  );\n  (0, import_outvariant3.invariant)(\n    fieldName !== \"data\",\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?',\n      fieldName\n    )\n  );\n  (0, import_outvariant3.invariant)(\n    fieldName !== \"errors\",\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?',\n      fieldName\n    )\n  );\n  (0, import_outvariant3.invariant)(\n    fieldName !== \"extensions\",\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?',\n      fieldName\n    )\n  );\n}\n\n// src/utils/internal/tryCatch.ts\nfunction tryCatch(fn, onException) {\n  try {\n    const result = fn();\n    return result;\n  } catch (error2) {\n    onException == null ? void 0 : onException(error2);\n  }\n}\n\n// src/handlers/GraphQLHandler.ts\nvar graphqlContext = {\n  ...defaultContext,\n  data,\n  extensions,\n  errors,\n  cookie,\n  field\n};\nfunction isDocumentNode(value) {\n  if (value == null) {\n    return false;\n  }\n  return typeof value === \"object\" && \"kind\" in value && \"definitions\" in value;\n}\nvar GraphQLRequest = class extends MockedRequest {\n  constructor(request, variables, operationName) {\n    super(request.url, {\n      ...request,\n      body: request[\"_body\"]\n    });\n    this.variables = variables;\n    this.operationName = operationName;\n  }\n};\nvar GraphQLHandler = class extends RequestHandler {\n  constructor(operationType, operationName, endpoint, resolver) {\n    let resolvedOperationName = operationName;\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName);\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`\n        );\n      }\n      if (!parsedNode.operationName) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`\n        );\n      }\n      resolvedOperationName = parsedNode.operationName;\n    }\n    const header = operationType === \"all\" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`;\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName\n      },\n      ctx: graphqlContext,\n      resolver\n    });\n    this.endpoint = endpoint;\n  }\n  parse(request) {\n    return tryCatch(\n      () => parseGraphQLRequest(request),\n      (error2) => console.error(error2.message)\n    );\n  }\n  getPublicRequest(request, parsedResult) {\n    var _a, _b;\n    return new GraphQLRequest(\n      request,\n      (_a = parsedResult == null ? void 0 : parsedResult.variables) != null ? _a : {},\n      (_b = parsedResult == null ? void 0 : parsedResult.operationName) != null ? _b : \"\"\n    );\n  }\n  predicate(request, parsedResult) {\n    if (!parsedResult) {\n      return false;\n    }\n    if (!parsedResult.operationName && this.info.operationType !== \"all\") {\n      const publicUrl = getPublicUrlFromRequest(request);\n      devUtils.warn(`Failed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation()\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation      `);\n      return false;\n    }\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint);\n    const hasMatchingOperationType = this.info.operationType === \"all\" || parsedResult.operationType === this.info.operationType;\n    const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(parsedResult.operationName || \"\") : parsedResult.operationName === this.info.operationName;\n    return hasMatchingUrl.matches && hasMatchingOperationType && hasMatchingOperationName;\n  }\n  log(request, response2, parsedRequest) {\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    const requestInfo = (parsedRequest == null ? void 0 : parsedRequest.operationName) ? `${parsedRequest == null ? void 0 : parsedRequest.operationType} ${parsedRequest == null ? void 0 : parsedRequest.operationName}` : `anonymous ${parsedRequest == null ? void 0 : parsedRequest.operationType}`;\n    console.groupCollapsed(\n      devUtils.formatMessage(\"%s %s (%c%s%c)\"),\n      getTimestamp(),\n      `${requestInfo}`,\n      `color:${statusColor}`,\n      `${response2.status} ${response2.statusText}`,\n      \"color:inherit\"\n    );\n    console.log(\"Request:\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response:\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/utils/request/onUnhandledRequest.ts\nvar MAX_MATCH_SCORE = 3;\nvar MAX_SUGGESTION_COUNT = 4;\nvar TYPE_MATCH_DELTA = 0.5;\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce(\n    (groups, handler) => {\n      if (handler instanceof RestHandler) {\n        groups.rest.push(handler);\n      }\n      if (handler instanceof GraphQLHandler) {\n        groups.graphql.push(handler);\n      }\n      return groups;\n    },\n    {\n      rest: [],\n      graphql: []\n    }\n  );\n}\nfunction getRestHandlerScore() {\n  return (request, handler) => {\n    const { path, method } = handler.info;\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n    const hasSameMethod = isStringEqual(request.method, method);\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    const score = (0, import_js_levenshtein.default)(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === \"undefined\") {\n      return Infinity;\n    }\n    const { operationType, operationName } = handler.info;\n    if (typeof operationName !== \"string\") {\n      return Infinity;\n    }\n    const hasSameOperationType = parsedQuery.operationType === operationType;\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    const score = (0, import_js_levenshtein.default)(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\nfunction getSuggestedHandler(request, handlers, getScore) {\n  const suggestedHandlers = handlers.reduce((suggestions, handler) => {\n    const score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort(([leftScore], [rightScore]) => leftScore - rightScore).filter(([score]) => score <= MAX_MATCH_SCORE).slice(0, MAX_SUGGESTION_COUNT).map(([, handler]) => handler);\n  return suggestedHandlers;\n}\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return `Did you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `  \\u2022 ${handler.info.header}`).join(\"\\n\")}`;\n  }\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`;\n}\nfunction onUnhandledRequest(request, handlers, strategy = \"warn\") {\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));\n  function generateHandlerSuggestion() {\n    const handlerGroups = groupHandlersByType(handlers);\n    const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n    const suggestedHandlers = getSuggestedHandler(\n      request,\n      relevantHandlers,\n      parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore()\n    );\n    return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : \"\";\n  }\n  function generateUnhandledRequestMessage() {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;\n    const handlerSuggestion = generateHandlerSuggestion();\n    const messageTemplate = [\n      `captured a request without a matching request handler:`,\n      `  \\u2022 ${requestHeader}`,\n      handlerSuggestion,\n      `If you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks`\n    ].filter(Boolean);\n    return messageTemplate.join(\"\\n\\n\");\n  }\n  function applyStrategy(strategy2) {\n    const message = generateUnhandledRequestMessage();\n    switch (strategy2) {\n      case \"error\": {\n        devUtils.error(\"Error: %s\", message);\n        throw new Error(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'\n          )\n        );\n      }\n      case \"warn\": {\n        devUtils.warn(\"Warning: %s\", message);\n        break;\n      }\n      case \"bypass\":\n        break;\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy2\n          )\n        );\n    }\n  }\n  if (typeof strategy === \"function\") {\n    strategy(request, {\n      warning: applyStrategy.bind(null, \"warn\"),\n      error: applyStrategy.bind(null, \"error\")\n    });\n    return;\n  }\n  applyStrategy(strategy);\n}\n\n// src/utils/request/readResponseCookies.ts\nvar import_cookies2 = __webpack_require__(/*! @mswjs/cookies */ \"(ssr)/../../node_modules/@mswjs/cookies/lib/index.js\");\nfunction readResponseCookies(request, response2) {\n  import_cookies2.store.add({ ...request, url: request.url.toString() }, response2);\n  import_cookies2.store.persist();\n}\n\n// src/utils/handleRequest.ts\nasync function handleRequest(request, handlers, options, emitter, handleRequestOptions) {\n  var _a, _b, _c, _d, _e, _f;\n  emitter.emit(\"request:start\", request);\n  if (request.headers.get(\"x-msw-bypass\") === \"true\") {\n    emitter.emit(\"request:end\", request);\n    (_a = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _a.call(handleRequestOptions, request);\n    return;\n  }\n  const [lookupError, lookupResult] = await (0, import_until2.until)(() => {\n    return getResponse(\n      request,\n      handlers,\n      handleRequestOptions == null ? void 0 : handleRequestOptions.resolutionContext\n    );\n  });\n  if (lookupError) {\n    emitter.emit(\"unhandledException\", lookupError, request);\n    throw lookupError;\n  }\n  const { handler, response: response2 } = lookupResult;\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n    emitter.emit(\"request:unhandled\", request);\n    emitter.emit(\"request:end\", request);\n    (_b = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _b.call(handleRequestOptions, request);\n    return;\n  }\n  if (!response2) {\n    devUtils.warn(\n      `Expected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\n\n  \\u2022 %s\n    %s`,\n      response2,\n      handler.info.header,\n      handler.info.callFrame\n    );\n    emitter.emit(\"request:end\", request);\n    (_c = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _c.call(handleRequestOptions, request);\n    return;\n  }\n  if (response2.passthrough) {\n    emitter.emit(\"request:end\", request);\n    (_d = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _d.call(handleRequestOptions, request);\n    return;\n  }\n  readResponseCookies(request, response2);\n  emitter.emit(\"request:match\", request);\n  const requiredLookupResult = lookupResult;\n  const transformedResponse = ((_e = handleRequestOptions == null ? void 0 : handleRequestOptions.transformResponse) == null ? void 0 : _e.call(handleRequestOptions, response2)) || response2;\n  (_f = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponse) == null ? void 0 : _f.call(\n    handleRequestOptions,\n    transformedResponse,\n    requiredLookupResult\n  );\n  emitter.emit(\"request:end\", request);\n  return transformedResponse;\n}\n\n// src/utils/logging/serializeResponse.ts\nvar import_headers_polyfill9 = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.js\");\nasync function serializeResponse(response2) {\n  return {\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: (0, import_headers_polyfill9.flattenHeadersObject)((0, import_headers_polyfill9.headersToObject)(response2.headers)),\n    body: await response2.clone().text()\n  };\n}\n\n// src/setupWorker/start/createRequestListener.ts\nvar createRequestListener = (context, options) => {\n  return async (event, message) => {\n    var _a;\n    const messageChannel = new WorkerChannel(event.ports[0]);\n    const request = parseWorkerRequest(message.payload);\n    try {\n      await handleRequest(\n        request,\n        context.requestHandlers,\n        options,\n        context.emitter,\n        {\n          transformResponse,\n          onPassthroughResponse() {\n            messageChannel.postMessage(\"NOT_FOUND\");\n          },\n          async onMockedResponse(response2, { handler, publicRequest, parsedRequest }) {\n            if (response2.body instanceof ReadableStream) {\n              throw new Error(\n                devUtils.formatMessage(\n                  'Failed to construct a mocked response with a \"ReadableStream\" body: mocked streams are not supported. Follow https://github.com/mswjs/msw/issues/1336 for more details.'\n                )\n              );\n            }\n            const responseInstance = new Response(response2.body, response2);\n            const responseForLogs = responseInstance.clone();\n            const responseBodyBuffer = await responseInstance.arrayBuffer();\n            const responseBody = response2.body == null ? null : responseBodyBuffer;\n            messageChannel.postMessage(\n              \"MOCK_RESPONSE\",\n              {\n                ...response2,\n                body: responseBody\n              },\n              [responseBodyBuffer]\n            );\n            if (!options.quiet) {\n              context.emitter.once(\"response:mocked\", async () => {\n                handler.log(\n                  publicRequest,\n                  await serializeResponse(responseForLogs),\n                  parsedRequest\n                );\n              });\n            }\n          }\n        }\n      );\n    } catch (error2) {\n      if (error2 instanceof NetworkError) {\n        messageChannel.postMessage(\"NETWORK_ERROR\", {\n          name: error2.name,\n          message: error2.message\n        });\n        return;\n      }\n      if (error2 instanceof Error) {\n        devUtils.error(\n          `Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`,\n          request.method,\n          request.url,\n          (_a = error2.stack) != null ? _a : error2\n        );\n        messageChannel.postMessage(\"MOCK_RESPONSE\", {\n          status: 500,\n          statusText: \"Request Handler Error\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({\n            name: error2.name,\n            message: error2.message,\n            stack: error2.stack\n          })\n        });\n      }\n    }\n  };\n};\nfunction transformResponse(response2) {\n  return {\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: response2.headers.all(),\n    body: response2.body,\n    delay: response2.delay\n  };\n}\n\n// src/utils/internal/requestIntegrityCheck.ts\nasync function requestIntegrityCheck(context, serviceWorker) {\n  context.workerChannel.send(\"INTEGRITY_CHECK_REQUEST\");\n  const { payload: actualChecksum } = await context.events.once(\n    \"INTEGRITY_CHECK_RESPONSE\"\n  );\n  if (actualChecksum !== \"3d6b9f06410d179a7f7404d4bf4c3c70\") {\n    throw new Error(\n      `Currently active Service Worker (${actualChecksum}) is behind the latest published one (${\"3d6b9f06410d179a7f7404d4bf4c3c70\"}).`\n    );\n  }\n  return serviceWorker;\n}\n\n// src/utils/deferNetworkRequestsUntil.ts\nvar import_until3 = __webpack_require__(/*! @open-draft/until */ \"(ssr)/../../node_modules/@open-draft/until/lib/index.js\");\nfunction deferNetworkRequestsUntil(predicatePromise) {\n  const originalXhrSend = window.XMLHttpRequest.prototype.send;\n  window.XMLHttpRequest.prototype.send = function(...args) {\n    (0, import_until3.until)(() => predicatePromise).then(() => {\n      window.XMLHttpRequest.prototype.send = originalXhrSend;\n      this.send(...args);\n    });\n  };\n  const originalFetch = window.fetch;\n  window.fetch = async (...args) => {\n    await (0, import_until3.until)(() => predicatePromise);\n    window.fetch = originalFetch;\n    return window.fetch(...args);\n  };\n}\n\n// src/setupWorker/start/createResponseListener.ts\nfunction createResponseListener(context) {\n  return (_, message) => {\n    var _a;\n    const { payload: responseJson } = message;\n    if ((_a = responseJson.type) == null ? void 0 : _a.includes(\"opaque\")) {\n      return;\n    }\n    const response2 = new Response(responseJson.body || null, responseJson);\n    const isMockedResponse = response2.headers.get(\"x-powered-by\") === \"msw\";\n    if (isMockedResponse) {\n      context.emitter.emit(\"response:mocked\", response2, responseJson.requestId);\n    } else {\n      context.emitter.emit(\"response:bypass\", response2, responseJson.requestId);\n    }\n  };\n}\n\n// src/setupWorker/start/utils/validateWorkerScope.ts\nfunction validateWorkerScope(registration, options) {\n  if (!(options == null ? void 0 : options.quiet) && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(\n      `Cannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.`\n    );\n  }\n}\n\n// src/setupWorker/start/createStartHandler.ts\nvar createStartHandler = (context) => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      context.events.removeAllListeners();\n      context.workerChannel.on(\n        \"REQUEST\",\n        createRequestListener(context, options)\n      );\n      context.workerChannel.on(\"RESPONSE\", createResponseListener(context));\n      const instance = await getWorkerInstance(\n        options.serviceWorker.url,\n        options.serviceWorker.options,\n        options.findWorker\n      );\n      const [worker, registration] = instance;\n      if (!worker) {\n        const missingWorkerMessage = (customOptions == null ? void 0 : customOptions.findWorker) ? devUtils.formatMessage(\n          `Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`,\n          options.serviceWorker.url\n        ) : devUtils.formatMessage(\n          `Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,\n          options.serviceWorker.url,\n          location.host\n        );\n        throw new Error(missingWorkerMessage);\n      }\n      context.worker = worker;\n      context.registration = registration;\n      context.events.addListener(window, \"beforeunload\", () => {\n        if (worker.state !== \"redundant\") {\n          context.workerChannel.send(\"CLIENT_CLOSED\");\n        }\n        window.clearInterval(context.keepAliveInterval);\n      });\n      const [integrityError] = await (0, import_until4.until)(\n        () => requestIntegrityCheck(context, worker)\n      );\n      if (integrityError) {\n        devUtils.error(`Detected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues      `);\n      }\n      context.keepAliveInterval = window.setInterval(\n        () => context.workerChannel.send(\"KEEPALIVE_REQUEST\"),\n        5e3\n      );\n      validateWorkerScope(registration, context.startOptions);\n      return registration;\n    };\n    const workerRegistration = startWorkerInstance().then(\n      async (registration) => {\n        const pendingInstance = registration.installing || registration.waiting;\n        if (pendingInstance) {\n          await new Promise((resolve) => {\n            pendingInstance.addEventListener(\"statechange\", () => {\n              if (pendingInstance.state === \"activated\") {\n                return resolve();\n              }\n            });\n          });\n        }\n        await enableMocking(context, options).catch((error2) => {\n          throw new Error(`Failed to enable mocking: ${error2 == null ? void 0 : error2.message}`);\n        });\n        return registration;\n      }\n    );\n    if (options.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration);\n    }\n    return workerRegistration;\n  };\n};\n\n// src/setupWorker/stop/utils/printStopMessage.ts\nfunction printStopMessage(args = {}) {\n  if (args.quiet) {\n    return;\n  }\n  console.log(\n    `%c${devUtils.formatMessage(\"Mocking disabled.\")}`,\n    \"color:orangered;font-weight:bold;\"\n  );\n}\n\n// src/setupWorker/stop/createStop.ts\nvar createStop = (context) => {\n  return function stop() {\n    var _a;\n    if (!context.isMockingEnabled) {\n      devUtils.warn(\n        'Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.'\n      );\n      return;\n    }\n    context.workerChannel.send(\"MOCK_DEACTIVATE\");\n    context.isMockingEnabled = false;\n    window.clearInterval(context.keepAliveInterval);\n    printStopMessage({ quiet: (_a = context.startOptions) == null ? void 0 : _a.quiet });\n  };\n};\n\n// src/setupWorker/start/utils/prepareStartHandler.ts\nvar DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: \"/mockServiceWorker.js\",\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: \"warn\",\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl;\n  }\n};\n\n// src/setupWorker/start/createFallbackRequestListener.ts\nvar import_interceptors3 = __webpack_require__(/*! @mswjs/interceptors */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/index.js\");\nvar import_fetch3 = __webpack_require__(/*! @mswjs/interceptors/lib/interceptors/fetch */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/interceptors/fetch/index.js\");\nvar import_XMLHttpRequest = __webpack_require__(/*! @mswjs/interceptors/lib/interceptors/XMLHttpRequest */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/interceptors/XMLHttpRequest/index.js\");\n\n// src/utils/request/createResponseFromIsomorphicResponse.ts\nfunction createResponseFromIsomorphicResponse(response2) {\n  return new Response(response2.body, {\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: response2.headers\n  });\n}\n\n// src/setupWorker/start/createFallbackRequestListener.ts\nfunction createFallbackRequestListener(context, options) {\n  const interceptor = new import_interceptors3.BatchInterceptor({\n    name: \"fallback\",\n    interceptors: [new import_fetch3.FetchInterceptor(), new import_XMLHttpRequest.XMLHttpRequestInterceptor()]\n  });\n  interceptor.on(\"request\", async (request) => {\n    const mockedRequest = new MockedRequest(request.url, {\n      ...request,\n      body: await request.arrayBuffer()\n    });\n    const response2 = await handleRequest(\n      mockedRequest,\n      context.requestHandlers,\n      options,\n      context.emitter,\n      {\n        transformResponse(response3) {\n          return {\n            status: response3.status,\n            statusText: response3.statusText,\n            headers: response3.headers.all(),\n            body: response3.body,\n            delay: response3.delay\n          };\n        },\n        onMockedResponse(_, { handler, publicRequest, parsedRequest }) {\n          if (!options.quiet) {\n            context.emitter.once(\"response:mocked\", async (response3) => {\n              handler.log(\n                publicRequest,\n                await serializeResponse(response3),\n                parsedRequest\n              );\n            });\n          }\n        }\n      }\n    );\n    if (response2) {\n      request.respondWith(response2);\n    }\n  });\n  interceptor.on(\"response\", (request, response2) => {\n    if (!request.id) {\n      return;\n    }\n    const browserResponse = createResponseFromIsomorphicResponse(response2);\n    if (response2.headers.get(\"x-powered-by\") === \"msw\") {\n      context.emitter.emit(\"response:mocked\", browserResponse, request.id);\n    } else {\n      context.emitter.emit(\"response:bypass\", browserResponse, request.id);\n    }\n  });\n  interceptor.apply();\n  return interceptor;\n}\n\n// src/setupWorker/start/createFallbackStart.ts\nfunction createFallbackStart(context) {\n  return async function start(options) {\n    context.fallbackInterceptor = createFallbackRequestListener(\n      context,\n      options\n    );\n    printStartMessage({\n      message: \"Mocking enabled (fallback mode).\",\n      quiet: options.quiet\n    });\n    return void 0;\n  };\n}\n\n// src/setupWorker/stop/createFallbackStop.ts\nfunction createFallbackStop(context) {\n  return function stop() {\n    var _a, _b;\n    (_a = context.fallbackInterceptor) == null ? void 0 : _a.dispose();\n    printStopMessage({ quiet: (_b = context.startOptions) == null ? void 0 : _b.quiet });\n  };\n}\n\n// src/SetupApi.ts\nvar import_outvariant4 = __webpack_require__(/*! outvariant */ \"(ssr)/../../node_modules/outvariant/lib/index.js\");\nvar import_strict_event_emitter = __webpack_require__(/*! strict-event-emitter */ \"(ssr)/../../node_modules/strict-event-emitter/lib/index.js\");\n\n// src/utils/internal/pipeEvents.ts\nfunction pipeEvents(source, destination) {\n  const rawEmit = source.emit;\n  if (rawEmit._isPiped) {\n    return;\n  }\n  source.emit = function(event, ...data2) {\n    destination.emit(event, ...data2);\n    return rawEmit.call(this, event, ...data2);\n  };\n  source.emit._isPiped = true;\n}\n\n// src/utils/internal/toReadonlyArray.ts\nfunction toReadonlyArray(source) {\n  const clone = [...source];\n  Object.freeze(clone);\n  return clone;\n}\n\n// src/SetupApi.ts\nvar SetupApi = class {\n  constructor(...initialHandlers) {\n    this.validateHandlers(...initialHandlers);\n    this.initialHandlers = toReadonlyArray(initialHandlers);\n    this.currentHandlers = [...initialHandlers];\n    this.emitter = new import_strict_event_emitter.Emitter();\n    this.publicEmitter = new import_strict_event_emitter.Emitter();\n    pipeEvents(this.emitter, this.publicEmitter);\n    this.events = this.createLifeCycleEvents();\n  }\n  validateHandlers(...handlers) {\n    for (const handler of handlers) {\n      (0, import_outvariant4.invariant)(\n        !Array.isArray(handler),\n        devUtils.formatMessage(\n          'Failed to construct \"%s\" given an Array of request handlers. Make sure you spread the request handlers when calling the respective setup function.'\n        ),\n        this.constructor.name\n      );\n    }\n  }\n  dispose() {\n    this.emitter.removeAllListeners();\n    this.publicEmitter.removeAllListeners();\n  }\n  use(...runtimeHandlers) {\n    this.currentHandlers.unshift(...runtimeHandlers);\n  }\n  restoreHandlers() {\n    this.currentHandlers.forEach((handler) => {\n      handler.markAsSkipped(false);\n    });\n  }\n  resetHandlers(...nextHandlers) {\n    this.currentHandlers = nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers];\n  }\n  listHandlers() {\n    return toReadonlyArray(this.currentHandlers);\n  }\n  createLifeCycleEvents() {\n    return {\n      on: (...args) => {\n        return this.publicEmitter.on(...args);\n      },\n      removeListener: (...args) => {\n        return this.publicEmitter.removeListener(...args);\n      },\n      removeAllListeners: (...args) => {\n        return this.publicEmitter.removeAllListeners(...args);\n      }\n    };\n  }\n};\n\n// src/setupWorker/setupWorker.ts\nvar SetupWorkerApi = class extends SetupApi {\n  constructor(...handlers) {\n    super(...handlers);\n    this.startHandler = null;\n    this.stopHandler = null;\n    (0, import_outvariant5.invariant)(\n      !(0, import_is_node_process3.isNodeProcess)(),\n      devUtils.formatMessage(\n        \"Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.\"\n      )\n    );\n    this.listeners = [];\n    this.context = this.createWorkerContext();\n  }\n  createWorkerContext() {\n    const context = {\n      isMockingEnabled: false,\n      startOptions: null,\n      worker: null,\n      registration: null,\n      requestHandlers: this.currentHandlers,\n      emitter: this.emitter,\n      workerChannel: {\n        on: (eventType, callback) => {\n          this.context.events.addListener(\n            navigator.serviceWorker,\n            \"message\",\n            (event) => {\n              if (event.source !== this.context.worker) {\n                return;\n              }\n              const message = event.data;\n              if (!message) {\n                return;\n              }\n              if (message.type === eventType) {\n                callback(event, message);\n              }\n            }\n          );\n        },\n        send: (type) => {\n          var _a;\n          (_a = this.context.worker) == null ? void 0 : _a.postMessage(type);\n        }\n      },\n      events: {\n        addListener: (target, eventType, callback) => {\n          target.addEventListener(eventType, callback);\n          this.listeners.push({ eventType, target, callback });\n          return () => {\n            target.removeEventListener(eventType, callback);\n          };\n        },\n        removeAllListeners: () => {\n          for (const { target, eventType, callback } of this.listeners) {\n            target.removeEventListener(eventType, callback);\n          }\n          this.listeners = [];\n        },\n        once: (eventType) => {\n          const bindings = [];\n          return new Promise((resolve, reject) => {\n            const handleIncomingMessage = (event) => {\n              try {\n                const message = event.data;\n                if (message.type === eventType) {\n                  resolve(message);\n                }\n              } catch (error2) {\n                reject(error2);\n              }\n            };\n            bindings.push(\n              this.context.events.addListener(\n                navigator.serviceWorker,\n                \"message\",\n                handleIncomingMessage\n              ),\n              this.context.events.addListener(\n                navigator.serviceWorker,\n                \"messageerror\",\n                reject\n              )\n            );\n          }).finally(() => {\n            bindings.forEach((unbind) => unbind());\n          });\n        }\n      },\n      useFallbackMode: !(\"serviceWorker\" in navigator) || location.protocol === \"file:\"\n    };\n    Object.defineProperties(context, {\n      requestHandlers: {\n        get: () => this.currentHandlers\n      }\n    });\n    this.startHandler = context.useFallbackMode ? createFallbackStart(context) : createStartHandler(context);\n    this.stopHandler = context.useFallbackMode ? createFallbackStop(context) : createStop(context);\n    return context;\n  }\n  async start(options = {}) {\n    this.context.startOptions = mergeRight(\n      DEFAULT_START_OPTIONS,\n      options\n    );\n    return await this.startHandler(this.context.startOptions, options);\n  }\n  printHandlers() {\n    const handlers = this.listHandlers();\n    handlers.forEach((handler) => {\n      const { header, callFrame } = handler.info;\n      const pragma = handler.info.hasOwnProperty(\"operationType\") ? \"[graphql]\" : \"[rest]\";\n      console.groupCollapsed(`${pragma} ${header}`);\n      if (callFrame) {\n        console.log(`Declaration: ${callFrame}`);\n      }\n      console.log(\"Handler:\", handler);\n      console.groupEnd();\n    });\n  }\n  stop() {\n    super.dispose();\n    this.context.events.removeAllListeners();\n    this.context.emitter.removeAllListeners();\n    this.stopHandler();\n  }\n};\nfunction setupWorker(...handlers) {\n  return new SetupWorkerApi(...handlers);\n}\n\n// src/rest.ts\nfunction createRestHandler(method) {\n  return (path, resolver) => {\n    return new RestHandler(method, path, resolver);\n  };\n}\nvar rest = {\n  all: createRestHandler(/.+/),\n  head: createRestHandler(\"HEAD\" /* HEAD */),\n  get: createRestHandler(\"GET\" /* GET */),\n  post: createRestHandler(\"POST\" /* POST */),\n  put: createRestHandler(\"PUT\" /* PUT */),\n  delete: createRestHandler(\"DELETE\" /* DELETE */),\n  patch: createRestHandler(\"PATCH\" /* PATCH */),\n  options: createRestHandler(\"OPTIONS\" /* OPTIONS */)\n};\n\n// src/graphql.ts\nfunction createScopedGraphQLHandler(operationType, url) {\n  return (operationName, resolver) => {\n    return new GraphQLHandler(\n      operationType,\n      operationName,\n      url,\n      resolver\n    );\n  };\n}\nfunction createGraphQLOperationHandler(url) {\n  return (resolver) => {\n    return new GraphQLHandler(\n      \"all\",\n      new RegExp(\".*\"),\n      url,\n      resolver\n    );\n  };\n}\nvar standardGraphQLHandlers = {\n  operation: createGraphQLOperationHandler(\"*\"),\n  query: createScopedGraphQLHandler(\"query\", \"*\"),\n  mutation: createScopedGraphQLHandler(\"mutation\", \"*\")\n};\nfunction createGraphQLLink(url) {\n  return {\n    operation: createGraphQLOperationHandler(url),\n    query: createScopedGraphQLHandler(\"query\", url),\n    mutation: createScopedGraphQLHandler(\"mutation\", url)\n  };\n}\nvar graphql = {\n  ...standardGraphQLHandlers,\n  link: createGraphQLLink\n};\n\n// src/index.ts\ncheckGlobals();\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL21zdy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkcseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixtQkFBTyxDQUFDLGdGQUFrQjtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQXNCTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9tc3cvbGliL2luZGV4LmpzP2M4OGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgc3JjX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNyY19leHBvcnRzLCB7XG4gIEdyYXBoUUxIYW5kbGVyOiAoKSA9PiBHcmFwaFFMSGFuZGxlcixcbiAgTW9ja2VkUmVxdWVzdDogKCkgPT4gTW9ja2VkUmVxdWVzdCxcbiAgUkVTVE1ldGhvZHM6ICgpID0+IFJFU1RNZXRob2RzLFxuICBSZXF1ZXN0SGFuZGxlcjogKCkgPT4gUmVxdWVzdEhhbmRsZXIsXG4gIFJlc3RIYW5kbGVyOiAoKSA9PiBSZXN0SGFuZGxlcixcbiAgU2V0dXBBcGk6ICgpID0+IFNldHVwQXBpLFxuICBTZXR1cFdvcmtlckFwaTogKCkgPT4gU2V0dXBXb3JrZXJBcGksXG4gIGNsZWFuVXJsOiAoKSA9PiBjbGVhblVybCxcbiAgY29tcG9zZTogKCkgPT4gY29tcG9zZSxcbiAgY29udGV4dDogKCkgPT4gY29udGV4dF9leHBvcnRzLFxuICBjcmVhdGVSZXNwb25zZUNvbXBvc2l0aW9uOiAoKSA9PiBjcmVhdGVSZXNwb25zZUNvbXBvc2l0aW9uLFxuICBkZWZhdWx0Q29udGV4dDogKCkgPT4gZGVmYXVsdENvbnRleHQsXG4gIGRlZmF1bHRSZXNwb25zZTogKCkgPT4gZGVmYXVsdFJlc3BvbnNlLFxuICBncmFwaHFsOiAoKSA9PiBncmFwaHFsLFxuICBncmFwaHFsQ29udGV4dDogKCkgPT4gZ3JhcGhxbENvbnRleHQsXG4gIGhhbmRsZVJlcXVlc3Q6ICgpID0+IGhhbmRsZVJlcXVlc3QsXG4gIG1hdGNoUmVxdWVzdFVybDogKCkgPT4gbWF0Y2hSZXF1ZXN0VXJsLFxuICByZXNwb25zZTogKCkgPT4gcmVzcG9uc2UsXG4gIHJlc3Q6ICgpID0+IHJlc3QsXG4gIHJlc3RDb250ZXh0OiAoKSA9PiByZXN0Q29udGV4dCxcbiAgc2V0dXBXb3JrZXI6ICgpID0+IHNldHVwV29ya2VyXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHNyY19leHBvcnRzKTtcblxuLy8gc3JjL2NvbnRleHQvaW5kZXgudHNcbnZhciBjb250ZXh0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNvbnRleHRfZXhwb3J0cywge1xuICBib2R5OiAoKSA9PiBib2R5LFxuICBjb29raWU6ICgpID0+IGNvb2tpZSxcbiAgZGF0YTogKCkgPT4gZGF0YSxcbiAgZGVsYXk6ICgpID0+IGRlbGF5LFxuICBlcnJvcnM6ICgpID0+IGVycm9ycyxcbiAgZXh0ZW5zaW9uczogKCkgPT4gZXh0ZW5zaW9ucyxcbiAgZmV0Y2g6ICgpID0+IGZldGNoLFxuICBqc29uOiAoKSA9PiBqc29uLFxuICBzZXQ6ICgpID0+IHNldCxcbiAgc3RhdHVzOiAoKSA9PiBzdGF0dXMsXG4gIHRleHQ6ICgpID0+IHRleHQsXG4gIHhtbDogKCkgPT4geG1sXG59KTtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3N0YXR1c2VzQDIuMC4xL25vZGVfbW9kdWxlcy9zdGF0dXNlcy9jb2Rlcy5qc29uXG52YXIgY29kZXNfZGVmYXVsdCA9IHtcbiAgXCIxMDBcIjogXCJDb250aW51ZVwiLFxuICBcIjEwMVwiOiBcIlN3aXRjaGluZyBQcm90b2NvbHNcIixcbiAgXCIxMDJcIjogXCJQcm9jZXNzaW5nXCIsXG4gIFwiMTAzXCI6IFwiRWFybHkgSGludHNcIixcbiAgXCIyMDBcIjogXCJPS1wiLFxuICBcIjIwMVwiOiBcIkNyZWF0ZWRcIixcbiAgXCIyMDJcIjogXCJBY2NlcHRlZFwiLFxuICBcIjIwM1wiOiBcIk5vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uXCIsXG4gIFwiMjA0XCI6IFwiTm8gQ29udGVudFwiLFxuICBcIjIwNVwiOiBcIlJlc2V0IENvbnRlbnRcIixcbiAgXCIyMDZcIjogXCJQYXJ0aWFsIENvbnRlbnRcIixcbiAgXCIyMDdcIjogXCJNdWx0aS1TdGF0dXNcIixcbiAgXCIyMDhcIjogXCJBbHJlYWR5IFJlcG9ydGVkXCIsXG4gIFwiMjI2XCI6IFwiSU0gVXNlZFwiLFxuICBcIjMwMFwiOiBcIk11bHRpcGxlIENob2ljZXNcIixcbiAgXCIzMDFcIjogXCJNb3ZlZCBQZXJtYW5lbnRseVwiLFxuICBcIjMwMlwiOiBcIkZvdW5kXCIsXG4gIFwiMzAzXCI6IFwiU2VlIE90aGVyXCIsXG4gIFwiMzA0XCI6IFwiTm90IE1vZGlmaWVkXCIsXG4gIFwiMzA1XCI6IFwiVXNlIFByb3h5XCIsXG4gIFwiMzA3XCI6IFwiVGVtcG9yYXJ5IFJlZGlyZWN0XCIsXG4gIFwiMzA4XCI6IFwiUGVybWFuZW50IFJlZGlyZWN0XCIsXG4gIFwiNDAwXCI6IFwiQmFkIFJlcXVlc3RcIixcbiAgXCI0MDFcIjogXCJVbmF1dGhvcml6ZWRcIixcbiAgXCI0MDJcIjogXCJQYXltZW50IFJlcXVpcmVkXCIsXG4gIFwiNDAzXCI6IFwiRm9yYmlkZGVuXCIsXG4gIFwiNDA0XCI6IFwiTm90IEZvdW5kXCIsXG4gIFwiNDA1XCI6IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsXG4gIFwiNDA2XCI6IFwiTm90IEFjY2VwdGFibGVcIixcbiAgXCI0MDdcIjogXCJQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQwOFwiOiBcIlJlcXVlc3QgVGltZW91dFwiLFxuICBcIjQwOVwiOiBcIkNvbmZsaWN0XCIsXG4gIFwiNDEwXCI6IFwiR29uZVwiLFxuICBcIjQxMVwiOiBcIkxlbmd0aCBSZXF1aXJlZFwiLFxuICBcIjQxMlwiOiBcIlByZWNvbmRpdGlvbiBGYWlsZWRcIixcbiAgXCI0MTNcIjogXCJQYXlsb2FkIFRvbyBMYXJnZVwiLFxuICBcIjQxNFwiOiBcIlVSSSBUb28gTG9uZ1wiLFxuICBcIjQxNVwiOiBcIlVuc3VwcG9ydGVkIE1lZGlhIFR5cGVcIixcbiAgXCI0MTZcIjogXCJSYW5nZSBOb3QgU2F0aXNmaWFibGVcIixcbiAgXCI0MTdcIjogXCJFeHBlY3RhdGlvbiBGYWlsZWRcIixcbiAgXCI0MThcIjogXCJJJ20gYSBUZWFwb3RcIixcbiAgXCI0MjFcIjogXCJNaXNkaXJlY3RlZCBSZXF1ZXN0XCIsXG4gIFwiNDIyXCI6IFwiVW5wcm9jZXNzYWJsZSBFbnRpdHlcIixcbiAgXCI0MjNcIjogXCJMb2NrZWRcIixcbiAgXCI0MjRcIjogXCJGYWlsZWQgRGVwZW5kZW5jeVwiLFxuICBcIjQyNVwiOiBcIlRvbyBFYXJseVwiLFxuICBcIjQyNlwiOiBcIlVwZ3JhZGUgUmVxdWlyZWRcIixcbiAgXCI0MjhcIjogXCJQcmVjb25kaXRpb24gUmVxdWlyZWRcIixcbiAgXCI0MjlcIjogXCJUb28gTWFueSBSZXF1ZXN0c1wiLFxuICBcIjQzMVwiOiBcIlJlcXVlc3QgSGVhZGVyIEZpZWxkcyBUb28gTGFyZ2VcIixcbiAgXCI0NTFcIjogXCJVbmF2YWlsYWJsZSBGb3IgTGVnYWwgUmVhc29uc1wiLFxuICBcIjUwMFwiOiBcIkludGVybmFsIFNlcnZlciBFcnJvclwiLFxuICBcIjUwMVwiOiBcIk5vdCBJbXBsZW1lbnRlZFwiLFxuICBcIjUwMlwiOiBcIkJhZCBHYXRld2F5XCIsXG4gIFwiNTAzXCI6IFwiU2VydmljZSBVbmF2YWlsYWJsZVwiLFxuICBcIjUwNFwiOiBcIkdhdGV3YXkgVGltZW91dFwiLFxuICBcIjUwNVwiOiBcIkhUVFAgVmVyc2lvbiBOb3QgU3VwcG9ydGVkXCIsXG4gIFwiNTA2XCI6IFwiVmFyaWFudCBBbHNvIE5lZ290aWF0ZXNcIixcbiAgXCI1MDdcIjogXCJJbnN1ZmZpY2llbnQgU3RvcmFnZVwiLFxuICBcIjUwOFwiOiBcIkxvb3AgRGV0ZWN0ZWRcIixcbiAgXCI1MDlcIjogXCJCYW5kd2lkdGggTGltaXQgRXhjZWVkZWRcIixcbiAgXCI1MTBcIjogXCJOb3QgRXh0ZW5kZWRcIixcbiAgXCI1MTFcIjogXCJOZXR3b3JrIEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXCJcbn07XG5cbi8vIHNyYy9jb250ZXh0L3N0YXR1cy50c1xudmFyIHN0YXR1cyA9IChzdGF0dXNDb2RlLCBzdGF0dXNUZXh0KSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgcmVzLnN0YXR1cyA9IHN0YXR1c0NvZGU7XG4gICAgcmVzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0IHx8IGNvZGVzX2RlZmF1bHRbU3RyaW5nKHN0YXR1c0NvZGUpXTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQvc2V0LnRzXG52YXIgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGwgPSByZXF1aXJlKFwiaGVhZGVycy1wb2x5ZmlsbFwiKTtcbmZ1bmN0aW9uIHNldCguLi5hcmdzKSB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgY29uc3QgW25hbWUsIHZhbHVlXSA9IGFyZ3M7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXMuaGVhZGVycy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gKDAsIGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsLm9iamVjdFRvSGVhZGVycykobmFtZSk7XG4gICAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlMiwgbmFtZTIpID0+IHtcbiAgICAgICAgcmVzLmhlYWRlcnMuYXBwZW5kKG5hbWUyLCB2YWx1ZTIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG59XG5cbi8vIHNyYy9jb250ZXh0L2Nvb2tpZS50c1xudmFyIGNvb2tpZVV0aWxzID0gX190b0VTTShyZXF1aXJlKFwiY29va2llXCIpKTtcbnZhciBjb29raWUgPSAobmFtZSwgdmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICBjb25zdCBzZXJpYWxpemVkQ29va2llID0gY29va2llVXRpbHMuc2VyaWFsaXplKG5hbWUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICByZXMuaGVhZGVycy5hcHBlbmQoXCJTZXQtQ29va2llXCIsIHNlcmlhbGl6ZWRDb29raWUpO1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGRvY3VtZW50LmNvb2tpZSA9IHNlcmlhbGl6ZWRDb29raWU7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dC9ib2R5LnRzXG52YXIgYm9keSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIHJlcy5ib2R5ID0gdmFsdWU7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9qc29uUGFyc2UudHNcbmZ1bmN0aW9uIGpzb25QYXJzZSh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvaXNPYmplY3QudHNcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9tZXJnZVJpZ2h0LnRzXG5mdW5jdGlvbiBtZXJnZVJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyaWdodCkucmVkdWNlKChyZXN1bHQsIFtrZXksIHJpZ2h0VmFsdWVdKSA9PiB7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gcmVzdWx0W2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGVmdFZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHJpZ2h0VmFsdWUpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGxlZnRWYWx1ZS5jb25jYXQocmlnaHRWYWx1ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QobGVmdFZhbHVlKSAmJiBpc09iamVjdChyaWdodFZhbHVlKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZVJpZ2h0KGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXN1bHRba2V5XSA9IHJpZ2h0VmFsdWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgT2JqZWN0LmFzc2lnbih7fSwgbGVmdCkpO1xufVxuXG4vLyBzcmMvY29udGV4dC9qc29uLnRzXG52YXIganNvbiA9IChib2R5MikgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIHJlcy5oZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgcmVzLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5Mik7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L2RhdGEudHNcbnZhciBkYXRhID0gKHBheWxvYWQpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICBjb25zdCBwcmV2Qm9keSA9IGpzb25QYXJzZShyZXMuYm9keSkgfHwge307XG4gICAgY29uc3QgbmV4dEJvZHkgPSBtZXJnZVJpZ2h0KHByZXZCb2R5LCB7IGRhdGE6IHBheWxvYWQgfSk7XG4gICAgcmV0dXJuIGpzb24obmV4dEJvZHkpKHJlcyk7XG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dC9leHRlbnNpb25zLnRzXG52YXIgZXh0ZW5zaW9ucyA9IChwYXlsb2FkKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgY29uc3QgcHJldkJvZHkgPSBqc29uUGFyc2UocmVzLmJvZHkpIHx8IHt9O1xuICAgIGNvbnN0IG5leHRCb2R5ID0gbWVyZ2VSaWdodChwcmV2Qm9keSwgeyBleHRlbnNpb25zOiBwYXlsb2FkIH0pO1xuICAgIHJldHVybiBqc29uKG5leHRCb2R5KShyZXMpO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQvZGVsYXkudHNcbnZhciBpbXBvcnRfaXNfbm9kZV9wcm9jZXNzID0gcmVxdWlyZShcImlzLW5vZGUtcHJvY2Vzc1wiKTtcbnZhciBTRVRfVElNRU9VVF9NQVhfQUxMT1dFRF9JTlQgPSAyMTQ3NDgzNjQ3O1xudmFyIE1JTl9TRVJWRVJfUkVTUE9OU0VfVElNRSA9IDEwMDtcbnZhciBNQVhfU0VSVkVSX1JFU1BPTlNFX1RJTUUgPSA0MDA7XG52YXIgTk9ERV9TRVJWRVJfUkVTUE9OU0VfVElNRSA9IDU7XG52YXIgZ2V0UmFuZG9tU2VydmVyUmVzcG9uc2VUaW1lID0gKCkgPT4ge1xuICBpZiAoKDAsIGltcG9ydF9pc19ub2RlX3Byb2Nlc3MuaXNOb2RlUHJvY2VzcykoKSkge1xuICAgIHJldHVybiBOT0RFX1NFUlZFUl9SRVNQT05TRV9USU1FO1xuICB9XG4gIHJldHVybiBNYXRoLmZsb29yKFxuICAgIE1hdGgucmFuZG9tKCkgKiAoTUFYX1NFUlZFUl9SRVNQT05TRV9USU1FIC0gTUlOX1NFUlZFUl9SRVNQT05TRV9USU1FKSArIE1JTl9TRVJWRVJfUkVTUE9OU0VfVElNRVxuICApO1xufTtcbnZhciBkZWxheSA9IChkdXJhdGlvbk9yTW9kZSkgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIGxldCBkZWxheVRpbWU7XG4gICAgaWYgKHR5cGVvZiBkdXJhdGlvbk9yTW9kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgc3dpdGNoIChkdXJhdGlvbk9yTW9kZSkge1xuICAgICAgICBjYXNlIFwiaW5maW5pdGVcIjoge1xuICAgICAgICAgIGRlbGF5VGltZSA9IFNFVF9USU1FT1VUX01BWF9BTExPV0VEX0lOVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicmVhbFwiOiB7XG4gICAgICAgICAgZGVsYXlUaW1lID0gZ2V0UmFuZG9tU2VydmVyUmVzcG9uc2VUaW1lKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZGVsYXkgYSByZXNwb25zZTogdW5rbm93biBkZWxheSBtb2RlIFwiJHtkdXJhdGlvbk9yTW9kZX1cIi4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UgcHJvdmlkZSBvbmUgb2YgdGhlIHN1cHBvcnRlZCBtb2RlcyAoXCJyZWFsXCIsIFwiaW5maW5pdGVcIikgb3IgYSBudW1iZXIgdG8gXCJjdHguZGVsYXlcIi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uT3JNb2RlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBkZWxheVRpbWUgPSBnZXRSYW5kb21TZXJ2ZXJSZXNwb25zZVRpbWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGR1cmF0aW9uT3JNb2RlID4gU0VUX1RJTUVPVVRfTUFYX0FMTE9XRURfSU5UKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRmFpbGVkIHRvIGRlbGF5IGEgcmVzcG9uc2U6IHByb3ZpZGVkIGRlbGF5IGR1cmF0aW9uICgke2R1cmF0aW9uT3JNb2RlfSkgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIGR1cmF0aW9uIGZvciBcInNldFRpbWVvdXRcIiAoJHtTRVRfVElNRU9VVF9NQVhfQUxMT1dFRF9JTlR9KS4gVGhpcyB3aWxsIGNhdXNlIHRoZSByZXNwb25zZSB0byBiZSByZXR1cm5lZCBpbW1lZGlhdGVseS4gUGxlYXNlIHVzZSBhIG51bWJlciB3aXRoaW4gdGhlIGFsbG93ZWQgcmFuZ2UgdG8gZGVsYXkgdGhlIHJlc3BvbnNlIGJ5IGV4YWN0IGR1cmF0aW9uLCBvciBjb25zaWRlciB0aGUgXCJpbmZpbml0ZVwiIGRlbGF5IG1vZGUgdG8gZGVsYXkgdGhlIHJlc3BvbnNlIGluZGVmaW5pdGVseS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWxheVRpbWUgPSBkdXJhdGlvbk9yTW9kZTtcbiAgICB9XG4gICAgcmVzLmRlbGF5ID0gZGVsYXlUaW1lO1xuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dC9lcnJvcnMudHNcbnZhciBlcnJvcnMgPSAoZXJyb3JzTGlzdCkgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIGlmIChlcnJvcnNMaXN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGNvbnN0IHByZXZCb2R5ID0ganNvblBhcnNlKHJlcy5ib2R5KSB8fCB7fTtcbiAgICBjb25zdCBuZXh0Qm9keSA9IG1lcmdlUmlnaHQocHJldkJvZHksIHsgZXJyb3JzOiBlcnJvcnNMaXN0IH0pO1xuICAgIHJldHVybiBqc29uKG5leHRCb2R5KShyZXMpO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQvZmV0Y2gudHNcbnZhciBpbXBvcnRfaXNfbm9kZV9wcm9jZXNzMiA9IHJlcXVpcmUoXCJpcy1ub2RlLXByb2Nlc3NcIik7XG52YXIgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGwyID0gcmVxdWlyZShcImhlYWRlcnMtcG9seWZpbGxcIik7XG52YXIgdXNlRmV0Y2ggPSAoMCwgaW1wb3J0X2lzX25vZGVfcHJvY2VzczIuaXNOb2RlUHJvY2VzcykoKSA/IChpbnB1dCwgaW5pdCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBfX3RvRVNNKHJlcXVpcmUoXCJub2RlLWZldGNoXCIpKSkudGhlbihcbiAgKHsgZGVmYXVsdDogbm9kZUZldGNoIH0pID0+IG5vZGVGZXRjaChpbnB1dCwgaW5pdClcbikgOiBnbG9iYWxUaGlzLmZldGNoO1xudmFyIGF1Z21lbnRSZXF1ZXN0SW5pdCA9IChyZXF1ZXN0SW5pdCkgPT4ge1xuICBjb25zdCBoZWFkZXJzID0gbmV3IGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsMi5IZWFkZXJzKHJlcXVlc3RJbml0LmhlYWRlcnMpO1xuICBoZWFkZXJzLnNldChcIngtbXN3LWJ5cGFzc1wiLCBcInRydWVcIik7XG4gIHJldHVybiB7XG4gICAgLi4ucmVxdWVzdEluaXQsXG4gICAgaGVhZGVyczogaGVhZGVycy5hbGwoKVxuICB9O1xufTtcbnZhciBjcmVhdGVGZXRjaFJlcXVlc3RQYXJhbWV0ZXJzID0gKGlucHV0KSA9PiB7XG4gIGNvbnN0IHsgYm9keTogYm9keTIsIG1ldGhvZCB9ID0gaW5wdXQ7XG4gIGNvbnN0IHJlcXVlc3RQYXJhbWV0ZXJzID0ge1xuICAgIC4uLmlucHV0LFxuICAgIGJvZHk6IHZvaWQgMFxuICB9O1xuICBpZiAoW1wiR0VUXCIsIFwiSEVBRFwiXS5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RQYXJhbWV0ZXJzO1xuICB9XG4gIGlmICh0eXBlb2YgYm9keTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGJvZHkyID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBib2R5MiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXF1ZXN0UGFyYW1ldGVycy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keTIpO1xuICB9IGVsc2Uge1xuICAgIHJlcXVlc3RQYXJhbWV0ZXJzLmJvZHkgPSBib2R5MjtcbiAgfVxuICByZXR1cm4gcmVxdWVzdFBhcmFtZXRlcnM7XG59O1xudmFyIGZldGNoID0gKGlucHV0LCByZXF1ZXN0SW5pdCA9IHt9KSA9PiB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdXNlRmV0Y2goaW5wdXQsIGF1Z21lbnRSZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCkpO1xuICB9XG4gIGNvbnN0IHJlcXVlc3RQYXJhbWV0ZXJzID0gY3JlYXRlRmV0Y2hSZXF1ZXN0UGFyYW1ldGVycyhpbnB1dCk7XG4gIGNvbnN0IGRlcml2ZWRSZXF1ZXN0SW5pdCA9IGF1Z21lbnRSZXF1ZXN0SW5pdChyZXF1ZXN0UGFyYW1ldGVycyk7XG4gIHJldHVybiB1c2VGZXRjaChpbnB1dC51cmwuaHJlZiwgZGVyaXZlZFJlcXVlc3RJbml0KTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L3RleHQudHNcbnZhciB0ZXh0ID0gKGJvZHkyKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgcmVzLmhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwidGV4dC9wbGFpblwiKTtcbiAgICByZXMuYm9keSA9IGJvZHkyO1xuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dC94bWwudHNcbnZhciB4bWwgPSAoYm9keTIpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICByZXMuaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJ0ZXh0L3htbFwiKTtcbiAgICByZXMuYm9keSA9IGJvZHkyO1xuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvY2hlY2tHbG9iYWxzLnRzXG52YXIgaW1wb3J0X291dHZhcmlhbnQyID0gcmVxdWlyZShcIm91dHZhcmlhbnRcIik7XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9kZXZVdGlscy50c1xudmFyIGltcG9ydF9vdXR2YXJpYW50ID0gcmVxdWlyZShcIm91dHZhcmlhbnRcIik7XG52YXIgTElCUkFSWV9QUkVGSVggPSBcIltNU1ddXCI7XG5mdW5jdGlvbiBmb3JtYXRNZXNzYWdlKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSB7XG4gIGNvbnN0IGludGVycG9sYXRlZE1lc3NhZ2UgPSAoMCwgaW1wb3J0X291dHZhcmlhbnQuZm9ybWF0KShtZXNzYWdlLCAuLi5wb3NpdGlvbmFscyk7XG4gIHJldHVybiBgJHtMSUJSQVJZX1BSRUZJWH0gJHtpbnRlcnBvbGF0ZWRNZXNzYWdlfWA7XG59XG5mdW5jdGlvbiB3YXJuKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSB7XG4gIGNvbnNvbGUud2Fybihmb3JtYXRNZXNzYWdlKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSk7XG59XG5mdW5jdGlvbiBlcnJvcihtZXNzYWdlLCAuLi5wb3NpdGlvbmFscykge1xuICBjb25zb2xlLmVycm9yKGZvcm1hdE1lc3NhZ2UobWVzc2FnZSwgLi4ucG9zaXRpb25hbHMpKTtcbn1cbnZhciBkZXZVdGlscyA9IHtcbiAgZm9ybWF0TWVzc2FnZSxcbiAgd2FybixcbiAgZXJyb3Jcbn07XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9jaGVja0dsb2JhbHMudHNcbmZ1bmN0aW9uIGNoZWNrR2xvYmFscygpIHtcbiAgKDAsIGltcG9ydF9vdXR2YXJpYW50Mi5pbnZhcmlhbnQpKFxuICAgIHR5cGVvZiBVUkwgIT09IFwidW5kZWZpbmVkXCIsXG4gICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgIGBHbG9iYWwgXCJVUkxcIiBjbGFzcyBpcyBub3QgZGVmaW5lZC4gVGhpcyBsaWtlbHkgbWVhbnMgdGhhdCB5b3UncmUgcnVubmluZyBNU1cgaW4gYW4gZW52aXJvbm1lbnQgdGhhdCBkb2Vzbid0IHN1cHBvcnQgYWxsIE5vZGUuanMgc3RhbmRhcmQgQVBJIChlLmcuIFJlYWN0IE5hdGl2ZSkuIElmIHRoYXQncyB0aGUgY2FzZSwgcGxlYXNlIHVzZSBhbiBhcHByb3ByaWF0ZSBwb2x5ZmlsbCBmb3IgdGhlIFwiVVJMXCIgY2xhc3MsIGxpa2UgXCJyZWFjdC1uYXRpdmUtdXJsLXBvbHlmaWxsXCIuYFxuICAgIClcbiAgKTtcbn1cblxuLy8gc3JjL3NldHVwV29ya2VyL3NldHVwV29ya2VyLnRzXG52YXIgaW1wb3J0X291dHZhcmlhbnQ1ID0gcmVxdWlyZShcIm91dHZhcmlhbnRcIik7XG52YXIgaW1wb3J0X2lzX25vZGVfcHJvY2VzczMgPSByZXF1aXJlKFwiaXMtbm9kZS1wcm9jZXNzXCIpO1xuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvY3JlYXRlU3RhcnRIYW5kbGVyLnRzXG52YXIgaW1wb3J0X3VudGlsNCA9IHJlcXVpcmUoXCJAb3Blbi1kcmFmdC91bnRpbFwiKTtcblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L3V0aWxzL2dldFdvcmtlckluc3RhbmNlLnRzXG52YXIgaW1wb3J0X3VudGlsID0gcmVxdWlyZShcIkBvcGVuLWRyYWZ0L3VudGlsXCIpO1xuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvdXRpbHMvZ2V0V29ya2VyQnlSZWdpc3RyYXRpb24udHNcbmZ1bmN0aW9uIGdldFdvcmtlckJ5UmVnaXN0cmF0aW9uKHJlZ2lzdHJhdGlvbiwgYWJzb2x1dGVXb3JrZXJVcmwsIGZpbmRXb3JrZXIpIHtcbiAgY29uc3QgYWxsU3RhdGVzID0gW1xuICAgIHJlZ2lzdHJhdGlvbi5hY3RpdmUsXG4gICAgcmVnaXN0cmF0aW9uLmluc3RhbGxpbmcsXG4gICAgcmVnaXN0cmF0aW9uLndhaXRpbmdcbiAgXTtcbiAgY29uc3QgcmVsZXZhbnRTdGF0ZXMgPSBhbGxTdGF0ZXMuZmlsdGVyKChzdGF0ZSkgPT4ge1xuICAgIHJldHVybiBzdGF0ZSAhPSBudWxsO1xuICB9KTtcbiAgY29uc3Qgd29ya2VyID0gcmVsZXZhbnRTdGF0ZXMuZmluZCgod29ya2VyMikgPT4ge1xuICAgIHJldHVybiBmaW5kV29ya2VyKHdvcmtlcjIuc2NyaXB0VVJMLCBhYnNvbHV0ZVdvcmtlclVybCk7XG4gIH0pO1xuICByZXR1cm4gd29ya2VyIHx8IG51bGw7XG59XG5cbi8vIHNyYy91dGlscy91cmwvZ2V0QWJzb2x1dGVXb3JrZXJVcmwudHNcbmZ1bmN0aW9uIGdldEFic29sdXRlV29ya2VyVXJsKHdvcmtlclVybCkge1xuICByZXR1cm4gbmV3IFVSTCh3b3JrZXJVcmwsIGxvY2F0aW9uLmhyZWYpLmhyZWY7XG59XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC91dGlscy9nZXRXb3JrZXJJbnN0YW5jZS50c1xudmFyIGdldFdvcmtlckluc3RhbmNlID0gYXN5bmMgKHVybCwgb3B0aW9ucyA9IHt9LCBmaW5kV29ya2VyKSA9PiB7XG4gIGNvbnN0IGFic29sdXRlV29ya2VyVXJsID0gZ2V0QWJzb2x1dGVXb3JrZXJVcmwodXJsKTtcbiAgY29uc3QgbW9ja1JlZ2lzdHJhdGlvbnMgPSBhd2FpdCBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5nZXRSZWdpc3RyYXRpb25zKCkudGhlbihcbiAgICAocmVnaXN0cmF0aW9ucykgPT4gcmVnaXN0cmF0aW9ucy5maWx0ZXIoXG4gICAgICAocmVnaXN0cmF0aW9uKSA9PiBnZXRXb3JrZXJCeVJlZ2lzdHJhdGlvbihyZWdpc3RyYXRpb24sIGFic29sdXRlV29ya2VyVXJsLCBmaW5kV29ya2VyKVxuICAgIClcbiAgKTtcbiAgaWYgKCFuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyICYmIG1vY2tSZWdpc3RyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgfVxuICBjb25zdCBbZXhpc3RpbmdSZWdpc3RyYXRpb25dID0gbW9ja1JlZ2lzdHJhdGlvbnM7XG4gIGlmIChleGlzdGluZ1JlZ2lzdHJhdGlvbikge1xuICAgIHJldHVybiBleGlzdGluZ1JlZ2lzdHJhdGlvbi51cGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGdldFdvcmtlckJ5UmVnaXN0cmF0aW9uKFxuICAgICAgICAgIGV4aXN0aW5nUmVnaXN0cmF0aW9uLFxuICAgICAgICAgIGFic29sdXRlV29ya2VyVXJsLFxuICAgICAgICAgIGZpbmRXb3JrZXJcbiAgICAgICAgKSxcbiAgICAgICAgZXhpc3RpbmdSZWdpc3RyYXRpb25cbiAgICAgIF07XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgW2Vycm9yMiwgaW5zdGFuY2VdID0gYXdhaXQgKDAsIGltcG9ydF91bnRpbC51bnRpbCkoXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVnaXN0cmF0aW9uID0gYXdhaXQgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIucmVnaXN0ZXIodXJsLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGdldFdvcmtlckJ5UmVnaXN0cmF0aW9uKHJlZ2lzdHJhdGlvbiwgYWJzb2x1dGVXb3JrZXJVcmwsIGZpbmRXb3JrZXIpLFxuICAgICAgICByZWdpc3RyYXRpb25cbiAgICAgIF07XG4gICAgfVxuICApO1xuICBpZiAoZXJyb3IyKSB7XG4gICAgY29uc3QgaXNXb3JrZXJNaXNzaW5nID0gZXJyb3IyLm1lc3NhZ2UuaW5jbHVkZXMoXCIoNDA0KVwiKTtcbiAgICBpZiAoaXNXb3JrZXJNaXNzaW5nKSB7XG4gICAgICBjb25zdCBzY29wZVVybCA9IG5ldyBVUkwoKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2NvcGUpIHx8IFwiL1wiLCBsb2NhdGlvbi5ocmVmKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShgRmFpbGVkIHRvIHJlZ2lzdGVyIGEgU2VydmljZSBXb3JrZXIgZm9yIHNjb3BlICgnJHtzY29wZVVybC5ocmVmfScpIHdpdGggc2NyaXB0ICgnJHthYnNvbHV0ZVdvcmtlclVybH0nKTogU2VydmljZSBXb3JrZXIgc2NyaXB0IGRvZXMgbm90IGV4aXN0IGF0IHRoZSBnaXZlbiBwYXRoLlxuXG5EaWQgeW91IGZvcmdldCB0byBydW4gXCJucHggbXN3IGluaXQgPFBVQkxJQ19ESVI+XCI/XG5cbkxlYXJuIG1vcmUgYWJvdXQgY3JlYXRpbmcgdGhlIFNlcnZpY2UgV29ya2VyIHNjcmlwdDogaHR0cHM6Ly9tc3dqcy5pby9kb2NzL2NsaS9pbml0YClcbiAgICAgICk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlZ2lzdGVyIHRoZSBTZXJ2aWNlIFdvcmtlcjpcXG5cXG4lc1wiLFxuICAgICAgICBlcnJvcjIubWVzc2FnZVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlO1xufTtcblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L3V0aWxzL3ByaW50U3RhcnRNZXNzYWdlLnRzXG5mdW5jdGlvbiBwcmludFN0YXJ0TWVzc2FnZShhcmdzID0ge30pIHtcbiAgaWYgKGFyZ3MucXVpZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbWVzc2FnZSA9IGFyZ3MubWVzc2FnZSB8fCBcIk1vY2tpbmcgZW5hYmxlZC5cIjtcbiAgY29uc29sZS5ncm91cENvbGxhcHNlZChcbiAgICBgJWMke2RldlV0aWxzLmZvcm1hdE1lc3NhZ2UobWVzc2FnZSl9YCxcbiAgICBcImNvbG9yOm9yYW5nZXJlZDtmb250LXdlaWdodDpib2xkO1wiXG4gICk7XG4gIGNvbnNvbGUubG9nKFxuICAgIFwiJWNEb2N1bWVudGF0aW9uOiAlY2h0dHBzOi8vbXN3anMuaW8vZG9jc1wiLFxuICAgIFwiZm9udC13ZWlnaHQ6Ym9sZFwiLFxuICAgIFwiZm9udC13ZWlnaHQ6bm9ybWFsXCJcbiAgKTtcbiAgY29uc29sZS5sb2coXCJGb3VuZCBhbiBpc3N1ZT8gaHR0cHM6Ly9naXRodWIuY29tL21zd2pzL21zdy9pc3N1ZXNcIik7XG4gIGlmIChhcmdzLndvcmtlclVybCkge1xuICAgIGNvbnNvbGUubG9nKFwiV29ya2VyIHNjcmlwdCBVUkw6XCIsIGFyZ3Mud29ya2VyVXJsKTtcbiAgfVxuICBpZiAoYXJncy53b3JrZXJTY29wZSkge1xuICAgIGNvbnNvbGUubG9nKFwiV29ya2VyIHNjb3BlOlwiLCBhcmdzLndvcmtlclNjb3BlKTtcbiAgfVxuICBjb25zb2xlLmdyb3VwRW5kKCk7XG59XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC91dGlscy9lbmFibGVNb2NraW5nLnRzXG5hc3luYyBmdW5jdGlvbiBlbmFibGVNb2NraW5nKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29udGV4dC53b3JrZXJDaGFubmVsLnNlbmQoXCJNT0NLX0FDVElWQVRFXCIpO1xuICBhd2FpdCBjb250ZXh0LmV2ZW50cy5vbmNlKFwiTU9DS0lOR19FTkFCTEVEXCIpO1xuICBpZiAoY29udGV4dC5pc01vY2tpbmdFbmFibGVkKSB7XG4gICAgZGV2VXRpbHMud2FybihcbiAgICAgIGBGb3VuZCBhIHJlZHVuZGFudCBcIndvcmtlci5zdGFydCgpXCIgY2FsbC4gTm90ZSB0aGF0IHN0YXJ0aW5nIHRoZSB3b3JrZXIgd2hpbGUgbW9ja2luZyBpcyBhbHJlYWR5IGVuYWJsZWQgd2lsbCBoYXZlIG5vIGVmZmVjdC4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhpcyBcIndvcmtlci5zdGFydCgpXCIgY2FsbC5gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29udGV4dC5pc01vY2tpbmdFbmFibGVkID0gdHJ1ZTtcbiAgcHJpbnRTdGFydE1lc3NhZ2Uoe1xuICAgIHF1aWV0OiBvcHRpb25zLnF1aWV0LFxuICAgIHdvcmtlclNjb3BlOiAoX2EgPSBjb250ZXh0LnJlZ2lzdHJhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNjb3BlLFxuICAgIHdvcmtlclVybDogKF9iID0gY29udGV4dC53b3JrZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zY3JpcHRVUkxcbiAgfSk7XG59XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC91dGlscy9jcmVhdGVNZXNzYWdlQ2hhbm5lbC50c1xudmFyIFdvcmtlckNoYW5uZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBvcnQpIHtcbiAgICB0aGlzLnBvcnQgPSBwb3J0O1xuICB9XG4gIHBvc3RNZXNzYWdlKGV2ZW50LCAuLi5yZXN0Mikge1xuICAgIGNvbnN0IFtkYXRhMiwgdHJhbnNmZXJdID0gcmVzdDI7XG4gICAgdGhpcy5wb3J0LnBvc3RNZXNzYWdlKHsgdHlwZTogZXZlbnQsIGRhdGE6IGRhdGEyIH0sIHsgdHJhbnNmZXIgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9OZXR3b3JrRXJyb3IudHNcbnZhciBOZXR3b3JrRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiTmV0d29ya0Vycm9yXCI7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L3BhcnNlV29ya2VyUmVxdWVzdC50c1xudmFyIGltcG9ydF9pbnRlcmNlcHRvcnMyID0gcmVxdWlyZShcIkBtc3dqcy9pbnRlcmNlcHRvcnNcIik7XG52YXIgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGw1ID0gcmVxdWlyZShcImhlYWRlcnMtcG9seWZpbGxcIik7XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L01vY2tlZFJlcXVlc3QudHNcbnZhciBjb29raWVVdGlsczMgPSBfX3RvRVNNKHJlcXVpcmUoXCJjb29raWVcIikpO1xudmFyIGltcG9ydF9jb29raWVzID0gcmVxdWlyZShcIkBtc3dqcy9jb29raWVzXCIpO1xudmFyIGltcG9ydF9pbnRlcmNlcHRvcnMgPSByZXF1aXJlKFwiQG1zd2pzL2ludGVyY2VwdG9yc1wiKTtcbnZhciBpbXBvcnRfYnVmZmVyVXRpbHMgPSByZXF1aXJlKFwiQG1zd2pzL2ludGVyY2VwdG9ycy9saWIvdXRpbHMvYnVmZmVyVXRpbHMuanNcIik7XG52YXIgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGw0ID0gcmVxdWlyZShcImhlYWRlcnMtcG9seWZpbGxcIik7XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L2dldFJlcXVlc3RDb29raWVzLnRzXG52YXIgY29va2llVXRpbHMyID0gX190b0VTTShyZXF1aXJlKFwiY29va2llXCIpKTtcbmZ1bmN0aW9uIGdldEFsbENvb2tpZXMoKSB7XG4gIHJldHVybiBjb29raWVVdGlsczIucGFyc2UoZG9jdW1lbnQuY29va2llKTtcbn1cbmZ1bmN0aW9uIGdldFJlcXVlc3RDb29raWVzKHJlcXVlc3QpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgbG9jYXRpb24gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgc3dpdGNoIChyZXF1ZXN0LmNyZWRlbnRpYWxzKSB7XG4gICAgY2FzZSBcInNhbWUtb3JpZ2luXCI6IHtcbiAgICAgIHJldHVybiBsb2NhdGlvbi5vcmlnaW4gPT09IHJlcXVlc3QudXJsLm9yaWdpbiA/IGdldEFsbENvb2tpZXMoKSA6IHt9O1xuICAgIH1cbiAgICBjYXNlIFwiaW5jbHVkZVwiOiB7XG4gICAgICByZXR1cm4gZ2V0QWxsQ29va2llcygpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9wYXJzZU11bHRpcGFydERhdGEudHNcbnZhciBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDMgPSByZXF1aXJlKFwiaGVhZGVycy1wb2x5ZmlsbFwiKTtcbmZ1bmN0aW9uIHBhcnNlQ29udGVudEhlYWRlcnMoaGVhZGVyc1N0cmluZykge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBoZWFkZXJzID0gKDAsIGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsMy5zdHJpbmdUb0hlYWRlcnMpKGhlYWRlcnNTdHJpbmcpO1xuICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IFwidGV4dC9wbGFpblwiO1xuICBjb25zdCBkaXNwb3NpdGlvbiA9IGhlYWRlcnMuZ2V0KFwiY29udGVudC1kaXNwb3NpdGlvblwiKTtcbiAgaWYgKCFkaXNwb3NpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJDb250ZW50LURpc3Bvc2l0aW9uXCIgaGVhZGVyIGlzIHJlcXVpcmVkLicpO1xuICB9XG4gIGNvbnN0IGRpcmVjdGl2ZXMgPSBkaXNwb3NpdGlvbi5zcGxpdChcIjtcIikucmVkdWNlKChhY2MsIGNodW5rKSA9PiB7XG4gICAgY29uc3QgW25hbWUyLCAuLi5yZXN0Ml0gPSBjaHVuay50cmltKCkuc3BsaXQoXCI9XCIpO1xuICAgIGFjY1tuYW1lMl0gPSByZXN0Mi5qb2luKFwiPVwiKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIGNvbnN0IG5hbWUgPSAoX2EgPSBkaXJlY3RpdmVzLm5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zbGljZSgxLCAtMSk7XG4gIGNvbnN0IGZpbGVuYW1lID0gKF9iID0gZGlyZWN0aXZlcy5maWxlbmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnNsaWNlKDEsIC0xKTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIGZpbGVuYW1lLFxuICAgIGNvbnRlbnRUeXBlXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZU11bHRpcGFydERhdGEoZGF0YTIsIGhlYWRlcnMpIHtcbiAgY29uc3QgY29udGVudFR5cGUgPSBoZWFkZXJzID09IG51bGwgPyB2b2lkIDAgOiBoZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgaWYgKCFjb250ZW50VHlwZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgWywgLi4uZGlyZWN0aXZlc10gPSBjb250ZW50VHlwZS5zcGxpdCgvOyAqLyk7XG4gIGNvbnN0IGJvdW5kYXJ5ID0gZGlyZWN0aXZlcy5maWx0ZXIoKGQpID0+IGQuc3RhcnRzV2l0aChcImJvdW5kYXJ5PVwiKSkubWFwKChzKSA9PiBzLnJlcGxhY2UoL15ib3VuZGFyeT0vLCBcIlwiKSlbMF07XG4gIGlmICghYm91bmRhcnkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IGJvdW5kYXJ5UmVnRXhwID0gbmV3IFJlZ0V4cChgLS0rJHtib3VuZGFyeX1gKTtcbiAgY29uc3QgZmllbGRzID0gZGF0YTIuc3BsaXQoYm91bmRhcnlSZWdFeHApLmZpbHRlcigoY2h1bmspID0+IGNodW5rLnN0YXJ0c1dpdGgoXCJcXHJcXG5cIikgJiYgY2h1bmsuZW5kc1dpdGgoXCJcXHJcXG5cIikpLm1hcCgoY2h1bmspID0+IGNodW5rLnRyaW1TdGFydCgpLnJlcGxhY2UoL1xcclxcbiQvLCBcIlwiKSk7XG4gIGlmICghZmllbGRzLmxlbmd0aCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgcGFyc2VkQm9keSA9IHt9O1xuICB0cnkge1xuICAgIGZvciAoY29uc3QgZmllbGQyIG9mIGZpZWxkcykge1xuICAgICAgY29uc3QgW2NvbnRlbnRIZWFkZXJzLCAuLi5yZXN0Ml0gPSBmaWVsZDIuc3BsaXQoXCJcXHJcXG5cXHJcXG5cIik7XG4gICAgICBjb25zdCBjb250ZW50Qm9keSA9IHJlc3QyLmpvaW4oXCJcXHJcXG5cXHJcXG5cIik7XG4gICAgICBjb25zdCB7IGNvbnRlbnRUeXBlOiBjb250ZW50VHlwZTIsIGZpbGVuYW1lLCBuYW1lIH0gPSBwYXJzZUNvbnRlbnRIZWFkZXJzKGNvbnRlbnRIZWFkZXJzKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZmlsZW5hbWUgPT09IHZvaWQgMCA/IGNvbnRlbnRCb2R5IDogbmV3IEZpbGUoW2NvbnRlbnRCb2R5XSwgZmlsZW5hbWUsIHsgdHlwZTogY29udGVudFR5cGUyIH0pO1xuICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZWRCb2R5W25hbWVdO1xuICAgICAgaWYgKHBhcnNlZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgcGFyc2VkQm9keVtuYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZFZhbHVlKSkge1xuICAgICAgICBwYXJzZWRCb2R5W25hbWVdID0gWy4uLnBhcnNlZFZhbHVlLCB2YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRCb2R5W25hbWVdID0gW3BhcnNlZFZhbHVlLCB2YWx1ZV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWRCb2R5O1xuICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L3BhcnNlQm9keS50c1xuZnVuY3Rpb24gcGFyc2VCb2R5KGJvZHkyLCBoZWFkZXJzKSB7XG4gIHZhciBfYTtcbiAgaWYgKCFib2R5Mikge1xuICAgIHJldHVybiBib2R5MjtcbiAgfVxuICBjb25zdCBjb250ZW50VHlwZSA9ICgoX2EgPSBoZWFkZXJzID09IG51bGwgPyB2b2lkIDAgOiBoZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRvTG93ZXJDYXNlKCkpIHx8IFwiXCI7XG4gIGNvbnN0IGhhc011bHRpcGFydENvbnRlbnQgPSBjb250ZW50VHlwZS5zdGFydHNXaXRoKFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiKTtcbiAgaWYgKGhhc011bHRpcGFydENvbnRlbnQgJiYgdHlwZW9mIGJvZHkyICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIHBhcnNlTXVsdGlwYXJ0RGF0YShib2R5Mi50b1N0cmluZygpLCBoZWFkZXJzKSB8fCBib2R5MjtcbiAgfVxuICBjb25zdCBoYXNKc29uQ29udGVudCA9IGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwianNvblwiKTtcbiAgaWYgKGhhc0pzb25Db250ZW50ICYmIHR5cGVvZiBib2R5MiAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBqc29uUGFyc2UoYm9keTIudG9TdHJpbmcoKSkgfHwgYm9keTI7XG4gIH1cbiAgcmV0dXJuIGJvZHkyO1xufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvaXNTdHJpbmdFcXVhbC50c1xuZnVuY3Rpb24gaXNTdHJpbmdFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIHJldHVybiBhY3R1YWwudG9Mb3dlckNhc2UoKSA9PT0gZXhwZWN0ZWQudG9Mb3dlckNhc2UoKTtcbn1cblxuLy8gc3JjL3V0aWxzL3JlcXVlc3QvTW9ja2VkUmVxdWVzdC50c1xudmFyIE1vY2tlZFJlcXVlc3QgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9pbnRlcmNlcHRvcnMuSXNvbW9ycGhpY1JlcXVlc3Qge1xuICBjb25zdHJ1Y3Rvcih1cmwsIGluaXQgPSB7fSkge1xuICAgIHN1cGVyKHVybCwgaW5pdCk7XG4gICAgaWYgKGluaXQuaWQpIHtcbiAgICAgIHRoaXMuaWQgPSBpbml0LmlkO1xuICAgIH1cbiAgICB0aGlzLmNhY2hlID0gaW5pdC5jYWNoZSB8fCBcImRlZmF1bHRcIjtcbiAgICB0aGlzLmRlc3RpbmF0aW9uID0gaW5pdC5kZXN0aW5hdGlvbiB8fCBcIlwiO1xuICAgIHRoaXMuaW50ZWdyaXR5ID0gaW5pdC5pbnRlZ3JpdHkgfHwgXCJcIjtcbiAgICB0aGlzLmtlZXBhbGl2ZSA9IGluaXQua2VlcGFsaXZlIHx8IGZhbHNlO1xuICAgIHRoaXMubW9kZSA9IGluaXQubW9kZSB8fCBcImNvcnNcIjtcbiAgICB0aGlzLnByaW9yaXR5ID0gaW5pdC5wcmlvcml0eSB8fCBcImF1dG9cIjtcbiAgICB0aGlzLnJlZGlyZWN0ID0gaW5pdC5yZWRpcmVjdCB8fCBcImZvbGxvd1wiO1xuICAgIHRoaXMucmVmZXJyZXIgPSBpbml0LnJlZmVycmVyIHx8IFwiXCI7XG4gICAgdGhpcy5yZWZlcnJlclBvbGljeSA9IGluaXQucmVmZXJyZXJQb2xpY3kgfHwgXCJuby1yZWZlcnJlclwiO1xuICAgIHRoaXMuY29va2llcyA9IGluaXQuY29va2llcyB8fCB0aGlzLmdldENvb2tpZXMoKTtcbiAgfVxuICBnZXQgYm9keSgpIHtcbiAgICBjb25zdCB0ZXh0MiA9ICgwLCBpbXBvcnRfYnVmZmVyVXRpbHMuZGVjb2RlQnVmZmVyKSh0aGlzW1wiX2JvZHlcIl0pO1xuICAgIGNvbnN0IGJvZHkyID0gcGFyc2VCb2R5KHRleHQyLCB0aGlzLmhlYWRlcnMpO1xuICAgIGlmIChpc1N0cmluZ0VxdWFsKHRoaXMubWV0aG9kLCBcIkdFVFwiKSAmJiBib2R5MiA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHkyO1xuICB9XG4gIHBhc3N0aHJvdWdoKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IDEwMSxcbiAgICAgIHN0YXR1c1RleHQ6IFwiQ29udGludWVcIixcbiAgICAgIGhlYWRlcnM6IG5ldyBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDQuSGVhZGVycygpLFxuICAgICAgYm9keTogbnVsbCxcbiAgICAgIHBhc3N0aHJvdWdoOiB0cnVlLFxuICAgICAgb25jZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGdldENvb2tpZXMoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJlcXVlc3RDb29raWVzU3RyaW5nID0gdGhpcy5oZWFkZXJzLmdldChcImNvb2tpZVwiKTtcbiAgICBjb25zdCBvd25Db29raWVzID0gcmVxdWVzdENvb2tpZXNTdHJpbmcgPyBjb29raWVVdGlsczMucGFyc2UocmVxdWVzdENvb2tpZXNTdHJpbmcpIDoge307XG4gICAgaW1wb3J0X2Nvb2tpZXMuc3RvcmUuaHlkcmF0ZSgpO1xuICAgIGNvbnN0IGNvb2tpZXNGcm9tU3RvcmUgPSBBcnJheS5mcm9tKFxuICAgICAgKF9hID0gaW1wb3J0X2Nvb2tpZXMuc3RvcmUuZ2V0KHsgLi4udGhpcywgdXJsOiB0aGlzLnVybC5ocmVmIH0pKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZW50cmllcygpXG4gICAgKS5yZWR1Y2UoKGNvb2tpZXMsIFtuYW1lLCB7IHZhbHVlIH1dKSA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihjb29raWVzLCB7IFtuYW1lLnRyaW0oKV06IHZhbHVlIH0pO1xuICAgIH0sIHt9KTtcbiAgICBjb25zdCBjb29raWVzRnJvbURvY3VtZW50ID0gZ2V0UmVxdWVzdENvb2tpZXModGhpcyk7XG4gICAgY29uc3QgZm9yd2FyZGVkQ29va2llcyA9IHtcbiAgICAgIC4uLmNvb2tpZXNGcm9tRG9jdW1lbnQsXG4gICAgICAuLi5jb29raWVzRnJvbVN0b3JlXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZm9yd2FyZGVkQ29va2llcykpIHtcbiAgICAgIHRoaXMuaGVhZGVycy5hcHBlbmQoXCJjb29raWVcIiwgYCR7bmFtZX09JHt2YWx1ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZvcndhcmRlZENvb2tpZXMsXG4gICAgICAuLi5vd25Db29raWVzXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3JlcXVlc3QvcGFyc2VXb3JrZXJSZXF1ZXN0LnRzXG5mdW5jdGlvbiBwYXJzZVdvcmtlclJlcXVlc3QocmF3UmVxdWVzdCkge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKHJhd1JlcXVlc3QudXJsKTtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDUuSGVhZGVycyhyYXdSZXF1ZXN0LmhlYWRlcnMpO1xuICByZXR1cm4gbmV3IE1vY2tlZFJlcXVlc3QodXJsLCB7XG4gICAgLi4ucmF3UmVxdWVzdCxcbiAgICBib2R5OiAoMCwgaW1wb3J0X2ludGVyY2VwdG9yczIuZW5jb2RlQnVmZmVyKShyYXdSZXF1ZXN0LmJvZHkgfHwgXCJcIiksXG4gICAgaGVhZGVyc1xuICB9KTtcbn1cblxuLy8gc3JjL3V0aWxzL2hhbmRsZVJlcXVlc3QudHNcbnZhciBpbXBvcnRfdW50aWwyID0gcmVxdWlyZShcIkBvcGVuLWRyYWZ0L3VudGlsXCIpO1xuXG4vLyBzcmMvdXRpbHMvZ2V0UmVzcG9uc2UudHNcbnZhciBnZXRSZXNwb25zZSA9IGFzeW5jIChyZXF1ZXN0LCBoYW5kbGVycywgcmVzb2x1dGlvbkNvbnRleHQpID0+IHtcbiAgY29uc3QgcmVsZXZhbnRIYW5kbGVycyA9IGhhbmRsZXJzLmZpbHRlcigoaGFuZGxlcikgPT4ge1xuICAgIHJldHVybiBoYW5kbGVyLnRlc3QocmVxdWVzdCwgcmVzb2x1dGlvbkNvbnRleHQpO1xuICB9KTtcbiAgaWYgKHJlbGV2YW50SGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIHJlc3BvbnNlOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlbGV2YW50SGFuZGxlcnMucmVkdWNlKGFzeW5jIChleGVjdXRpb25SZXN1bHQsIGhhbmRsZXIpID0+IHtcbiAgICBjb25zdCBwcmV2aW91c1Jlc3VsdHMgPSBhd2FpdCBleGVjdXRpb25SZXN1bHQ7XG4gICAgaWYgKCEhKHByZXZpb3VzUmVzdWx0cyA9PSBudWxsID8gdm9pZCAwIDogcHJldmlvdXNSZXN1bHRzLnJlc3BvbnNlKSkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGlvblJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IGhhbmRsZXIucnVuKHJlcXVlc3QsIHJlc29sdXRpb25Db250ZXh0KTtcbiAgICBpZiAocmVzdWx0MiA9PT0gbnVsbCB8fCByZXN1bHQyLmhhbmRsZXIuc2hvdWxkU2tpcCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghcmVzdWx0Mi5yZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVxdWVzdDogcmVzdWx0Mi5yZXF1ZXN0LFxuICAgICAgICBoYW5kbGVyOiByZXN1bHQyLmhhbmRsZXIsXG4gICAgICAgIHJlc3BvbnNlOiB2b2lkIDAsXG4gICAgICAgIHBhcnNlZFJlc3VsdDogcmVzdWx0Mi5wYXJzZWRSZXN1bHRcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChyZXN1bHQyLnJlc3BvbnNlLm9uY2UpIHtcbiAgICAgIGhhbmRsZXIubWFya0FzU2tpcHBlZCh0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH0sIFByb21pc2UucmVzb2x2ZShudWxsKSk7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIHJlc3BvbnNlOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaGFuZGxlcjogcmVzdWx0LmhhbmRsZXIsXG4gICAgcHVibGljUmVxdWVzdDogcmVzdWx0LnJlcXVlc3QsXG4gICAgcGFyc2VkUmVxdWVzdDogcmVzdWx0LnBhcnNlZFJlc3VsdCxcbiAgICByZXNwb25zZTogcmVzdWx0LnJlc3BvbnNlXG4gIH07XG59O1xuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9vblVuaGFuZGxlZFJlcXVlc3QudHNcbnZhciBpbXBvcnRfanNfbGV2ZW5zaHRlaW4gPSBfX3RvRVNNKHJlcXVpcmUoXCJqcy1sZXZlbnNodGVpblwiKSk7XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9wYXJzZUdyYXBoUUxSZXF1ZXN0LnRzXG52YXIgaW1wb3J0X2dyYXBocWwgPSByZXF1aXJlKFwiZ3JhcGhxbFwiKTtcblxuLy8gc3JjL3V0aWxzL3JlcXVlc3QvZ2V0UHVibGljVXJsRnJvbVJlcXVlc3QudHNcbnZhciBnZXRQdWJsaWNVcmxGcm9tUmVxdWVzdCA9IChyZXF1ZXN0KSA9PiB7XG4gIHJldHVybiByZXF1ZXN0LnJlZmVycmVyLnN0YXJ0c1dpdGgocmVxdWVzdC51cmwub3JpZ2luKSA/IHJlcXVlc3QudXJsLnBhdGhuYW1lIDogbmV3IFVSTChcbiAgICByZXF1ZXN0LnVybC5wYXRobmFtZSxcbiAgICBgJHtyZXF1ZXN0LnVybC5wcm90b2NvbH0vLyR7cmVxdWVzdC51cmwuaG9zdH1gXG4gICkuaHJlZjtcbn07XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9wYXJzZUdyYXBoUUxSZXF1ZXN0LnRzXG5mdW5jdGlvbiBwYXJzZURvY3VtZW50Tm9kZShub2RlKSB7XG4gIHZhciBfYTtcbiAgY29uc3Qgb3BlcmF0aW9uRGVmID0gbm9kZS5kZWZpbml0aW9ucy5maW5kKChkZWYpID0+IHtcbiAgICByZXR1cm4gZGVmLmtpbmQgPT09IFwiT3BlcmF0aW9uRGVmaW5pdGlvblwiO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBvcGVyYXRpb25UeXBlOiBvcGVyYXRpb25EZWYgPT0gbnVsbCA/IHZvaWQgMCA6IG9wZXJhdGlvbkRlZi5vcGVyYXRpb24sXG4gICAgb3BlcmF0aW9uTmFtZTogKF9hID0gb3BlcmF0aW9uRGVmID09IG51bGwgPyB2b2lkIDAgOiBvcGVyYXRpb25EZWYubmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVF1ZXJ5KHF1ZXJ5KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgYXN0ID0gKDAsIGltcG9ydF9ncmFwaHFsLnBhcnNlKShxdWVyeSk7XG4gICAgcmV0dXJuIHBhcnNlRG9jdW1lbnROb2RlKGFzdCk7XG4gIH0gY2F0Y2ggKGVycm9yMikge1xuICAgIHJldHVybiBlcnJvcjI7XG4gIH1cbn1cbmZ1bmN0aW9uIGV4dHJhY3RNdWx0aXBhcnRWYXJpYWJsZXModmFyaWFibGVzLCBtYXAsIGZpbGVzKSB7XG4gIGNvbnN0IG9wZXJhdGlvbnMgPSB7IHZhcmlhYmxlcyB9O1xuICBmb3IgKGNvbnN0IFtrZXksIHBhdGhBcnJheV0gb2YgT2JqZWN0LmVudHJpZXMobWFwKSkge1xuICAgIGlmICghKGtleSBpbiBmaWxlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgR2l2ZW4gZmlsZXMgZG8gbm90IGhhdmUgYSBrZXkgJyR7a2V5fScgLmApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRvdFBhdGggb2YgcGF0aEFycmF5KSB7XG4gICAgICBjb25zdCBbbGFzdFBhdGgsIC4uLnJldmVyc2VkUGF0aHNdID0gZG90UGF0aC5zcGxpdChcIi5cIikucmV2ZXJzZSgpO1xuICAgICAgY29uc3QgcGF0aHMgPSByZXZlcnNlZFBhdGhzLnJldmVyc2UoKTtcbiAgICAgIGxldCB0YXJnZXQgPSBvcGVyYXRpb25zO1xuICAgICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIGlmICghKHBhdGggaW4gdGFyZ2V0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvcGVydHkgJyR7cGF0aHN9JyBpcyBub3QgaW4gb3BlcmF0aW9ucy5gKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQgPSB0YXJnZXRbcGF0aF07XG4gICAgICB9XG4gICAgICB0YXJnZXRbbGFzdFBhdGhdID0gZmlsZXNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wZXJhdGlvbnMudmFyaWFibGVzO1xufVxuZnVuY3Rpb24gZ2V0R3JhcGhRTElucHV0KHJlcXVlc3QpIHtcbiAgdmFyIF9hLCBfYjtcbiAgc3dpdGNoIChyZXF1ZXN0Lm1ldGhvZCkge1xuICAgIGNhc2UgXCJHRVRcIjoge1xuICAgICAgY29uc3QgcXVlcnkgPSByZXF1ZXN0LnVybC5zZWFyY2hQYXJhbXMuZ2V0KFwicXVlcnlcIik7XG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSByZXF1ZXN0LnVybC5zZWFyY2hQYXJhbXMuZ2V0KFwidmFyaWFibGVzXCIpIHx8IFwiXCI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBxdWVyeSxcbiAgICAgICAgdmFyaWFibGVzOiBqc29uUGFyc2UodmFyaWFibGVzKVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIlBPU1RcIjoge1xuICAgICAgaWYgKChfYSA9IHJlcXVlc3QuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IHsgcXVlcnksIHZhcmlhYmxlcyB9ID0gcmVxdWVzdC5ib2R5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIHZhcmlhYmxlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKChfYiA9IHJlcXVlc3QuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm9wZXJhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBvcGVyYXRpb25zLCBtYXAsIC4uLmZpbGVzIH0gPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIGNvbnN0IHBhcnNlZE9wZXJhdGlvbnMgPSBqc29uUGFyc2UoXG4gICAgICAgICAgb3BlcmF0aW9uc1xuICAgICAgICApIHx8IHt9O1xuICAgICAgICBpZiAoIXBhcnNlZE9wZXJhdGlvbnMucXVlcnkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRNYXAgPSBqc29uUGFyc2UobWFwIHx8IFwiXCIpIHx8IHt9O1xuICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSBwYXJzZWRPcGVyYXRpb25zLnZhcmlhYmxlcyA/IGV4dHJhY3RNdWx0aXBhcnRWYXJpYWJsZXMoXG4gICAgICAgICAgcGFyc2VkT3BlcmF0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgcGFyc2VkTWFwLFxuICAgICAgICAgIGZpbGVzXG4gICAgICAgICkgOiB7fTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBxdWVyeTogcGFyc2VkT3BlcmF0aW9ucy5xdWVyeSxcbiAgICAgICAgICB2YXJpYWJsZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUdyYXBoUUxSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgY29uc3QgaW5wdXQgPSBnZXRHcmFwaFFMSW5wdXQocmVxdWVzdCk7XG4gIGlmICghaW5wdXQgfHwgIWlucHV0LnF1ZXJ5KSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCB7IHF1ZXJ5LCB2YXJpYWJsZXMgfSA9IGlucHV0O1xuICBjb25zdCBwYXJzZWRSZXN1bHQgPSBwYXJzZVF1ZXJ5KHF1ZXJ5KTtcbiAgaWYgKHBhcnNlZFJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgY29uc3QgcmVxdWVzdFB1YmxpY1VybCA9IGdldFB1YmxpY1VybEZyb21SZXF1ZXN0KHJlcXVlc3QpO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICdGYWlsZWQgdG8gaW50ZXJjZXB0IGEgR3JhcGhRTCByZXF1ZXN0IHRvIFwiJXMgJXNcIjogY2Fubm90IHBhcnNlIHF1ZXJ5LiBTZWUgdGhlIGVycm9yIG1lc3NhZ2UgZnJvbSB0aGUgcGFyc2VyIGJlbG93LlxcblxcbiVzJyxcbiAgICAgICAgcmVxdWVzdC5tZXRob2QsXG4gICAgICAgIHJlcXVlc3RQdWJsaWNVcmwsXG4gICAgICAgIHBhcnNlZFJlc3VsdC5tZXNzYWdlXG4gICAgICApXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9wZXJhdGlvblR5cGU6IHBhcnNlZFJlc3VsdC5vcGVyYXRpb25UeXBlLFxuICAgIG9wZXJhdGlvbk5hbWU6IHBhcnNlZFJlc3VsdC5vcGVyYXRpb25OYW1lLFxuICAgIHZhcmlhYmxlc1xuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMvbG9nZ2luZy9nZXRTdGF0dXNDb2RlQ29sb3IudHNcbmZ1bmN0aW9uIGdldFN0YXR1c0NvZGVDb2xvcihzdGF0dXMyKSB7XG4gIGlmIChzdGF0dXMyIDwgMzAwKSB7XG4gICAgcmV0dXJuIFwiIzY5QUIzMlwiIC8qIFN1Y2Nlc3MgKi87XG4gIH1cbiAgaWYgKHN0YXR1czIgPCA0MDApIHtcbiAgICByZXR1cm4gXCIjRjBCQjRCXCIgLyogV2FybmluZyAqLztcbiAgfVxuICByZXR1cm4gXCIjRTk1RjVEXCIgLyogRGFuZ2VyICovO1xufVxuXG4vLyBzcmMvdXRpbHMvbG9nZ2luZy9nZXRUaW1lc3RhbXAudHNcbmZ1bmN0aW9uIGdldFRpbWVzdGFtcCgpIHtcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgcmV0dXJuIFtub3cuZ2V0SG91cnMoKSwgbm93LmdldE1pbnV0ZXMoKSwgbm93LmdldFNlY29uZHMoKV0ubWFwKFN0cmluZykubWFwKChjaHVuaykgPT4gY2h1bmsuc2xpY2UoMCwgMikpLm1hcCgoY2h1bmspID0+IGNodW5rLnBhZFN0YXJ0KDIsIFwiMFwiKSkuam9pbihcIjpcIik7XG59XG5cbi8vIHNyYy91dGlscy9sb2dnaW5nL3ByZXBhcmVSZXF1ZXN0LnRzXG5mdW5jdGlvbiBwcmVwYXJlUmVxdWVzdChyZXF1ZXN0KSB7XG4gIHJldHVybiB7XG4gICAgLi4ucmVxdWVzdCxcbiAgICBib2R5OiByZXF1ZXN0LmJvZHksXG4gICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLmFsbCgpXG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9sb2dnaW5nL3ByZXBhcmVSZXNwb25zZS50c1xudmFyIGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsNiA9IHJlcXVpcmUoXCJoZWFkZXJzLXBvbHlmaWxsXCIpO1xuZnVuY3Rpb24gcHJlcGFyZVJlc3BvbnNlKHJlcykge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSAoMCwgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGw2Lm9iamVjdFRvSGVhZGVycykocmVzLmhlYWRlcnMpO1xuICBjb25zdCBwYXJzZWRCb2R5ID0gcGFyc2VCb2R5KHJlcy5ib2R5LCByZXNwb25zZUhlYWRlcnMpO1xuICByZXR1cm4ge1xuICAgIC4uLnJlcyxcbiAgICBib2R5OiBwYXJzZWRCb2R5XG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9tYXRjaGluZy9tYXRjaFJlcXVlc3RVcmwudHNcbnZhciBpbXBvcnRfcGF0aF90b19yZWdleHAgPSByZXF1aXJlKFwicGF0aC10by1yZWdleHBcIik7XG52YXIgaW1wb3J0X2dldENsZWFuVXJsID0gcmVxdWlyZShcIkBtc3dqcy9pbnRlcmNlcHRvcnMvbGliL3V0aWxzL2dldENsZWFuVXJsLmpzXCIpO1xuXG4vLyBzcmMvdXRpbHMvdXJsL2NsZWFuVXJsLnRzXG52YXIgUkVEVU5EQU5UX0NIQVJBQ1RFUlNfRVhQID0gL1tcXD98I10uKiQvZztcbmZ1bmN0aW9uIGdldFNlYXJjaFBhcmFtcyhwYXRoKSB7XG4gIHJldHVybiBuZXcgVVJMKGAvJHtwYXRofWAsIFwiaHR0cDovL2xvY2FsaG9zdFwiKS5zZWFyY2hQYXJhbXM7XG59XG5mdW5jdGlvbiBjbGVhblVybChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoUkVEVU5EQU5UX0NIQVJBQ1RFUlNfRVhQLCBcIlwiKTtcbn1cblxuLy8gc3JjL3V0aWxzL3VybC9pc0Fic29sdXRlVXJsLnRzXG5mdW5jdGlvbiBpc0Fic29sdXRlVXJsKHVybCkge1xuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59XG5cbi8vIHNyYy91dGlscy91cmwvZ2V0QWJzb2x1dGVVcmwudHNcbmZ1bmN0aW9uIGdldEFic29sdXRlVXJsKHBhdGgsIGJhc2VVcmwpIHtcbiAgaWYgKGlzQWJzb2x1dGVVcmwocGF0aCkpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiKlwiKSkge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIGNvbnN0IG9yaWdpbiA9IGJhc2VVcmwgfHwgdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmJhc2VVUkk7XG4gIHJldHVybiBvcmlnaW4gPyBkZWNvZGVVUkkobmV3IFVSTChlbmNvZGVVUkkocGF0aCksIG9yaWdpbikuaHJlZikgOiBwYXRoO1xufVxuXG4vLyBzcmMvdXRpbHMvbWF0Y2hpbmcvbm9ybWFsaXplUGF0aC50c1xuZnVuY3Rpb24gbm9ybWFsaXplUGF0aChwYXRoLCBiYXNlVXJsKSB7XG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgY29uc3QgbWF5YmVBYnNvbHV0ZVVybCA9IGdldEFic29sdXRlVXJsKHBhdGgsIGJhc2VVcmwpO1xuICByZXR1cm4gY2xlYW5VcmwobWF5YmVBYnNvbHV0ZVVybCk7XG59XG5cbi8vIHNyYy91dGlscy9tYXRjaGluZy9tYXRjaFJlcXVlc3RVcmwudHNcbmZ1bmN0aW9uIGNvZXJjZVBhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKFxuICAgIC8oWzphLXpBLVpfLV0qKShcXCp7MSwyfSkrL2csXG4gICAgKF8sIHBhcmFtZXRlck5hbWUsIHdpbGRjYXJkKSA9PiB7XG4gICAgICBjb25zdCBleHByZXNzaW9uID0gXCIoLiopXCI7XG4gICAgICBpZiAoIXBhcmFtZXRlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1ldGVyTmFtZS5zdGFydHNXaXRoKFwiOlwiKSA/IGAke3BhcmFtZXRlck5hbWV9JHt3aWxkY2FyZH1gIDogYCR7cGFyYW1ldGVyTmFtZX0ke2V4cHJlc3Npb259YDtcbiAgICB9XG4gICkucmVwbGFjZSgvKFteXFwvXSkoOikoPz1cXGQrKS8sIFwiJDFcXFxcJDJcIikucmVwbGFjZSgvXihbXlxcL10rKSg6KSg/PVxcL1xcLykvLCBcIiQxXFxcXCQyXCIpO1xufVxuZnVuY3Rpb24gbWF0Y2hSZXF1ZXN0VXJsKHVybCwgcGF0aCwgYmFzZVVybCkge1xuICBjb25zdCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgocGF0aCwgYmFzZVVybCk7XG4gIGNvbnN0IGNsZWFuUGF0aCA9IHR5cGVvZiBub3JtYWxpemVkUGF0aCA9PT0gXCJzdHJpbmdcIiA/IGNvZXJjZVBhdGgobm9ybWFsaXplZFBhdGgpIDogbm9ybWFsaXplZFBhdGg7XG4gIGNvbnN0IGNsZWFuVXJsMiA9ICgwLCBpbXBvcnRfZ2V0Q2xlYW5VcmwuZ2V0Q2xlYW5VcmwpKHVybCk7XG4gIGNvbnN0IHJlc3VsdCA9ICgwLCBpbXBvcnRfcGF0aF90b19yZWdleHAubWF0Y2gpKGNsZWFuUGF0aCwgeyBkZWNvZGU6IGRlY29kZVVSSUNvbXBvbmVudCB9KShjbGVhblVybDIpO1xuICBjb25zdCBwYXJhbXMgPSByZXN1bHQgJiYgcmVzdWx0LnBhcmFtcyB8fCB7fTtcbiAgcmV0dXJuIHtcbiAgICBtYXRjaGVzOiByZXN1bHQgIT09IGZhbHNlLFxuICAgIHBhcmFtc1xuICB9O1xufVxuXG4vLyBzcmMvaGFuZGxlcnMvUmVxdWVzdEhhbmRsZXIudHNcbnZhciBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDggPSByZXF1aXJlKFwiaGVhZGVycy1wb2x5ZmlsbFwiKTtcblxuLy8gc3JjL3Jlc3BvbnNlLnRzXG52YXIgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGw3ID0gcmVxdWlyZShcImhlYWRlcnMtcG9seWZpbGxcIik7XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9jb21wb3NlLnRzXG5mdW5jdGlvbiBjb21wb3NlKC4uLmZucykge1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gZm5zLnJlZHVjZVJpZ2h0KChsZWZ0Rm4sIHJpZ2h0Rm4pID0+IHtcbiAgICAgIHJldHVybiBsZWZ0Rm4gaW5zdGFuY2VvZiBQcm9taXNlID8gUHJvbWlzZS5yZXNvbHZlKGxlZnRGbikudGhlbihyaWdodEZuKSA6IHJpZ2h0Rm4obGVmdEZuKTtcbiAgICB9LCBhcmdzWzBdKTtcbiAgfTtcbn1cblxuLy8gc3JjL3Jlc3BvbnNlLnRzXG52YXIgZGVmYXVsdFJlc3BvbnNlID0ge1xuICBzdGF0dXM6IDIwMCxcbiAgc3RhdHVzVGV4dDogXCJPS1wiLFxuICBib2R5OiBudWxsLFxuICBkZWxheTogMCxcbiAgb25jZTogZmFsc2UsXG4gIHBhc3N0aHJvdWdoOiBmYWxzZVxufTtcbnZhciBkZWZhdWx0UmVzcG9uc2VUcmFuc2Zvcm1lcnMgPSBbXTtcbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlQ29tcG9zaXRpb24ocmVzcG9uc2VPdmVycmlkZXMsIGRlZmF1bHRUcmFuc2Zvcm1lcnMgPSBkZWZhdWx0UmVzcG9uc2VUcmFuc2Zvcm1lcnMpIHtcbiAgcmV0dXJuIGFzeW5jICguLi50cmFuc2Zvcm1lcnMpID0+IHtcbiAgICBjb25zdCBpbml0aWFsUmVzcG9uc2UgPSBPYmplY3QuYXNzaWduKFxuICAgICAge30sXG4gICAgICBkZWZhdWx0UmVzcG9uc2UsXG4gICAgICB7XG4gICAgICAgIGhlYWRlcnM6IG5ldyBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDcuSGVhZGVycyh7XG4gICAgICAgICAgXCJ4LXBvd2VyZWQtYnlcIjogXCJtc3dcIlxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNlT3ZlcnJpZGVzXG4gICAgKTtcbiAgICBjb25zdCByZXNvbHZlZFRyYW5zZm9ybWVycyA9IFtcbiAgICAgIC4uLmRlZmF1bHRUcmFuc2Zvcm1lcnMsXG4gICAgICAuLi50cmFuc2Zvcm1lcnNcbiAgICBdLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCByZXNvbHZlZFJlc3BvbnNlID0gcmVzb2x2ZWRUcmFuc2Zvcm1lcnMubGVuZ3RoID4gMCA/IGNvbXBvc2UoLi4ucmVzb2x2ZWRUcmFuc2Zvcm1lcnMpKGluaXRpYWxSZXNwb25zZSkgOiBpbml0aWFsUmVzcG9uc2U7XG4gICAgcmV0dXJuIHJlc29sdmVkUmVzcG9uc2U7XG4gIH07XG59XG52YXIgcmVzcG9uc2UgPSBPYmplY3QuYXNzaWduKGNyZWF0ZVJlc3BvbnNlQ29tcG9zaXRpb24oKSwge1xuICBvbmNlOiBjcmVhdGVSZXNwb25zZUNvbXBvc2l0aW9uKHsgb25jZTogdHJ1ZSB9KSxcbiAgbmV0d29ya0Vycm9yKG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKG1lc3NhZ2UpO1xuICB9XG59KTtcblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL2dldENhbGxGcmFtZS50c1xudmFyIFNPVVJDRV9GUkFNRSA9IC9bXFwvXFxcXF1tc3dbXFwvXFxcXF1zcmNbXFwvXFxcXF0oLispLztcbnZhciBCVUlMRF9GUkFNRSA9IC8obm9kZV9tb2R1bGVzKT9bXFwvXFxcXF1saWJbXFwvXFxcXF0odW1kfGVzbXxpaWVmfGNqcylbXFwvXFxcXF18XlteXFwvXFxcXF0qJC87XG5mdW5jdGlvbiBnZXRDYWxsRnJhbWUoZXJyb3IyKSB7XG4gIGNvbnN0IHN0YWNrID0gZXJyb3IyLnN0YWNrO1xuICBpZiAoIXN0YWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZyYW1lcyA9IHN0YWNrLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDEpO1xuICBjb25zdCBkZWNsYXJhdGlvbkZyYW1lID0gZnJhbWVzLmZpbmQoKGZyYW1lKSA9PiB7XG4gICAgcmV0dXJuICEoU09VUkNFX0ZSQU1FLnRlc3QoZnJhbWUpIHx8IEJVSUxEX0ZSQU1FLnRlc3QoZnJhbWUpKTtcbiAgfSk7XG4gIGlmICghZGVjbGFyYXRpb25GcmFtZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkZWNsYXJhdGlvblBhdGggPSBkZWNsYXJhdGlvbkZyYW1lLnJlcGxhY2UoL1xccyphdCBbXigpXSpcXCgoW14pXSspXFwpLywgXCIkMVwiKS5yZXBsYWNlKC9eQC8sIFwiXCIpO1xuICByZXR1cm4gZGVjbGFyYXRpb25QYXRoO1xufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvaXNJdGVyYWJsZS50c1xuZnVuY3Rpb24gaXNJdGVyYWJsZShmbikge1xuICBpZiAoIWZuKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgZm5bU3ltYm9sLml0ZXJhdG9yXSA9PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8vIHNyYy9oYW5kbGVycy9SZXF1ZXN0SGFuZGxlci50c1xudmFyIGRlZmF1bHRDb250ZXh0ID0ge1xuICBzdGF0dXMsXG4gIHNldCxcbiAgZGVsYXksXG4gIGZldGNoXG59O1xudmFyIFJlcXVlc3RIYW5kbGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5zaG91bGRTa2lwID0gZmFsc2U7XG4gICAgdGhpcy5jdHggPSBvcHRpb25zLmN0eCB8fCBkZWZhdWx0Q29udGV4dDtcbiAgICB0aGlzLnJlc29sdmVyID0gb3B0aW9ucy5yZXNvbHZlcjtcbiAgICBjb25zdCBjYWxsRnJhbWUgPSBnZXRDYWxsRnJhbWUobmV3IEVycm9yKCkpO1xuICAgIHRoaXMuaW5mbyA9IHtcbiAgICAgIC4uLm9wdGlvbnMuaW5mbyxcbiAgICAgIGNhbGxGcmFtZVxuICAgIH07XG4gIH1cbiAgcGFyc2UoX3JlcXVlc3QsIF9yZXNvbHV0aW9uQ29udGV4dCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRlc3QocmVxdWVzdCwgcmVzb2x1dGlvbkNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGhpcy5wYXJzZShyZXF1ZXN0LCByZXNvbHV0aW9uQ29udGV4dCksXG4gICAgICByZXNvbHV0aW9uQ29udGV4dFxuICAgICk7XG4gIH1cbiAgZ2V0UHVibGljUmVxdWVzdChyZXF1ZXN0LCBfcGFyc2VkUmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cbiAgbWFya0FzU2tpcHBlZChzaG91bGRTa2lwID0gdHJ1ZSkge1xuICAgIHRoaXMuc2hvdWxkU2tpcCA9IHNob3VsZFNraXA7XG4gIH1cbiAgYXN5bmMgcnVuKHJlcXVlc3QsIHJlc29sdXRpb25Db250ZXh0KSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkU2tpcCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFJlc3VsdCA9IHRoaXMucGFyc2UocmVxdWVzdCwgcmVzb2x1dGlvbkNvbnRleHQpO1xuICAgIGNvbnN0IHNob3VsZEludGVyY2VwdCA9IHRoaXMucHJlZGljYXRlKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHBhcnNlZFJlc3VsdCxcbiAgICAgIHJlc29sdXRpb25Db250ZXh0XG4gICAgKTtcbiAgICBpZiAoIXNob3VsZEludGVyY2VwdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY1JlcXVlc3QgPSB0aGlzLmdldFB1YmxpY1JlcXVlc3QocmVxdWVzdCwgcGFyc2VkUmVzdWx0KTtcbiAgICBjb25zdCBleGVjdXRlUmVzb2x2ZXIgPSB0aGlzLndyYXBSZXNvbHZlcih0aGlzLnJlc29sdmVyKTtcbiAgICBjb25zdCBtb2NrZWRSZXNwb25zZSA9IGF3YWl0IGV4ZWN1dGVSZXNvbHZlcihcbiAgICAgIHB1YmxpY1JlcXVlc3QsXG4gICAgICByZXNwb25zZSxcbiAgICAgIHRoaXMuY3R4XG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVFeGVjdXRpb25SZXN1bHQoXG4gICAgICBwYXJzZWRSZXN1bHQsXG4gICAgICBwdWJsaWNSZXF1ZXN0LFxuICAgICAgbW9ja2VkUmVzcG9uc2VcbiAgICApO1xuICB9XG4gIHdyYXBSZXNvbHZlcihyZXNvbHZlcikge1xuICAgIHJldHVybiBhc3luYyAocmVxLCByZXMsIGN0eCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXNvbHZlckdlbmVyYXRvciB8fCBhd2FpdCByZXNvbHZlcihyZXEsIHJlcywgY3R4KTtcbiAgICAgIGlmIChpc0l0ZXJhYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gcmVzdWx0W1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCk7XG4gICAgICAgIGNvbnN0IG5leHRSZXNwb25zZSA9IGF3YWl0IHZhbHVlO1xuICAgICAgICBpZiAoIW5leHRSZXNwb25zZSAmJiBkb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZXJHZW5lcmF0b3JSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJlc29sdmVyR2VuZXJhdG9yKSB7XG4gICAgICAgICAgdGhpcy5yZXNvbHZlckdlbmVyYXRvciA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc29sdmVyR2VuZXJhdG9yUmVzdWx0ID0gbmV4dFJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gbmV4dFJlc3BvbnNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG4gIGNyZWF0ZUV4ZWN1dGlvblJlc3VsdChwYXJzZWRSZXN1bHQsIHJlcXVlc3QsIHJlc3BvbnNlMikge1xuICAgIHJldHVybiB7XG4gICAgICBoYW5kbGVyOiB0aGlzLFxuICAgICAgcGFyc2VkUmVzdWx0OiBwYXJzZWRSZXN1bHQgfHwgbnVsbCxcbiAgICAgIHJlcXVlc3QsXG4gICAgICByZXNwb25zZTogcmVzcG9uc2UyIHx8IG51bGxcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvaGFuZGxlcnMvUmVzdEhhbmRsZXIudHNcbnZhciBSRVNUTWV0aG9kcyA9IC8qIEBfX1BVUkVfXyAqLyAoKFJFU1RNZXRob2RzMikgPT4ge1xuICBSRVNUTWV0aG9kczJbXCJIRUFEXCJdID0gXCJIRUFEXCI7XG4gIFJFU1RNZXRob2RzMltcIkdFVFwiXSA9IFwiR0VUXCI7XG4gIFJFU1RNZXRob2RzMltcIlBPU1RcIl0gPSBcIlBPU1RcIjtcbiAgUkVTVE1ldGhvZHMyW1wiUFVUXCJdID0gXCJQVVRcIjtcbiAgUkVTVE1ldGhvZHMyW1wiUEFUQ0hcIl0gPSBcIlBBVENIXCI7XG4gIFJFU1RNZXRob2RzMltcIk9QVElPTlNcIl0gPSBcIk9QVElPTlNcIjtcbiAgUkVTVE1ldGhvZHMyW1wiREVMRVRFXCJdID0gXCJERUxFVEVcIjtcbiAgcmV0dXJuIFJFU1RNZXRob2RzMjtcbn0pKFJFU1RNZXRob2RzIHx8IHt9KTtcbnZhciByZXN0Q29udGV4dCA9IHtcbiAgLi4uZGVmYXVsdENvbnRleHQsXG4gIGNvb2tpZSxcbiAgYm9keSxcbiAgdGV4dCxcbiAganNvbixcbiAgeG1sXG59O1xudmFyIFJlc3RSZXF1ZXN0ID0gY2xhc3MgZXh0ZW5kcyBNb2NrZWRSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IocmVxdWVzdCwgcGFyYW1zKSB7XG4gICAgc3VwZXIocmVxdWVzdC51cmwsIHtcbiAgICAgIC4uLnJlcXVlc3QsXG4gICAgICBib2R5OiByZXF1ZXN0W1wiX2JvZHlcIl1cbiAgICB9KTtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLmlkID0gcmVxdWVzdC5pZDtcbiAgfVxufTtcbnZhciBSZXN0SGFuZGxlciA9IGNsYXNzIGV4dGVuZHMgUmVxdWVzdEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihtZXRob2QsIHBhdGgsIHJlc29sdmVyKSB7XG4gICAgc3VwZXIoe1xuICAgICAgaW5mbzoge1xuICAgICAgICBoZWFkZXI6IGAke21ldGhvZH0gJHtwYXRofWAsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG1ldGhvZFxuICAgICAgfSxcbiAgICAgIGN0eDogcmVzdENvbnRleHQsXG4gICAgICByZXNvbHZlclxuICAgIH0pO1xuICAgIHRoaXMuY2hlY2tSZWR1bmRhbnRRdWVyeVBhcmFtZXRlcnMoKTtcbiAgfVxuICBjaGVja1JlZHVuZGFudFF1ZXJ5UGFyYW1ldGVycygpIHtcbiAgICBjb25zdCB7IG1ldGhvZCwgcGF0aCB9ID0gdGhpcy5pbmZvO1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGNsZWFuVXJsKHBhdGgpO1xuICAgIGlmICh1cmwgPT09IHBhdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gZ2V0U2VhcmNoUGFyYW1zKHBhdGgpO1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gW107XG4gICAgc2VhcmNoUGFyYW1zLmZvckVhY2goKF8sIHBhcmFtTmFtZSkgPT4ge1xuICAgICAgcXVlcnlQYXJhbXMucHVzaChwYXJhbU5hbWUpO1xuICAgIH0pO1xuICAgIGRldlV0aWxzLndhcm4oXG4gICAgICBgRm91bmQgYSByZWR1bmRhbnQgdXNhZ2Ugb2YgcXVlcnkgcGFyYW1ldGVycyBpbiB0aGUgcmVxdWVzdCBoYW5kbGVyIFVSTCBmb3IgXCIke21ldGhvZH0gJHtwYXRofVwiLiBQbGVhc2UgbWF0Y2ggYWdhaW5zdCBhIHBhdGggaW5zdGVhZCBhbmQgYWNjZXNzIHF1ZXJ5IHBhcmFtZXRlcnMgaW4gdGhlIHJlc3BvbnNlIHJlc29sdmVyIGZ1bmN0aW9uIHVzaW5nIFwicmVxLnVybC5zZWFyY2hQYXJhbXNcIi5gXG4gICAgKTtcbiAgfVxuICBwYXJzZShyZXF1ZXN0LCByZXNvbHV0aW9uQ29udGV4dCkge1xuICAgIHJldHVybiBtYXRjaFJlcXVlc3RVcmwoXG4gICAgICByZXF1ZXN0LnVybCxcbiAgICAgIHRoaXMuaW5mby5wYXRoLFxuICAgICAgcmVzb2x1dGlvbkNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc29sdXRpb25Db250ZXh0LmJhc2VVcmxcbiAgICApO1xuICB9XG4gIGdldFB1YmxpY1JlcXVlc3QocmVxdWVzdCwgcGFyc2VkUmVzdWx0KSB7XG4gICAgcmV0dXJuIG5ldyBSZXN0UmVxdWVzdChyZXF1ZXN0LCBwYXJzZWRSZXN1bHQucGFyYW1zIHx8IHt9KTtcbiAgfVxuICBwcmVkaWNhdGUocmVxdWVzdCwgcGFyc2VkUmVzdWx0KSB7XG4gICAgY29uc3QgbWF0Y2hlc01ldGhvZCA9IHRoaXMuaW5mby5tZXRob2QgaW5zdGFuY2VvZiBSZWdFeHAgPyB0aGlzLmluZm8ubWV0aG9kLnRlc3QocmVxdWVzdC5tZXRob2QpIDogaXNTdHJpbmdFcXVhbCh0aGlzLmluZm8ubWV0aG9kLCByZXF1ZXN0Lm1ldGhvZCk7XG4gICAgcmV0dXJuIG1hdGNoZXNNZXRob2QgJiYgcGFyc2VkUmVzdWx0Lm1hdGNoZXM7XG4gIH1cbiAgbG9nKHJlcXVlc3QsIHJlc3BvbnNlMikge1xuICAgIGNvbnN0IHB1YmxpY1VybCA9IGdldFB1YmxpY1VybEZyb21SZXF1ZXN0KHJlcXVlc3QpO1xuICAgIGNvbnN0IGxvZ2dlZFJlcXVlc3QgPSBwcmVwYXJlUmVxdWVzdChyZXF1ZXN0KTtcbiAgICBjb25zdCBsb2dnZWRSZXNwb25zZSA9IHByZXBhcmVSZXNwb25zZShyZXNwb25zZTIpO1xuICAgIGNvbnN0IHN0YXR1c0NvbG9yID0gZ2V0U3RhdHVzQ29kZUNvbG9yKHJlc3BvbnNlMi5zdGF0dXMpO1xuICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXG4gICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFwiJXMgJXMgJXMgKCVjJXMlYylcIiksXG4gICAgICBnZXRUaW1lc3RhbXAoKSxcbiAgICAgIHJlcXVlc3QubWV0aG9kLFxuICAgICAgcHVibGljVXJsLFxuICAgICAgYGNvbG9yOiR7c3RhdHVzQ29sb3J9YCxcbiAgICAgIGAke3Jlc3BvbnNlMi5zdGF0dXN9ICR7cmVzcG9uc2UyLnN0YXR1c1RleHR9YCxcbiAgICAgIFwiY29sb3I6aW5oZXJpdFwiXG4gICAgKTtcbiAgICBjb25zb2xlLmxvZyhcIlJlcXVlc3RcIiwgbG9nZ2VkUmVxdWVzdCk7XG4gICAgY29uc29sZS5sb2coXCJIYW5kbGVyOlwiLCB0aGlzKTtcbiAgICBjb25zb2xlLmxvZyhcIlJlc3BvbnNlXCIsIGxvZ2dlZFJlc3BvbnNlKTtcbiAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb250ZXh0L2ZpZWxkLnRzXG52YXIgaW1wb3J0X291dHZhcmlhbnQzID0gcmVxdWlyZShcIm91dHZhcmlhbnRcIik7XG52YXIgZmllbGQgPSAoZmllbGROYW1lLCBmaWVsZFZhbHVlKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgdmFsaWRhdGVGaWVsZE5hbWUoZmllbGROYW1lKTtcbiAgICBjb25zdCBwcmV2Qm9keSA9IGpzb25QYXJzZShyZXMuYm9keSkgfHwge307XG4gICAgY29uc3QgbmV4dEJvZHkgPSBtZXJnZVJpZ2h0KHByZXZCb2R5LCB7IFtmaWVsZE5hbWVdOiBmaWVsZFZhbHVlIH0pO1xuICAgIHJldHVybiBqc29uKG5leHRCb2R5KShyZXMpO1xuICB9O1xufTtcbmZ1bmN0aW9uIHZhbGlkYXRlRmllbGROYW1lKGZpZWxkTmFtZSkge1xuICAoMCwgaW1wb3J0X291dHZhcmlhbnQzLmludmFyaWFudCkoXG4gICAgZmllbGROYW1lLnRyaW0oKSAhPT0gXCJcIixcbiAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgXCJGYWlsZWQgdG8gc2V0IGEgY3VzdG9tIGZpZWxkIG9uIGEgR3JhcGhRTCByZXNwb25zZTogZmllbGQgbmFtZSBjYW5ub3QgYmUgZW1wdHkuXCJcbiAgICApXG4gICk7XG4gICgwLCBpbXBvcnRfb3V0dmFyaWFudDMuaW52YXJpYW50KShcbiAgICBmaWVsZE5hbWUgIT09IFwiZGF0YVwiLFxuICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAnRmFpbGVkIHRvIHNldCBhIGN1c3RvbSBcIiVzXCIgZmllbGQgb24gYSBtb2NrZWQgR3JhcGhRTCByZXNwb25zZTogZm9yYmlkZGVuIGZpZWxkIG5hbWUuIERpZCB5b3UgbWVhbiB0byBjYWxsIFwiY3R4LmRhdGEoKVwiIGluc3RlYWQ/JyxcbiAgICAgIGZpZWxkTmFtZVxuICAgIClcbiAgKTtcbiAgKDAsIGltcG9ydF9vdXR2YXJpYW50My5pbnZhcmlhbnQpKFxuICAgIGZpZWxkTmFtZSAhPT0gXCJlcnJvcnNcIixcbiAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgJ0ZhaWxlZCB0byBzZXQgYSBjdXN0b20gXCIlc1wiIGZpZWxkIG9uIGEgbW9ja2VkIEdyYXBoUUwgcmVzcG9uc2U6IGZvcmJpZGRlbiBmaWVsZCBuYW1lLiBEaWQgeW91IG1lYW4gdG8gY2FsbCBcImN0eC5lcnJvcnMoKVwiIGluc3RlYWQ/JyxcbiAgICAgIGZpZWxkTmFtZVxuICAgIClcbiAgKTtcbiAgKDAsIGltcG9ydF9vdXR2YXJpYW50My5pbnZhcmlhbnQpKFxuICAgIGZpZWxkTmFtZSAhPT0gXCJleHRlbnNpb25zXCIsXG4gICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICdGYWlsZWQgdG8gc2V0IGEgY3VzdG9tIFwiJXNcIiBmaWVsZCBvbiBhIG1vY2tlZCBHcmFwaFFMIHJlc3BvbnNlOiBmb3JiaWRkZW4gZmllbGQgbmFtZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgXCJjdHguZXh0ZW5zaW9ucygpXCIgaW5zdGVhZD8nLFxuICAgICAgZmllbGROYW1lXG4gICAgKVxuICApO1xufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvdHJ5Q2F0Y2gudHNcbmZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvbkV4Y2VwdGlvbikge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGZuKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgb25FeGNlcHRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IG9uRXhjZXB0aW9uKGVycm9yMik7XG4gIH1cbn1cblxuLy8gc3JjL2hhbmRsZXJzL0dyYXBoUUxIYW5kbGVyLnRzXG52YXIgZ3JhcGhxbENvbnRleHQgPSB7XG4gIC4uLmRlZmF1bHRDb250ZXh0LFxuICBkYXRhLFxuICBleHRlbnNpb25zLFxuICBlcnJvcnMsXG4gIGNvb2tpZSxcbiAgZmllbGRcbn07XG5mdW5jdGlvbiBpc0RvY3VtZW50Tm9kZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwia2luZFwiIGluIHZhbHVlICYmIFwiZGVmaW5pdGlvbnNcIiBpbiB2YWx1ZTtcbn1cbnZhciBHcmFwaFFMUmVxdWVzdCA9IGNsYXNzIGV4dGVuZHMgTW9ja2VkUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yKHJlcXVlc3QsIHZhcmlhYmxlcywgb3BlcmF0aW9uTmFtZSkge1xuICAgIHN1cGVyKHJlcXVlc3QudXJsLCB7XG4gICAgICAuLi5yZXF1ZXN0LFxuICAgICAgYm9keTogcmVxdWVzdFtcIl9ib2R5XCJdXG4gICAgfSk7XG4gICAgdGhpcy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgdGhpcy5vcGVyYXRpb25OYW1lID0gb3BlcmF0aW9uTmFtZTtcbiAgfVxufTtcbnZhciBHcmFwaFFMSGFuZGxlciA9IGNsYXNzIGV4dGVuZHMgUmVxdWVzdEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihvcGVyYXRpb25UeXBlLCBvcGVyYXRpb25OYW1lLCBlbmRwb2ludCwgcmVzb2x2ZXIpIHtcbiAgICBsZXQgcmVzb2x2ZWRPcGVyYXRpb25OYW1lID0gb3BlcmF0aW9uTmFtZTtcbiAgICBpZiAoaXNEb2N1bWVudE5vZGUob3BlcmF0aW9uTmFtZSkpIHtcbiAgICAgIGNvbnN0IHBhcnNlZE5vZGUgPSBwYXJzZURvY3VtZW50Tm9kZShvcGVyYXRpb25OYW1lKTtcbiAgICAgIGlmIChwYXJzZWROb2RlLm9wZXJhdGlvblR5cGUgIT09IG9wZXJhdGlvblR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gY3JlYXRlIGEgR3JhcGhRTCBoYW5kbGVyOiBwcm92aWRlZCBhIERvY3VtZW50Tm9kZSB3aXRoIGEgbWlzbWF0Y2hlZCBvcGVyYXRpb24gdHlwZSAoZXhwZWN0ZWQgXCIke29wZXJhdGlvblR5cGV9XCIsIGJ1dCBnb3QgXCIke3BhcnNlZE5vZGUub3BlcmF0aW9uVHlwZX1cIikuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCFwYXJzZWROb2RlLm9wZXJhdGlvbk5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gY3JlYXRlIGEgR3JhcGhRTCBoYW5kbGVyOiBwcm92aWRlZCBhIERvY3VtZW50Tm9kZSB3aXRoIG5vIG9wZXJhdGlvbiBuYW1lLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmVkT3BlcmF0aW9uTmFtZSA9IHBhcnNlZE5vZGUub3BlcmF0aW9uTmFtZTtcbiAgICB9XG4gICAgY29uc3QgaGVhZGVyID0gb3BlcmF0aW9uVHlwZSA9PT0gXCJhbGxcIiA/IGAke29wZXJhdGlvblR5cGV9IChvcmlnaW46ICR7ZW5kcG9pbnQudG9TdHJpbmcoKX0pYCA6IGAke29wZXJhdGlvblR5cGV9ICR7cmVzb2x2ZWRPcGVyYXRpb25OYW1lfSAob3JpZ2luOiAke2VuZHBvaW50LnRvU3RyaW5nKCl9KWA7XG4gICAgc3VwZXIoe1xuICAgICAgaW5mbzoge1xuICAgICAgICBoZWFkZXIsXG4gICAgICAgIG9wZXJhdGlvblR5cGUsXG4gICAgICAgIG9wZXJhdGlvbk5hbWU6IHJlc29sdmVkT3BlcmF0aW9uTmFtZVxuICAgICAgfSxcbiAgICAgIGN0eDogZ3JhcGhxbENvbnRleHQsXG4gICAgICByZXNvbHZlclxuICAgIH0pO1xuICAgIHRoaXMuZW5kcG9pbnQgPSBlbmRwb2ludDtcbiAgfVxuICBwYXJzZShyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRyeUNhdGNoKFxuICAgICAgKCkgPT4gcGFyc2VHcmFwaFFMUmVxdWVzdChyZXF1ZXN0KSxcbiAgICAgIChlcnJvcjIpID0+IGNvbnNvbGUuZXJyb3IoZXJyb3IyLm1lc3NhZ2UpXG4gICAgKTtcbiAgfVxuICBnZXRQdWJsaWNSZXF1ZXN0KHJlcXVlc3QsIHBhcnNlZFJlc3VsdCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIG5ldyBHcmFwaFFMUmVxdWVzdChcbiAgICAgIHJlcXVlc3QsXG4gICAgICAoX2EgPSBwYXJzZWRSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcnNlZFJlc3VsdC52YXJpYWJsZXMpICE9IG51bGwgPyBfYSA6IHt9LFxuICAgICAgKF9iID0gcGFyc2VkUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRSZXN1bHQub3BlcmF0aW9uTmFtZSkgIT0gbnVsbCA/IF9iIDogXCJcIlxuICAgICk7XG4gIH1cbiAgcHJlZGljYXRlKHJlcXVlc3QsIHBhcnNlZFJlc3VsdCkge1xuICAgIGlmICghcGFyc2VkUmVzdWx0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghcGFyc2VkUmVzdWx0Lm9wZXJhdGlvbk5hbWUgJiYgdGhpcy5pbmZvLm9wZXJhdGlvblR5cGUgIT09IFwiYWxsXCIpIHtcbiAgICAgIGNvbnN0IHB1YmxpY1VybCA9IGdldFB1YmxpY1VybEZyb21SZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgZGV2VXRpbHMud2FybihgRmFpbGVkIHRvIGludGVyY2VwdCBhIEdyYXBoUUwgcmVxdWVzdCBhdCBcIiR7cmVxdWVzdC5tZXRob2R9ICR7cHVibGljVXJsfVwiOiBhbm9ueW1vdXMgR3JhcGhRTCBvcGVyYXRpb25zIGFyZSBub3Qgc3VwcG9ydGVkLlxuXG5Db25zaWRlciBuYW1pbmcgdGhpcyBvcGVyYXRpb24gb3IgdXNpbmcgXCJncmFwaHFsLm9wZXJhdGlvbigpXCIgcmVxdWVzdCBoYW5kbGVyIHRvIGludGVyY2VwdCBHcmFwaFFMIHJlcXVlc3RzIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgb3BlcmF0aW9uIG5hbWUvdHlwZS4gUmVhZCBtb3JlOiBodHRwczovL21zd2pzLmlvL2RvY3MvYXBpL2dyYXBocWwvb3BlcmF0aW9uICAgICAgYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGhhc01hdGNoaW5nVXJsID0gbWF0Y2hSZXF1ZXN0VXJsKHJlcXVlc3QudXJsLCB0aGlzLmVuZHBvaW50KTtcbiAgICBjb25zdCBoYXNNYXRjaGluZ09wZXJhdGlvblR5cGUgPSB0aGlzLmluZm8ub3BlcmF0aW9uVHlwZSA9PT0gXCJhbGxcIiB8fCBwYXJzZWRSZXN1bHQub3BlcmF0aW9uVHlwZSA9PT0gdGhpcy5pbmZvLm9wZXJhdGlvblR5cGU7XG4gICAgY29uc3QgaGFzTWF0Y2hpbmdPcGVyYXRpb25OYW1lID0gdGhpcy5pbmZvLm9wZXJhdGlvbk5hbWUgaW5zdGFuY2VvZiBSZWdFeHAgPyB0aGlzLmluZm8ub3BlcmF0aW9uTmFtZS50ZXN0KHBhcnNlZFJlc3VsdC5vcGVyYXRpb25OYW1lIHx8IFwiXCIpIDogcGFyc2VkUmVzdWx0Lm9wZXJhdGlvbk5hbWUgPT09IHRoaXMuaW5mby5vcGVyYXRpb25OYW1lO1xuICAgIHJldHVybiBoYXNNYXRjaGluZ1VybC5tYXRjaGVzICYmIGhhc01hdGNoaW5nT3BlcmF0aW9uVHlwZSAmJiBoYXNNYXRjaGluZ09wZXJhdGlvbk5hbWU7XG4gIH1cbiAgbG9nKHJlcXVlc3QsIHJlc3BvbnNlMiwgcGFyc2VkUmVxdWVzdCkge1xuICAgIGNvbnN0IGxvZ2dlZFJlcXVlc3QgPSBwcmVwYXJlUmVxdWVzdChyZXF1ZXN0KTtcbiAgICBjb25zdCBsb2dnZWRSZXNwb25zZSA9IHByZXBhcmVSZXNwb25zZShyZXNwb25zZTIpO1xuICAgIGNvbnN0IHN0YXR1c0NvbG9yID0gZ2V0U3RhdHVzQ29kZUNvbG9yKHJlc3BvbnNlMi5zdGF0dXMpO1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gKHBhcnNlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcnNlZFJlcXVlc3Qub3BlcmF0aW9uTmFtZSkgPyBgJHtwYXJzZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRSZXF1ZXN0Lm9wZXJhdGlvblR5cGV9ICR7cGFyc2VkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkUmVxdWVzdC5vcGVyYXRpb25OYW1lfWAgOiBgYW5vbnltb3VzICR7cGFyc2VkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkUmVxdWVzdC5vcGVyYXRpb25UeXBlfWA7XG4gICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcbiAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXCIlcyAlcyAoJWMlcyVjKVwiKSxcbiAgICAgIGdldFRpbWVzdGFtcCgpLFxuICAgICAgYCR7cmVxdWVzdEluZm99YCxcbiAgICAgIGBjb2xvcjoke3N0YXR1c0NvbG9yfWAsXG4gICAgICBgJHtyZXNwb25zZTIuc3RhdHVzfSAke3Jlc3BvbnNlMi5zdGF0dXNUZXh0fWAsXG4gICAgICBcImNvbG9yOmluaGVyaXRcIlxuICAgICk7XG4gICAgY29uc29sZS5sb2coXCJSZXF1ZXN0OlwiLCBsb2dnZWRSZXF1ZXN0KTtcbiAgICBjb25zb2xlLmxvZyhcIkhhbmRsZXI6XCIsIHRoaXMpO1xuICAgIGNvbnNvbGUubG9nKFwiUmVzcG9uc2U6XCIsIGxvZ2dlZFJlc3BvbnNlKTtcbiAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L29uVW5oYW5kbGVkUmVxdWVzdC50c1xudmFyIE1BWF9NQVRDSF9TQ09SRSA9IDM7XG52YXIgTUFYX1NVR0dFU1RJT05fQ09VTlQgPSA0O1xudmFyIFRZUEVfTUFUQ0hfREVMVEEgPSAwLjU7XG5mdW5jdGlvbiBncm91cEhhbmRsZXJzQnlUeXBlKGhhbmRsZXJzKSB7XG4gIHJldHVybiBoYW5kbGVycy5yZWR1Y2UoXG4gICAgKGdyb3VwcywgaGFuZGxlcikgPT4ge1xuICAgICAgaWYgKGhhbmRsZXIgaW5zdGFuY2VvZiBSZXN0SGFuZGxlcikge1xuICAgICAgICBncm91cHMucmVzdC5wdXNoKGhhbmRsZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGhhbmRsZXIgaW5zdGFuY2VvZiBHcmFwaFFMSGFuZGxlcikge1xuICAgICAgICBncm91cHMuZ3JhcGhxbC5wdXNoKGhhbmRsZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9LFxuICAgIHtcbiAgICAgIHJlc3Q6IFtdLFxuICAgICAgZ3JhcGhxbDogW11cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBnZXRSZXN0SGFuZGxlclNjb3JlKCkge1xuICByZXR1cm4gKHJlcXVlc3QsIGhhbmRsZXIpID0+IHtcbiAgICBjb25zdCB7IHBhdGgsIG1ldGhvZCB9ID0gaGFuZGxlci5pbmZvO1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwIHx8IG1ldGhvZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICBjb25zdCBoYXNTYW1lTWV0aG9kID0gaXNTdHJpbmdFcXVhbChyZXF1ZXN0Lm1ldGhvZCwgbWV0aG9kKTtcbiAgICBjb25zdCBtZXRob2RTY29yZURlbHRhID0gaGFzU2FtZU1ldGhvZCA/IFRZUEVfTUFUQ0hfREVMVEEgOiAwO1xuICAgIGNvbnN0IHJlcXVlc3RQdWJsaWNVcmwgPSBnZXRQdWJsaWNVcmxGcm9tUmVxdWVzdChyZXF1ZXN0KTtcbiAgICBjb25zdCBzY29yZSA9ICgwLCBpbXBvcnRfanNfbGV2ZW5zaHRlaW4uZGVmYXVsdCkocmVxdWVzdFB1YmxpY1VybCwgcGF0aCk7XG4gICAgcmV0dXJuIHNjb3JlIC0gbWV0aG9kU2NvcmVEZWx0YTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEdyYXBoUUxIYW5kbGVyU2NvcmUocGFyc2VkUXVlcnkpIHtcbiAgcmV0dXJuIChfLCBoYW5kbGVyKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwYXJzZWRRdWVyeS5vcGVyYXRpb25OYW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIGNvbnN0IHsgb3BlcmF0aW9uVHlwZSwgb3BlcmF0aW9uTmFtZSB9ID0gaGFuZGxlci5pbmZvO1xuICAgIGlmICh0eXBlb2Ygb3BlcmF0aW9uTmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICBjb25zdCBoYXNTYW1lT3BlcmF0aW9uVHlwZSA9IHBhcnNlZFF1ZXJ5Lm9wZXJhdGlvblR5cGUgPT09IG9wZXJhdGlvblR5cGU7XG4gICAgY29uc3Qgb3BlcmF0aW9uVHlwZVNjb3JlRGVsdGEgPSBoYXNTYW1lT3BlcmF0aW9uVHlwZSA/IFRZUEVfTUFUQ0hfREVMVEEgOiAwO1xuICAgIGNvbnN0IHNjb3JlID0gKDAsIGltcG9ydF9qc19sZXZlbnNodGVpbi5kZWZhdWx0KShwYXJzZWRRdWVyeS5vcGVyYXRpb25OYW1lLCBvcGVyYXRpb25OYW1lKTtcbiAgICByZXR1cm4gc2NvcmUgLSBvcGVyYXRpb25UeXBlU2NvcmVEZWx0YTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFN1Z2dlc3RlZEhhbmRsZXIocmVxdWVzdCwgaGFuZGxlcnMsIGdldFNjb3JlKSB7XG4gIGNvbnN0IHN1Z2dlc3RlZEhhbmRsZXJzID0gaGFuZGxlcnMucmVkdWNlKChzdWdnZXN0aW9ucywgaGFuZGxlcikgPT4ge1xuICAgIGNvbnN0IHNjb3JlID0gZ2V0U2NvcmUocmVxdWVzdCwgaGFuZGxlcik7XG4gICAgcmV0dXJuIHN1Z2dlc3Rpb25zLmNvbmNhdChbW3Njb3JlLCBoYW5kbGVyXV0pO1xuICB9LCBbXSkuc29ydCgoW2xlZnRTY29yZV0sIFtyaWdodFNjb3JlXSkgPT4gbGVmdFNjb3JlIC0gcmlnaHRTY29yZSkuZmlsdGVyKChbc2NvcmVdKSA9PiBzY29yZSA8PSBNQVhfTUFUQ0hfU0NPUkUpLnNsaWNlKDAsIE1BWF9TVUdHRVNUSU9OX0NPVU5UKS5tYXAoKFssIGhhbmRsZXJdKSA9PiBoYW5kbGVyKTtcbiAgcmV0dXJuIHN1Z2dlc3RlZEhhbmRsZXJzO1xufVxuZnVuY3Rpb24gZ2V0U3VnZ2VzdGVkSGFuZGxlcnNNZXNzYWdlKGhhbmRsZXJzKSB7XG4gIGlmIChoYW5kbGVycy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGBEaWQgeW91IG1lYW4gdG8gcmVxdWVzdCBvbmUgb2YgdGhlIGZvbGxvd2luZyByZXNvdXJjZXMgaW5zdGVhZD9cblxuJHtoYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGAgIFxcdTIwMjIgJHtoYW5kbGVyLmluZm8uaGVhZGVyfWApLmpvaW4oXCJcXG5cIil9YDtcbiAgfVxuICByZXR1cm4gYERpZCB5b3UgbWVhbiB0byByZXF1ZXN0IFwiJHtoYW5kbGVyc1swXS5pbmZvLmhlYWRlcn1cIiBpbnN0ZWFkP2A7XG59XG5mdW5jdGlvbiBvblVuaGFuZGxlZFJlcXVlc3QocmVxdWVzdCwgaGFuZGxlcnMsIHN0cmF0ZWd5ID0gXCJ3YXJuXCIpIHtcbiAgY29uc3QgcGFyc2VkR3JhcGhRTFF1ZXJ5ID0gdHJ5Q2F0Y2goKCkgPT4gcGFyc2VHcmFwaFFMUmVxdWVzdChyZXF1ZXN0KSk7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlSGFuZGxlclN1Z2dlc3Rpb24oKSB7XG4gICAgY29uc3QgaGFuZGxlckdyb3VwcyA9IGdyb3VwSGFuZGxlcnNCeVR5cGUoaGFuZGxlcnMpO1xuICAgIGNvbnN0IHJlbGV2YW50SGFuZGxlcnMgPSBwYXJzZWRHcmFwaFFMUXVlcnkgPyBoYW5kbGVyR3JvdXBzLmdyYXBocWwgOiBoYW5kbGVyR3JvdXBzLnJlc3Q7XG4gICAgY29uc3Qgc3VnZ2VzdGVkSGFuZGxlcnMgPSBnZXRTdWdnZXN0ZWRIYW5kbGVyKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHJlbGV2YW50SGFuZGxlcnMsXG4gICAgICBwYXJzZWRHcmFwaFFMUXVlcnkgPyBnZXRHcmFwaFFMSGFuZGxlclNjb3JlKHBhcnNlZEdyYXBoUUxRdWVyeSkgOiBnZXRSZXN0SGFuZGxlclNjb3JlKClcbiAgICApO1xuICAgIHJldHVybiBzdWdnZXN0ZWRIYW5kbGVycy5sZW5ndGggPiAwID8gZ2V0U3VnZ2VzdGVkSGFuZGxlcnNNZXNzYWdlKHN1Z2dlc3RlZEhhbmRsZXJzKSA6IFwiXCI7XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVVbmhhbmRsZWRSZXF1ZXN0TWVzc2FnZSgpIHtcbiAgICBjb25zdCBwdWJsaWNVcmwgPSBnZXRQdWJsaWNVcmxGcm9tUmVxdWVzdChyZXF1ZXN0KTtcbiAgICBjb25zdCByZXF1ZXN0SGVhZGVyID0gcGFyc2VkR3JhcGhRTFF1ZXJ5ID8gYCR7cGFyc2VkR3JhcGhRTFF1ZXJ5Lm9wZXJhdGlvblR5cGV9ICR7cGFyc2VkR3JhcGhRTFF1ZXJ5Lm9wZXJhdGlvbk5hbWV9ICgke3JlcXVlc3QubWV0aG9kfSAke3B1YmxpY1VybH0pYCA6IGAke3JlcXVlc3QubWV0aG9kfSAke3B1YmxpY1VybH1gO1xuICAgIGNvbnN0IGhhbmRsZXJTdWdnZXN0aW9uID0gZ2VuZXJhdGVIYW5kbGVyU3VnZ2VzdGlvbigpO1xuICAgIGNvbnN0IG1lc3NhZ2VUZW1wbGF0ZSA9IFtcbiAgICAgIGBjYXB0dXJlZCBhIHJlcXVlc3Qgd2l0aG91dCBhIG1hdGNoaW5nIHJlcXVlc3QgaGFuZGxlcjpgLFxuICAgICAgYCAgXFx1MjAyMiAke3JlcXVlc3RIZWFkZXJ9YCxcbiAgICAgIGhhbmRsZXJTdWdnZXN0aW9uLFxuICAgICAgYElmIHlvdSBzdGlsbCB3aXNoIHRvIGludGVyY2VwdCB0aGlzIHVuaGFuZGxlZCByZXF1ZXN0LCBwbGVhc2UgY3JlYXRlIGEgcmVxdWVzdCBoYW5kbGVyIGZvciBpdC5cblJlYWQgbW9yZTogaHR0cHM6Ly9tc3dqcy5pby9kb2NzL2dldHRpbmctc3RhcnRlZC9tb2Nrc2BcbiAgICBdLmZpbHRlcihCb29sZWFuKTtcbiAgICByZXR1cm4gbWVzc2FnZVRlbXBsYXRlLmpvaW4oXCJcXG5cXG5cIik7XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlTdHJhdGVneShzdHJhdGVneTIpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2VuZXJhdGVVbmhhbmRsZWRSZXF1ZXN0TWVzc2FnZSgpO1xuICAgIHN3aXRjaCAoc3RyYXRlZ3kyKSB7XG4gICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICBkZXZVdGlscy5lcnJvcihcIkVycm9yOiAlc1wiLCBtZXNzYWdlKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgICAnQ2Fubm90IGJ5cGFzcyBhIHJlcXVlc3Qgd2hlbiB1c2luZyB0aGUgXCJlcnJvclwiIHN0cmF0ZWd5IGZvciB0aGUgXCJvblVuaGFuZGxlZFJlcXVlc3RcIiBvcHRpb24uJ1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ3YXJuXCI6IHtcbiAgICAgICAgZGV2VXRpbHMud2FybihcIldhcm5pbmc6ICVzXCIsIG1lc3NhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJieXBhc3NcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICAgICdGYWlsZWQgdG8gcmVhY3QgdG8gYW4gdW5oYW5kbGVkIHJlcXVlc3Q6IHVua25vd24gc3RyYXRlZ3kgXCIlc1wiLiBQbGVhc2UgcHJvdmlkZSBvbmUgb2YgdGhlIHN1cHBvcnRlZCBzdHJhdGVnaWVzIChcImJ5cGFzc1wiLCBcIndhcm5cIiwgXCJlcnJvclwiKSBvciBhIGN1c3RvbSBjYWxsYmFjayBmdW5jdGlvbiBhcyB0aGUgdmFsdWUgb2YgdGhlIFwib25VbmhhbmRsZWRSZXF1ZXN0XCIgb3B0aW9uLicsXG4gICAgICAgICAgICBzdHJhdGVneTJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygc3RyYXRlZ3kgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHN0cmF0ZWd5KHJlcXVlc3QsIHtcbiAgICAgIHdhcm5pbmc6IGFwcGx5U3RyYXRlZ3kuYmluZChudWxsLCBcIndhcm5cIiksXG4gICAgICBlcnJvcjogYXBwbHlTdHJhdGVneS5iaW5kKG51bGwsIFwiZXJyb3JcIilcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgYXBwbHlTdHJhdGVneShzdHJhdGVneSk7XG59XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L3JlYWRSZXNwb25zZUNvb2tpZXMudHNcbnZhciBpbXBvcnRfY29va2llczIgPSByZXF1aXJlKFwiQG1zd2pzL2Nvb2tpZXNcIik7XG5mdW5jdGlvbiByZWFkUmVzcG9uc2VDb29raWVzKHJlcXVlc3QsIHJlc3BvbnNlMikge1xuICBpbXBvcnRfY29va2llczIuc3RvcmUuYWRkKHsgLi4ucmVxdWVzdCwgdXJsOiByZXF1ZXN0LnVybC50b1N0cmluZygpIH0sIHJlc3BvbnNlMik7XG4gIGltcG9ydF9jb29raWVzMi5zdG9yZS5wZXJzaXN0KCk7XG59XG5cbi8vIHNyYy91dGlscy9oYW5kbGVSZXF1ZXN0LnRzXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0KHJlcXVlc3QsIGhhbmRsZXJzLCBvcHRpb25zLCBlbWl0dGVyLCBoYW5kbGVSZXF1ZXN0T3B0aW9ucykge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDpzdGFydFwiLCByZXF1ZXN0KTtcbiAgaWYgKHJlcXVlc3QuaGVhZGVycy5nZXQoXCJ4LW1zdy1ieXBhc3NcIikgPT09IFwidHJ1ZVwiKSB7XG4gICAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDplbmRcIiwgcmVxdWVzdCk7XG4gICAgKF9hID0gaGFuZGxlUmVxdWVzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVJlcXVlc3RPcHRpb25zLm9uUGFzc3Rocm91Z2hSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoaGFuZGxlUmVxdWVzdE9wdGlvbnMsIHJlcXVlc3QpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBbbG9va3VwRXJyb3IsIGxvb2t1cFJlc3VsdF0gPSBhd2FpdCAoMCwgaW1wb3J0X3VudGlsMi51bnRpbCkoKCkgPT4ge1xuICAgIHJldHVybiBnZXRSZXNwb25zZShcbiAgICAgIHJlcXVlc3QsXG4gICAgICBoYW5kbGVycyxcbiAgICAgIGhhbmRsZVJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVSZXF1ZXN0T3B0aW9ucy5yZXNvbHV0aW9uQ29udGV4dFxuICAgICk7XG4gIH0pO1xuICBpZiAobG9va3VwRXJyb3IpIHtcbiAgICBlbWl0dGVyLmVtaXQoXCJ1bmhhbmRsZWRFeGNlcHRpb25cIiwgbG9va3VwRXJyb3IsIHJlcXVlc3QpO1xuICAgIHRocm93IGxvb2t1cEVycm9yO1xuICB9XG4gIGNvbnN0IHsgaGFuZGxlciwgcmVzcG9uc2U6IHJlc3BvbnNlMiB9ID0gbG9va3VwUmVzdWx0O1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICBvblVuaGFuZGxlZFJlcXVlc3QocmVxdWVzdCwgaGFuZGxlcnMsIG9wdGlvbnMub25VbmhhbmRsZWRSZXF1ZXN0KTtcbiAgICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0OnVuaGFuZGxlZFwiLCByZXF1ZXN0KTtcbiAgICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0OmVuZFwiLCByZXF1ZXN0KTtcbiAgICAoX2IgPSBoYW5kbGVSZXF1ZXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUmVxdWVzdE9wdGlvbnMub25QYXNzdGhyb3VnaFJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChoYW5kbGVSZXF1ZXN0T3B0aW9ucywgcmVxdWVzdCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghcmVzcG9uc2UyKSB7XG4gICAgZGV2VXRpbHMud2FybihcbiAgICAgIGBFeHBlY3RlZCByZXNwb25zZSByZXNvbHZlciB0byByZXR1cm4gYSBtb2NrZWQgcmVzcG9uc2UgT2JqZWN0LCBidXQgZ290ICVzLiBUaGUgb3JpZ2luYWwgcmVzcG9uc2UgaXMgZ29pbmcgdG8gYmUgdXNlZCBpbnN0ZWFkLlxuXG4gIFxcdTIwMjIgJXNcbiAgICAlc2AsXG4gICAgICByZXNwb25zZTIsXG4gICAgICBoYW5kbGVyLmluZm8uaGVhZGVyLFxuICAgICAgaGFuZGxlci5pbmZvLmNhbGxGcmFtZVxuICAgICk7XG4gICAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDplbmRcIiwgcmVxdWVzdCk7XG4gICAgKF9jID0gaGFuZGxlUmVxdWVzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVJlcXVlc3RPcHRpb25zLm9uUGFzc3Rocm91Z2hSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwoaGFuZGxlUmVxdWVzdE9wdGlvbnMsIHJlcXVlc3QpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmVzcG9uc2UyLnBhc3N0aHJvdWdoKSB7XG4gICAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDplbmRcIiwgcmVxdWVzdCk7XG4gICAgKF9kID0gaGFuZGxlUmVxdWVzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVJlcXVlc3RPcHRpb25zLm9uUGFzc3Rocm91Z2hSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmNhbGwoaGFuZGxlUmVxdWVzdE9wdGlvbnMsIHJlcXVlc3QpO1xuICAgIHJldHVybjtcbiAgfVxuICByZWFkUmVzcG9uc2VDb29raWVzKHJlcXVlc3QsIHJlc3BvbnNlMik7XG4gIGVtaXR0ZXIuZW1pdChcInJlcXVlc3Q6bWF0Y2hcIiwgcmVxdWVzdCk7XG4gIGNvbnN0IHJlcXVpcmVkTG9va3VwUmVzdWx0ID0gbG9va3VwUmVzdWx0O1xuICBjb25zdCB0cmFuc2Zvcm1lZFJlc3BvbnNlID0gKChfZSA9IGhhbmRsZVJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVSZXF1ZXN0T3B0aW9ucy50cmFuc2Zvcm1SZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmNhbGwoaGFuZGxlUmVxdWVzdE9wdGlvbnMsIHJlc3BvbnNlMikpIHx8IHJlc3BvbnNlMjtcbiAgKF9mID0gaGFuZGxlUmVxdWVzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVJlcXVlc3RPcHRpb25zLm9uTW9ja2VkUmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZi5jYWxsKFxuICAgIGhhbmRsZVJlcXVlc3RPcHRpb25zLFxuICAgIHRyYW5zZm9ybWVkUmVzcG9uc2UsXG4gICAgcmVxdWlyZWRMb29rdXBSZXN1bHRcbiAgKTtcbiAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDplbmRcIiwgcmVxdWVzdCk7XG4gIHJldHVybiB0cmFuc2Zvcm1lZFJlc3BvbnNlO1xufVxuXG4vLyBzcmMvdXRpbHMvbG9nZ2luZy9zZXJpYWxpemVSZXNwb25zZS50c1xudmFyIGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsOSA9IHJlcXVpcmUoXCJoZWFkZXJzLXBvbHlmaWxsXCIpO1xuYXN5bmMgZnVuY3Rpb24gc2VyaWFsaXplUmVzcG9uc2UocmVzcG9uc2UyKSB7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzOiByZXNwb25zZTIuc3RhdHVzLFxuICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlMi5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6ICgwLCBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDkuZmxhdHRlbkhlYWRlcnNPYmplY3QpKCgwLCBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDkuaGVhZGVyc1RvT2JqZWN0KShyZXNwb25zZTIuaGVhZGVycykpLFxuICAgIGJvZHk6IGF3YWl0IHJlc3BvbnNlMi5jbG9uZSgpLnRleHQoKVxuICB9O1xufVxuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvY3JlYXRlUmVxdWVzdExpc3RlbmVyLnRzXG52YXIgY3JlYXRlUmVxdWVzdExpc3RlbmVyID0gKGNvbnRleHQsIG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIGFzeW5jIChldmVudCwgbWVzc2FnZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBtZXNzYWdlQ2hhbm5lbCA9IG5ldyBXb3JrZXJDaGFubmVsKGV2ZW50LnBvcnRzWzBdKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gcGFyc2VXb3JrZXJSZXF1ZXN0KG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGhhbmRsZVJlcXVlc3QoXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGNvbnRleHQucmVxdWVzdEhhbmRsZXJzLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBjb250ZXh0LmVtaXR0ZXIsXG4gICAgICAgIHtcbiAgICAgICAgICB0cmFuc2Zvcm1SZXNwb25zZSxcbiAgICAgICAgICBvblBhc3N0aHJvdWdoUmVzcG9uc2UoKSB7XG4gICAgICAgICAgICBtZXNzYWdlQ2hhbm5lbC5wb3N0TWVzc2FnZShcIk5PVF9GT1VORFwiKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFzeW5jIG9uTW9ja2VkUmVzcG9uc2UocmVzcG9uc2UyLCB7IGhhbmRsZXIsIHB1YmxpY1JlcXVlc3QsIHBhcnNlZFJlcXVlc3QgfSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlMi5ib2R5IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIGNvbnN0cnVjdCBhIG1vY2tlZCByZXNwb25zZSB3aXRoIGEgXCJSZWFkYWJsZVN0cmVhbVwiIGJvZHk6IG1vY2tlZCBzdHJlYW1zIGFyZSBub3Qgc3VwcG9ydGVkLiBGb2xsb3cgaHR0cHM6Ly9naXRodWIuY29tL21zd2pzL21zdy9pc3N1ZXMvMTMzNiBmb3IgbW9yZSBkZXRhaWxzLidcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUluc3RhbmNlID0gbmV3IFJlc3BvbnNlKHJlc3BvbnNlMi5ib2R5LCByZXNwb25zZTIpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VGb3JMb2dzID0gcmVzcG9uc2VJbnN0YW5jZS5jbG9uZSgpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5QnVmZmVyID0gYXdhaXQgcmVzcG9uc2VJbnN0YW5jZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gcmVzcG9uc2UyLmJvZHkgPT0gbnVsbCA/IG51bGwgOiByZXNwb25zZUJvZHlCdWZmZXI7XG4gICAgICAgICAgICBtZXNzYWdlQ2hhbm5lbC5wb3N0TWVzc2FnZShcbiAgICAgICAgICAgICAgXCJNT0NLX1JFU1BPTlNFXCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAuLi5yZXNwb25zZTIsXG4gICAgICAgICAgICAgICAgYm9keTogcmVzcG9uc2VCb2R5XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFtyZXNwb25zZUJvZHlCdWZmZXJdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnF1aWV0KSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci5vbmNlKFwicmVzcG9uc2U6bW9ja2VkXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmxvZyhcbiAgICAgICAgICAgICAgICAgIHB1YmxpY1JlcXVlc3QsXG4gICAgICAgICAgICAgICAgICBhd2FpdCBzZXJpYWxpemVSZXNwb25zZShyZXNwb25zZUZvckxvZ3MpLFxuICAgICAgICAgICAgICAgICAgcGFyc2VkUmVxdWVzdFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgIGlmIChlcnJvcjIgaW5zdGFuY2VvZiBOZXR3b3JrRXJyb3IpIHtcbiAgICAgICAgbWVzc2FnZUNoYW5uZWwucG9zdE1lc3NhZ2UoXCJORVRXT1JLX0VSUk9SXCIsIHtcbiAgICAgICAgICBuYW1lOiBlcnJvcjIubmFtZSxcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvcjIubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yMiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGRldlV0aWxzLmVycm9yKFxuICAgICAgICAgIGBVbmNhdWdodCBleGNlcHRpb24gaW4gdGhlIHJlcXVlc3QgaGFuZGxlciBmb3IgXCIlcyAlc1wiOlxuXG4lc1xuXG5UaGlzIGV4Y2VwdGlvbiBoYXMgYmVlbiBncmFjZWZ1bGx5IGhhbmRsZWQgYXMgYSA1MDAgcmVzcG9uc2UsIGhvd2V2ZXIsIGl0J3Mgc3Ryb25nbHkgcmVjb21tZW5kZWQgdG8gcmVzb2x2ZSB0aGlzIGVycm9yLCBhcyBpdCBpbmRpY2F0ZXMgYSBtaXN0YWtlIGluIHlvdXIgY29kZS4gSWYgeW91IHdpc2ggdG8gbW9jayBhbiBlcnJvciByZXNwb25zZSwgcGxlYXNlIHNlZSB0aGlzIGd1aWRlOiBodHRwczovL21zd2pzLmlvL2RvY3MvcmVjaXBlcy9tb2NraW5nLWVycm9yLXJlc3BvbnNlc2AsXG4gICAgICAgICAgcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgcmVxdWVzdC51cmwsXG4gICAgICAgICAgKF9hID0gZXJyb3IyLnN0YWNrKSAhPSBudWxsID8gX2EgOiBlcnJvcjJcbiAgICAgICAgKTtcbiAgICAgICAgbWVzc2FnZUNoYW5uZWwucG9zdE1lc3NhZ2UoXCJNT0NLX1JFU1BPTlNFXCIsIHtcbiAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgICBzdGF0dXNUZXh0OiBcIlJlcXVlc3QgSGFuZGxlciBFcnJvclwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBuYW1lOiBlcnJvcjIubmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yMi5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhY2s6IGVycm9yMi5zdGFja1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShyZXNwb25zZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6IHJlc3BvbnNlMi5zdGF0dXMsXG4gICAgc3RhdHVzVGV4dDogcmVzcG9uc2UyLnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogcmVzcG9uc2UyLmhlYWRlcnMuYWxsKCksXG4gICAgYm9keTogcmVzcG9uc2UyLmJvZHksXG4gICAgZGVsYXk6IHJlc3BvbnNlMi5kZWxheVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvcmVxdWVzdEludGVncml0eUNoZWNrLnRzXG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0SW50ZWdyaXR5Q2hlY2soY29udGV4dCwgc2VydmljZVdvcmtlcikge1xuICBjb250ZXh0LndvcmtlckNoYW5uZWwuc2VuZChcIklOVEVHUklUWV9DSEVDS19SRVFVRVNUXCIpO1xuICBjb25zdCB7IHBheWxvYWQ6IGFjdHVhbENoZWNrc3VtIH0gPSBhd2FpdCBjb250ZXh0LmV2ZW50cy5vbmNlKFxuICAgIFwiSU5URUdSSVRZX0NIRUNLX1JFU1BPTlNFXCJcbiAgKTtcbiAgaWYgKGFjdHVhbENoZWNrc3VtICE9PSBcIjNkNmI5ZjA2NDEwZDE3OWE3Zjc0MDRkNGJmNGMzYzcwXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ3VycmVudGx5IGFjdGl2ZSBTZXJ2aWNlIFdvcmtlciAoJHthY3R1YWxDaGVja3N1bX0pIGlzIGJlaGluZCB0aGUgbGF0ZXN0IHB1Ymxpc2hlZCBvbmUgKCR7XCIzZDZiOWYwNjQxMGQxNzlhN2Y3NDA0ZDRiZjRjM2M3MFwifSkuYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHNlcnZpY2VXb3JrZXI7XG59XG5cbi8vIHNyYy91dGlscy9kZWZlck5ldHdvcmtSZXF1ZXN0c1VudGlsLnRzXG52YXIgaW1wb3J0X3VudGlsMyA9IHJlcXVpcmUoXCJAb3Blbi1kcmFmdC91bnRpbFwiKTtcbmZ1bmN0aW9uIGRlZmVyTmV0d29ya1JlcXVlc3RzVW50aWwocHJlZGljYXRlUHJvbWlzZSkge1xuICBjb25zdCBvcmlnaW5hbFhoclNlbmQgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnNlbmQ7XG4gIHdpbmRvdy5YTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAoMCwgaW1wb3J0X3VudGlsMy51bnRpbCkoKCkgPT4gcHJlZGljYXRlUHJvbWlzZSkudGhlbigoKSA9PiB7XG4gICAgICB3aW5kb3cuWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnNlbmQgPSBvcmlnaW5hbFhoclNlbmQ7XG4gICAgICB0aGlzLnNlbmQoLi4uYXJncyk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IG9yaWdpbmFsRmV0Y2ggPSB3aW5kb3cuZmV0Y2g7XG4gIHdpbmRvdy5mZXRjaCA9IGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgYXdhaXQgKDAsIGltcG9ydF91bnRpbDMudW50aWwpKCgpID0+IHByZWRpY2F0ZVByb21pc2UpO1xuICAgIHdpbmRvdy5mZXRjaCA9IG9yaWdpbmFsRmV0Y2g7XG4gICAgcmV0dXJuIHdpbmRvdy5mZXRjaCguLi5hcmdzKTtcbiAgfTtcbn1cblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L2NyZWF0ZVJlc3BvbnNlTGlzdGVuZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlTGlzdGVuZXIoY29udGV4dCkge1xuICByZXR1cm4gKF8sIG1lc3NhZ2UpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBwYXlsb2FkOiByZXNwb25zZUpzb24gfSA9IG1lc3NhZ2U7XG4gICAgaWYgKChfYSA9IHJlc3BvbnNlSnNvbi50eXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoXCJvcGFxdWVcIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UyID0gbmV3IFJlc3BvbnNlKHJlc3BvbnNlSnNvbi5ib2R5IHx8IG51bGwsIHJlc3BvbnNlSnNvbik7XG4gICAgY29uc3QgaXNNb2NrZWRSZXNwb25zZSA9IHJlc3BvbnNlMi5oZWFkZXJzLmdldChcIngtcG93ZXJlZC1ieVwiKSA9PT0gXCJtc3dcIjtcbiAgICBpZiAoaXNNb2NrZWRSZXNwb25zZSkge1xuICAgICAgY29udGV4dC5lbWl0dGVyLmVtaXQoXCJyZXNwb25zZTptb2NrZWRcIiwgcmVzcG9uc2UyLCByZXNwb25zZUpzb24ucmVxdWVzdElkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5lbWl0dGVyLmVtaXQoXCJyZXNwb25zZTpieXBhc3NcIiwgcmVzcG9uc2UyLCByZXNwb25zZUpzb24ucmVxdWVzdElkKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC91dGlscy92YWxpZGF0ZVdvcmtlclNjb3BlLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZVdvcmtlclNjb3BlKHJlZ2lzdHJhdGlvbiwgb3B0aW9ucykge1xuICBpZiAoIShvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnF1aWV0KSAmJiAhbG9jYXRpb24uaHJlZi5zdGFydHNXaXRoKHJlZ2lzdHJhdGlvbi5zY29wZSkpIHtcbiAgICBkZXZVdGlscy53YXJuKFxuICAgICAgYENhbm5vdCBpbnRlcmNlcHQgcmVxdWVzdHMgb24gdGhpcyBwYWdlIGJlY2F1c2UgaXQncyBvdXRzaWRlIG9mIHRoZSB3b3JrZXIncyBzY29wZSAoXCIke3JlZ2lzdHJhdGlvbi5zY29wZX1cIikuIElmIHlvdSB3aXNoIHRvIG1vY2sgQVBJIHJlcXVlc3RzIG9uIHRoaXMgcGFnZSwgeW91IG11c3QgcmVzb2x2ZSB0aGlzIHNjb3BlIGlzc3VlLlxuXG4tIChSZWNvbW1lbmRlZCkgUmVnaXN0ZXIgdGhlIHdvcmtlciBhdCB0aGUgcm9vdCBsZXZlbCAoXCIvXCIpIG9mIHlvdXIgYXBwbGljYXRpb24uXG4tIFNldCB0aGUgXCJTZXJ2aWNlLVdvcmtlci1BbGxvd2VkXCIgcmVzcG9uc2UgaGVhZGVyIHRvIGFsbG93IG91dC1vZi1zY29wZSB3b3JrZXJzLmBcbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC9jcmVhdGVTdGFydEhhbmRsZXIudHNcbnZhciBjcmVhdGVTdGFydEhhbmRsZXIgPSAoY29udGV4dCkgPT4ge1xuICByZXR1cm4gZnVuY3Rpb24gc3RhcnQob3B0aW9ucywgY3VzdG9tT3B0aW9ucykge1xuICAgIGNvbnN0IHN0YXJ0V29ya2VySW5zdGFuY2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb250ZXh0LmV2ZW50cy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIGNvbnRleHQud29ya2VyQ2hhbm5lbC5vbihcbiAgICAgICAgXCJSRVFVRVNUXCIsXG4gICAgICAgIGNyZWF0ZVJlcXVlc3RMaXN0ZW5lcihjb250ZXh0LCBvcHRpb25zKVxuICAgICAgKTtcbiAgICAgIGNvbnRleHQud29ya2VyQ2hhbm5lbC5vbihcIlJFU1BPTlNFXCIsIGNyZWF0ZVJlc3BvbnNlTGlzdGVuZXIoY29udGV4dCkpO1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBhd2FpdCBnZXRXb3JrZXJJbnN0YW5jZShcbiAgICAgICAgb3B0aW9ucy5zZXJ2aWNlV29ya2VyLnVybCxcbiAgICAgICAgb3B0aW9ucy5zZXJ2aWNlV29ya2VyLm9wdGlvbnMsXG4gICAgICAgIG9wdGlvbnMuZmluZFdvcmtlclxuICAgICAgKTtcbiAgICAgIGNvbnN0IFt3b3JrZXIsIHJlZ2lzdHJhdGlvbl0gPSBpbnN0YW5jZTtcbiAgICAgIGlmICghd29ya2VyKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdXb3JrZXJNZXNzYWdlID0gKGN1c3RvbU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGN1c3RvbU9wdGlvbnMuZmluZFdvcmtlcikgPyBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAgIGBGYWlsZWQgdG8gbG9jYXRlIHRoZSBTZXJ2aWNlIFdvcmtlciByZWdpc3RyYXRpb24gdXNpbmcgYSBjdXN0b20gXCJmaW5kV29ya2VyXCIgcHJlZGljYXRlLlxuXG5QbGVhc2UgZW5zdXJlIHRoYXQgdGhlIGN1c3RvbSBwcmVkaWNhdGUgcHJvcGVybHkgbG9jYXRlcyB0aGUgU2VydmljZSBXb3JrZXIgcmVnaXN0cmF0aW9uIGF0IFwiJXNcIi5cbk1vcmUgZGV0YWlsczogaHR0cHM6Ly9tc3dqcy5pby9kb2NzL2FwaS9zZXR1cC13b3JrZXIvc3RhcnQjZmluZHdvcmtlclxuYCxcbiAgICAgICAgICBvcHRpb25zLnNlcnZpY2VXb3JrZXIudXJsXG4gICAgICAgICkgOiBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAgIGBGYWlsZWQgdG8gbG9jYXRlIHRoZSBTZXJ2aWNlIFdvcmtlciByZWdpc3RyYXRpb24uXG5cblRoaXMgbW9zdCBsaWtlbHkgbWVhbnMgdGhhdCB0aGUgd29ya2VyIHNjcmlwdCBVUkwgXCIlc1wiIGNhbm5vdCByZXNvbHZlIGFnYWluc3QgdGhlIGFjdHVhbCBwdWJsaWMgaG9zdG5hbWUgKCVzKS4gVGhpcyBtYXkgaGFwcGVuIGlmIHlvdXIgYXBwbGljYXRpb24gcnVucyBiZWhpbmQgYSBwcm94eSwgb3IgaGFzIGEgZHluYW1pYyBob3N0bmFtZS5cblxuUGxlYXNlIGNvbnNpZGVyIHVzaW5nIGEgY3VzdG9tIFwic2VydmljZVdvcmtlci51cmxcIiBvcHRpb24gdG8gcG9pbnQgdG8gdGhlIGFjdHVhbCB3b3JrZXIgc2NyaXB0IGxvY2F0aW9uLCBvciBhIGN1c3RvbSBcImZpbmRXb3JrZXJcIiBvcHRpb24gdG8gcmVzb2x2ZSB0aGUgU2VydmljZSBXb3JrZXIgcmVnaXN0cmF0aW9uIG1hbnVhbGx5LiBNb3JlIGRldGFpbHM6IGh0dHBzOi8vbXN3anMuaW8vZG9jcy9hcGkvc2V0dXAtd29ya2VyL3N0YXJ0YCxcbiAgICAgICAgICBvcHRpb25zLnNlcnZpY2VXb3JrZXIudXJsLFxuICAgICAgICAgIGxvY2F0aW9uLmhvc3RcbiAgICAgICAgKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1pc3NpbmdXb3JrZXJNZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQud29ya2VyID0gd29ya2VyO1xuICAgICAgY29udGV4dC5yZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb247XG4gICAgICBjb250ZXh0LmV2ZW50cy5hZGRMaXN0ZW5lcih3aW5kb3csIFwiYmVmb3JldW5sb2FkXCIsICgpID0+IHtcbiAgICAgICAgaWYgKHdvcmtlci5zdGF0ZSAhPT0gXCJyZWR1bmRhbnRcIikge1xuICAgICAgICAgIGNvbnRleHQud29ya2VyQ2hhbm5lbC5zZW5kKFwiQ0xJRU5UX0NMT1NFRFwiKTtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChjb250ZXh0LmtlZXBBbGl2ZUludGVydmFsKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgW2ludGVncml0eUVycm9yXSA9IGF3YWl0ICgwLCBpbXBvcnRfdW50aWw0LnVudGlsKShcbiAgICAgICAgKCkgPT4gcmVxdWVzdEludGVncml0eUNoZWNrKGNvbnRleHQsIHdvcmtlcilcbiAgICAgICk7XG4gICAgICBpZiAoaW50ZWdyaXR5RXJyb3IpIHtcbiAgICAgICAgZGV2VXRpbHMuZXJyb3IoYERldGVjdGVkIG91dGRhdGVkIFNlcnZpY2UgV29ya2VyOiAke2ludGVncml0eUVycm9yLm1lc3NhZ2V9XG5cblRoZSBtb2NraW5nIGlzIHN0aWxsIGVuYWJsZWQsIGJ1dCBpdCdzIGhpZ2hseSByZWNvbW1lbmRlZCB0aGF0IHlvdSB1cGRhdGUgeW91ciBTZXJ2aWNlIFdvcmtlciBieSBydW5uaW5nOlxuXG4kIG5weCBtc3cgaW5pdCA8UFVCTElDX0RJUj5cblxuVGhpcyBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIHRoYXQgdGhlIFNlcnZpY2UgV29ya2VyIGlzIGluIHN5bmMgd2l0aCB0aGUgbGlicmFyeSB0byBndWFyYW50ZWUgaXRzIHN0YWJpbGl0eS5cbklmIHRoaXMgbWVzc2FnZSBzdGlsbCBwZXJzaXN0cyBhZnRlciB1cGRhdGluZywgcGxlYXNlIHJlcG9ydCBhbiBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL29wZW4tZHJhZnQvbXN3L2lzc3VlcyAgICAgIGApO1xuICAgICAgfVxuICAgICAgY29udGV4dC5rZWVwQWxpdmVJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbChcbiAgICAgICAgKCkgPT4gY29udGV4dC53b3JrZXJDaGFubmVsLnNlbmQoXCJLRUVQQUxJVkVfUkVRVUVTVFwiKSxcbiAgICAgICAgNWUzXG4gICAgICApO1xuICAgICAgdmFsaWRhdGVXb3JrZXJTY29wZShyZWdpc3RyYXRpb24sIGNvbnRleHQuc3RhcnRPcHRpb25zKTtcbiAgICAgIHJldHVybiByZWdpc3RyYXRpb247XG4gICAgfTtcbiAgICBjb25zdCB3b3JrZXJSZWdpc3RyYXRpb24gPSBzdGFydFdvcmtlckluc3RhbmNlKCkudGhlbihcbiAgICAgIGFzeW5jIChyZWdpc3RyYXRpb24pID0+IHtcbiAgICAgICAgY29uc3QgcGVuZGluZ0luc3RhbmNlID0gcmVnaXN0cmF0aW9uLmluc3RhbGxpbmcgfHwgcmVnaXN0cmF0aW9uLndhaXRpbmc7XG4gICAgICAgIGlmIChwZW5kaW5nSW5zdGFuY2UpIHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgcGVuZGluZ0luc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJzdGF0ZWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChwZW5kaW5nSW5zdGFuY2Uuc3RhdGUgPT09IFwiYWN0aXZhdGVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmFibGVNb2NraW5nKGNvbnRleHQsIG9wdGlvbnMpLmNhdGNoKChlcnJvcjIpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBlbmFibGUgbW9ja2luZzogJHtlcnJvcjIgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yMi5tZXNzYWdlfWApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdHJhdGlvbjtcbiAgICAgIH1cbiAgICApO1xuICAgIGlmIChvcHRpb25zLndhaXRVbnRpbFJlYWR5KSB7XG4gICAgICBkZWZlck5ldHdvcmtSZXF1ZXN0c1VudGlsKHdvcmtlclJlZ2lzdHJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB3b3JrZXJSZWdpc3RyYXRpb247XG4gIH07XG59O1xuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RvcC91dGlscy9wcmludFN0b3BNZXNzYWdlLnRzXG5mdW5jdGlvbiBwcmludFN0b3BNZXNzYWdlKGFyZ3MgPSB7fSkge1xuICBpZiAoYXJncy5xdWlldCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLmxvZyhcbiAgICBgJWMke2RldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXCJNb2NraW5nIGRpc2FibGVkLlwiKX1gLFxuICAgIFwiY29sb3I6b3JhbmdlcmVkO2ZvbnQtd2VpZ2h0OmJvbGQ7XCJcbiAgKTtcbn1cblxuLy8gc3JjL3NldHVwV29ya2VyL3N0b3AvY3JlYXRlU3RvcC50c1xudmFyIGNyZWF0ZVN0b3AgPSAoY29udGV4dCkgPT4ge1xuICByZXR1cm4gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFjb250ZXh0LmlzTW9ja2luZ0VuYWJsZWQpIHtcbiAgICAgIGRldlV0aWxzLndhcm4oXG4gICAgICAgICdGb3VuZCBhIHJlZHVuZGFudCBcIndvcmtlci5zdG9wKClcIiBjYWxsLiBOb3RlIHRoYXQgc3RvcHBpbmcgdGhlIHdvcmtlciB3aGlsZSBtb2NraW5nIGFscmVhZHkgc3RvcHBlZCBoYXMgbm8gZWZmZWN0LiBDb25zaWRlciByZW1vdmluZyB0aGlzIFwid29ya2VyLnN0b3AoKVwiIGNhbGwuJ1xuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC53b3JrZXJDaGFubmVsLnNlbmQoXCJNT0NLX0RFQUNUSVZBVEVcIik7XG4gICAgY29udGV4dC5pc01vY2tpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgd2luZG93LmNsZWFySW50ZXJ2YWwoY29udGV4dC5rZWVwQWxpdmVJbnRlcnZhbCk7XG4gICAgcHJpbnRTdG9wTWVzc2FnZSh7IHF1aWV0OiAoX2EgPSBjb250ZXh0LnN0YXJ0T3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnF1aWV0IH0pO1xuICB9O1xufTtcblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L3V0aWxzL3ByZXBhcmVTdGFydEhhbmRsZXIudHNcbnZhciBERUZBVUxUX1NUQVJUX09QVElPTlMgPSB7XG4gIHNlcnZpY2VXb3JrZXI6IHtcbiAgICB1cmw6IFwiL21vY2tTZXJ2aWNlV29ya2VyLmpzXCIsXG4gICAgb3B0aW9uczogbnVsbFxuICB9LFxuICBxdWlldDogZmFsc2UsXG4gIHdhaXRVbnRpbFJlYWR5OiB0cnVlLFxuICBvblVuaGFuZGxlZFJlcXVlc3Q6IFwid2FyblwiLFxuICBmaW5kV29ya2VyKHNjcmlwdFVSTCwgbW9ja1NlcnZpY2VXb3JrZXJVcmwpIHtcbiAgICByZXR1cm4gc2NyaXB0VVJMID09PSBtb2NrU2VydmljZVdvcmtlclVybDtcbiAgfVxufTtcblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L2NyZWF0ZUZhbGxiYWNrUmVxdWVzdExpc3RlbmVyLnRzXG52YXIgaW1wb3J0X2ludGVyY2VwdG9yczMgPSByZXF1aXJlKFwiQG1zd2pzL2ludGVyY2VwdG9yc1wiKTtcbnZhciBpbXBvcnRfZmV0Y2gzID0gcmVxdWlyZShcIkBtc3dqcy9pbnRlcmNlcHRvcnMvbGliL2ludGVyY2VwdG9ycy9mZXRjaFwiKTtcbnZhciBpbXBvcnRfWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKFwiQG1zd2pzL2ludGVyY2VwdG9ycy9saWIvaW50ZXJjZXB0b3JzL1hNTEh0dHBSZXF1ZXN0XCIpO1xuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9jcmVhdGVSZXNwb25zZUZyb21Jc29tb3JwaGljUmVzcG9uc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlRnJvbUlzb21vcnBoaWNSZXNwb25zZShyZXNwb25zZTIpIHtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShyZXNwb25zZTIuYm9keSwge1xuICAgIHN0YXR1czogcmVzcG9uc2UyLnN0YXR1cyxcbiAgICBzdGF0dXNUZXh0OiByZXNwb25zZTIuc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiByZXNwb25zZTIuaGVhZGVyc1xuICB9KTtcbn1cblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L2NyZWF0ZUZhbGxiYWNrUmVxdWVzdExpc3RlbmVyLnRzXG5mdW5jdGlvbiBjcmVhdGVGYWxsYmFja1JlcXVlc3RMaXN0ZW5lcihjb250ZXh0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGludGVyY2VwdG9yID0gbmV3IGltcG9ydF9pbnRlcmNlcHRvcnMzLkJhdGNoSW50ZXJjZXB0b3Ioe1xuICAgIG5hbWU6IFwiZmFsbGJhY2tcIixcbiAgICBpbnRlcmNlcHRvcnM6IFtuZXcgaW1wb3J0X2ZldGNoMy5GZXRjaEludGVyY2VwdG9yKCksIG5ldyBpbXBvcnRfWE1MSHR0cFJlcXVlc3QuWE1MSHR0cFJlcXVlc3RJbnRlcmNlcHRvcigpXVxuICB9KTtcbiAgaW50ZXJjZXB0b3Iub24oXCJyZXF1ZXN0XCIsIGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgY29uc3QgbW9ja2VkUmVxdWVzdCA9IG5ldyBNb2NrZWRSZXF1ZXN0KHJlcXVlc3QudXJsLCB7XG4gICAgICAuLi5yZXF1ZXN0LFxuICAgICAgYm9keTogYXdhaXQgcmVxdWVzdC5hcnJheUJ1ZmZlcigpXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UyID0gYXdhaXQgaGFuZGxlUmVxdWVzdChcbiAgICAgIG1vY2tlZFJlcXVlc3QsXG4gICAgICBjb250ZXh0LnJlcXVlc3RIYW5kbGVycyxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBjb250ZXh0LmVtaXR0ZXIsXG4gICAgICB7XG4gICAgICAgIHRyYW5zZm9ybVJlc3BvbnNlKHJlc3BvbnNlMykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlMy5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZTMuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlMy5oZWFkZXJzLmFsbCgpLFxuICAgICAgICAgICAgYm9keTogcmVzcG9uc2UzLmJvZHksXG4gICAgICAgICAgICBkZWxheTogcmVzcG9uc2UzLmRlbGF5XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb2NrZWRSZXNwb25zZShfLCB7IGhhbmRsZXIsIHB1YmxpY1JlcXVlc3QsIHBhcnNlZFJlcXVlc3QgfSkge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5xdWlldCkge1xuICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLm9uY2UoXCJyZXNwb25zZTptb2NrZWRcIiwgYXN5bmMgKHJlc3BvbnNlMykgPT4ge1xuICAgICAgICAgICAgICBoYW5kbGVyLmxvZyhcbiAgICAgICAgICAgICAgICBwdWJsaWNSZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGF3YWl0IHNlcmlhbGl6ZVJlc3BvbnNlKHJlc3BvbnNlMyksXG4gICAgICAgICAgICAgICAgcGFyc2VkUmVxdWVzdFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAocmVzcG9uc2UyKSB7XG4gICAgICByZXF1ZXN0LnJlc3BvbmRXaXRoKHJlc3BvbnNlMik7XG4gICAgfVxuICB9KTtcbiAgaW50ZXJjZXB0b3Iub24oXCJyZXNwb25zZVwiLCAocmVxdWVzdCwgcmVzcG9uc2UyKSA9PiB7XG4gICAgaWYgKCFyZXF1ZXN0LmlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJyb3dzZXJSZXNwb25zZSA9IGNyZWF0ZVJlc3BvbnNlRnJvbUlzb21vcnBoaWNSZXNwb25zZShyZXNwb25zZTIpO1xuICAgIGlmIChyZXNwb25zZTIuaGVhZGVycy5nZXQoXCJ4LXBvd2VyZWQtYnlcIikgPT09IFwibXN3XCIpIHtcbiAgICAgIGNvbnRleHQuZW1pdHRlci5lbWl0KFwicmVzcG9uc2U6bW9ja2VkXCIsIGJyb3dzZXJSZXNwb25zZSwgcmVxdWVzdC5pZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuZW1pdHRlci5lbWl0KFwicmVzcG9uc2U6YnlwYXNzXCIsIGJyb3dzZXJSZXNwb25zZSwgcmVxdWVzdC5pZCk7XG4gICAgfVxuICB9KTtcbiAgaW50ZXJjZXB0b3IuYXBwbHkoKTtcbiAgcmV0dXJuIGludGVyY2VwdG9yO1xufVxuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvY3JlYXRlRmFsbGJhY2tTdGFydC50c1xuZnVuY3Rpb24gY3JlYXRlRmFsbGJhY2tTdGFydChjb250ZXh0KSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBzdGFydChvcHRpb25zKSB7XG4gICAgY29udGV4dC5mYWxsYmFja0ludGVyY2VwdG9yID0gY3JlYXRlRmFsbGJhY2tSZXF1ZXN0TGlzdGVuZXIoXG4gICAgICBjb250ZXh0LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgcHJpbnRTdGFydE1lc3NhZ2Uoe1xuICAgICAgbWVzc2FnZTogXCJNb2NraW5nIGVuYWJsZWQgKGZhbGxiYWNrIG1vZGUpLlwiLFxuICAgICAgcXVpZXQ6IG9wdGlvbnMucXVpZXRcbiAgICB9KTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9O1xufVxuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RvcC9jcmVhdGVGYWxsYmFja1N0b3AudHNcbmZ1bmN0aW9uIGNyZWF0ZUZhbGxiYWNrU3RvcChjb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgKF9hID0gY29udGV4dC5mYWxsYmFja0ludGVyY2VwdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xuICAgIHByaW50U3RvcE1lc3NhZ2UoeyBxdWlldDogKF9iID0gY29udGV4dC5zdGFydE9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5xdWlldCB9KTtcbiAgfTtcbn1cblxuLy8gc3JjL1NldHVwQXBpLnRzXG52YXIgaW1wb3J0X291dHZhcmlhbnQ0ID0gcmVxdWlyZShcIm91dHZhcmlhbnRcIik7XG52YXIgaW1wb3J0X3N0cmljdF9ldmVudF9lbWl0dGVyID0gcmVxdWlyZShcInN0cmljdC1ldmVudC1lbWl0dGVyXCIpO1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvcGlwZUV2ZW50cy50c1xuZnVuY3Rpb24gcGlwZUV2ZW50cyhzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIGNvbnN0IHJhd0VtaXQgPSBzb3VyY2UuZW1pdDtcbiAgaWYgKHJhd0VtaXQuX2lzUGlwZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc291cmNlLmVtaXQgPSBmdW5jdGlvbihldmVudCwgLi4uZGF0YTIpIHtcbiAgICBkZXN0aW5hdGlvbi5lbWl0KGV2ZW50LCAuLi5kYXRhMik7XG4gICAgcmV0dXJuIHJhd0VtaXQuY2FsbCh0aGlzLCBldmVudCwgLi4uZGF0YTIpO1xuICB9O1xuICBzb3VyY2UuZW1pdC5faXNQaXBlZCA9IHRydWU7XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC90b1JlYWRvbmx5QXJyYXkudHNcbmZ1bmN0aW9uIHRvUmVhZG9ubHlBcnJheShzb3VyY2UpIHtcbiAgY29uc3QgY2xvbmUgPSBbLi4uc291cmNlXTtcbiAgT2JqZWN0LmZyZWV6ZShjbG9uZSk7XG4gIHJldHVybiBjbG9uZTtcbn1cblxuLy8gc3JjL1NldHVwQXBpLnRzXG52YXIgU2V0dXBBcGkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKC4uLmluaXRpYWxIYW5kbGVycykge1xuICAgIHRoaXMudmFsaWRhdGVIYW5kbGVycyguLi5pbml0aWFsSGFuZGxlcnMpO1xuICAgIHRoaXMuaW5pdGlhbEhhbmRsZXJzID0gdG9SZWFkb25seUFycmF5KGluaXRpYWxIYW5kbGVycyk7XG4gICAgdGhpcy5jdXJyZW50SGFuZGxlcnMgPSBbLi4uaW5pdGlhbEhhbmRsZXJzXTtcbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgaW1wb3J0X3N0cmljdF9ldmVudF9lbWl0dGVyLkVtaXR0ZXIoKTtcbiAgICB0aGlzLnB1YmxpY0VtaXR0ZXIgPSBuZXcgaW1wb3J0X3N0cmljdF9ldmVudF9lbWl0dGVyLkVtaXR0ZXIoKTtcbiAgICBwaXBlRXZlbnRzKHRoaXMuZW1pdHRlciwgdGhpcy5wdWJsaWNFbWl0dGVyKTtcbiAgICB0aGlzLmV2ZW50cyA9IHRoaXMuY3JlYXRlTGlmZUN5Y2xlRXZlbnRzKCk7XG4gIH1cbiAgdmFsaWRhdGVIYW5kbGVycyguLi5oYW5kbGVycykge1xuICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgKDAsIGltcG9ydF9vdXR2YXJpYW50NC5pbnZhcmlhbnQpKFxuICAgICAgICAhQXJyYXkuaXNBcnJheShoYW5kbGVyKSxcbiAgICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICAnRmFpbGVkIHRvIGNvbnN0cnVjdCBcIiVzXCIgZ2l2ZW4gYW4gQXJyYXkgb2YgcmVxdWVzdCBoYW5kbGVycy4gTWFrZSBzdXJlIHlvdSBzcHJlYWQgdGhlIHJlcXVlc3QgaGFuZGxlcnMgd2hlbiBjYWxsaW5nIHRoZSByZXNwZWN0aXZlIHNldHVwIGZ1bmN0aW9uLidcbiAgICAgICAgKSxcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnB1YmxpY0VtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbiAgdXNlKC4uLnJ1bnRpbWVIYW5kbGVycykge1xuICAgIHRoaXMuY3VycmVudEhhbmRsZXJzLnVuc2hpZnQoLi4ucnVudGltZUhhbmRsZXJzKTtcbiAgfVxuICByZXN0b3JlSGFuZGxlcnMoKSB7XG4gICAgdGhpcy5jdXJyZW50SGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgaGFuZGxlci5tYXJrQXNTa2lwcGVkKGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuICByZXNldEhhbmRsZXJzKC4uLm5leHRIYW5kbGVycykge1xuICAgIHRoaXMuY3VycmVudEhhbmRsZXJzID0gbmV4dEhhbmRsZXJzLmxlbmd0aCA+IDAgPyBbLi4ubmV4dEhhbmRsZXJzXSA6IFsuLi50aGlzLmluaXRpYWxIYW5kbGVyc107XG4gIH1cbiAgbGlzdEhhbmRsZXJzKCkge1xuICAgIHJldHVybiB0b1JlYWRvbmx5QXJyYXkodGhpcy5jdXJyZW50SGFuZGxlcnMpO1xuICB9XG4gIGNyZWF0ZUxpZmVDeWNsZUV2ZW50cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb246ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY0VtaXR0ZXIub24oLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlTGlzdGVuZXI6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY0VtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiAoLi4uYXJncykgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyguLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc2V0dXBXb3JrZXIudHNcbnZhciBTZXR1cFdvcmtlckFwaSA9IGNsYXNzIGV4dGVuZHMgU2V0dXBBcGkge1xuICBjb25zdHJ1Y3RvciguLi5oYW5kbGVycykge1xuICAgIHN1cGVyKC4uLmhhbmRsZXJzKTtcbiAgICB0aGlzLnN0YXJ0SGFuZGxlciA9IG51bGw7XG4gICAgdGhpcy5zdG9wSGFuZGxlciA9IG51bGw7XG4gICAgKDAsIGltcG9ydF9vdXR2YXJpYW50NS5pbnZhcmlhbnQpKFxuICAgICAgISgwLCBpbXBvcnRfaXNfbm9kZV9wcm9jZXNzMy5pc05vZGVQcm9jZXNzKSgpLFxuICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgXCJGYWlsZWQgdG8gZXhlY3V0ZSBgc2V0dXBXb3JrZXJgIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQuIENvbnNpZGVyIHVzaW5nIGBzZXR1cFNlcnZlcmAgZm9yIE5vZGUuanMgZW52aXJvbm1lbnQgaW5zdGVhZC5cIlxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNyZWF0ZVdvcmtlckNvbnRleHQoKTtcbiAgfVxuICBjcmVhdGVXb3JrZXJDb250ZXh0KCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBpc01vY2tpbmdFbmFibGVkOiBmYWxzZSxcbiAgICAgIHN0YXJ0T3B0aW9uczogbnVsbCxcbiAgICAgIHdvcmtlcjogbnVsbCxcbiAgICAgIHJlZ2lzdHJhdGlvbjogbnVsbCxcbiAgICAgIHJlcXVlc3RIYW5kbGVyczogdGhpcy5jdXJyZW50SGFuZGxlcnMsXG4gICAgICBlbWl0dGVyOiB0aGlzLmVtaXR0ZXIsXG4gICAgICB3b3JrZXJDaGFubmVsOiB7XG4gICAgICAgIG9uOiAoZXZlbnRUeXBlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgIHRoaXMuY29udGV4dC5ldmVudHMuYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlcixcbiAgICAgICAgICAgIFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgIT09IHRoaXMuY29udGV4dC53b3JrZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSBldmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhldmVudCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBzZW5kOiAodHlwZSkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAoX2EgPSB0aGlzLmNvbnRleHQud29ya2VyKSA9PSBudWxsID8gdm9pZCAwIDogX2EucG9zdE1lc3NhZ2UodHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgYWRkTGlzdGVuZXI6ICh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKHsgZXZlbnRUeXBlLCB0YXJnZXQsIGNhbGxiYWNrIH0pO1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVBbGxMaXN0ZW5lcnM6ICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHsgdGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrIH0gb2YgdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB9LFxuICAgICAgICBvbmNlOiAoZXZlbnRUeXBlKSA9PiB7XG4gICAgICAgICAgY29uc3QgYmluZGluZ3MgPSBbXTtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlSW5jb21pbmdNZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBiaW5kaW5ncy5wdXNoKFxuICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZXZlbnRzLmFkZExpc3RlbmVyKFxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLFxuICAgICAgICAgICAgICAgIFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgIGhhbmRsZUluY29taW5nTWVzc2FnZVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZXZlbnRzLmFkZExpc3RlbmVyKFxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLFxuICAgICAgICAgICAgICAgIFwibWVzc2FnZWVycm9yXCIsXG4gICAgICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICBiaW5kaW5ncy5mb3JFYWNoKCh1bmJpbmQpID0+IHVuYmluZCgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZUZhbGxiYWNrTW9kZTogIShcInNlcnZpY2VXb3JrZXJcIiBpbiBuYXZpZ2F0b3IpIHx8IGxvY2F0aW9uLnByb3RvY29sID09PSBcImZpbGU6XCJcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnRleHQsIHtcbiAgICAgIHJlcXVlc3RIYW5kbGVyczoge1xuICAgICAgICBnZXQ6ICgpID0+IHRoaXMuY3VycmVudEhhbmRsZXJzXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zdGFydEhhbmRsZXIgPSBjb250ZXh0LnVzZUZhbGxiYWNrTW9kZSA/IGNyZWF0ZUZhbGxiYWNrU3RhcnQoY29udGV4dCkgOiBjcmVhdGVTdGFydEhhbmRsZXIoY29udGV4dCk7XG4gICAgdGhpcy5zdG9wSGFuZGxlciA9IGNvbnRleHQudXNlRmFsbGJhY2tNb2RlID8gY3JlYXRlRmFsbGJhY2tTdG9wKGNvbnRleHQpIDogY3JlYXRlU3RvcChjb250ZXh0KTtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuICBhc3luYyBzdGFydChvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmNvbnRleHQuc3RhcnRPcHRpb25zID0gbWVyZ2VSaWdodChcbiAgICAgIERFRkFVTFRfU1RBUlRfT1BUSU9OUyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnN0YXJ0SGFuZGxlcih0aGlzLmNvbnRleHQuc3RhcnRPcHRpb25zLCBvcHRpb25zKTtcbiAgfVxuICBwcmludEhhbmRsZXJzKCkge1xuICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5saXN0SGFuZGxlcnMoKTtcbiAgICBoYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICBjb25zdCB7IGhlYWRlciwgY2FsbEZyYW1lIH0gPSBoYW5kbGVyLmluZm87XG4gICAgICBjb25zdCBwcmFnbWEgPSBoYW5kbGVyLmluZm8uaGFzT3duUHJvcGVydHkoXCJvcGVyYXRpb25UeXBlXCIpID8gXCJbZ3JhcGhxbF1cIiA6IFwiW3Jlc3RdXCI7XG4gICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKGAke3ByYWdtYX0gJHtoZWFkZXJ9YCk7XG4gICAgICBpZiAoY2FsbEZyYW1lKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBEZWNsYXJhdGlvbjogJHtjYWxsRnJhbWV9YCk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhcIkhhbmRsZXI6XCIsIGhhbmRsZXIpO1xuICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH0pO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuY29udGV4dC5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5jb250ZXh0LmVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5zdG9wSGFuZGxlcigpO1xuICB9XG59O1xuZnVuY3Rpb24gc2V0dXBXb3JrZXIoLi4uaGFuZGxlcnMpIHtcbiAgcmV0dXJuIG5ldyBTZXR1cFdvcmtlckFwaSguLi5oYW5kbGVycyk7XG59XG5cbi8vIHNyYy9yZXN0LnRzXG5mdW5jdGlvbiBjcmVhdGVSZXN0SGFuZGxlcihtZXRob2QpIHtcbiAgcmV0dXJuIChwYXRoLCByZXNvbHZlcikgPT4ge1xuICAgIHJldHVybiBuZXcgUmVzdEhhbmRsZXIobWV0aG9kLCBwYXRoLCByZXNvbHZlcik7XG4gIH07XG59XG52YXIgcmVzdCA9IHtcbiAgYWxsOiBjcmVhdGVSZXN0SGFuZGxlcigvLisvKSxcbiAgaGVhZDogY3JlYXRlUmVzdEhhbmRsZXIoXCJIRUFEXCIgLyogSEVBRCAqLyksXG4gIGdldDogY3JlYXRlUmVzdEhhbmRsZXIoXCJHRVRcIiAvKiBHRVQgKi8pLFxuICBwb3N0OiBjcmVhdGVSZXN0SGFuZGxlcihcIlBPU1RcIiAvKiBQT1NUICovKSxcbiAgcHV0OiBjcmVhdGVSZXN0SGFuZGxlcihcIlBVVFwiIC8qIFBVVCAqLyksXG4gIGRlbGV0ZTogY3JlYXRlUmVzdEhhbmRsZXIoXCJERUxFVEVcIiAvKiBERUxFVEUgKi8pLFxuICBwYXRjaDogY3JlYXRlUmVzdEhhbmRsZXIoXCJQQVRDSFwiIC8qIFBBVENIICovKSxcbiAgb3B0aW9uczogY3JlYXRlUmVzdEhhbmRsZXIoXCJPUFRJT05TXCIgLyogT1BUSU9OUyAqLylcbn07XG5cbi8vIHNyYy9ncmFwaHFsLnRzXG5mdW5jdGlvbiBjcmVhdGVTY29wZWRHcmFwaFFMSGFuZGxlcihvcGVyYXRpb25UeXBlLCB1cmwpIHtcbiAgcmV0dXJuIChvcGVyYXRpb25OYW1lLCByZXNvbHZlcikgPT4ge1xuICAgIHJldHVybiBuZXcgR3JhcGhRTEhhbmRsZXIoXG4gICAgICBvcGVyYXRpb25UeXBlLFxuICAgICAgb3BlcmF0aW9uTmFtZSxcbiAgICAgIHVybCxcbiAgICAgIHJlc29sdmVyXG4gICAgKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdyYXBoUUxPcGVyYXRpb25IYW5kbGVyKHVybCkge1xuICByZXR1cm4gKHJlc29sdmVyKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBHcmFwaFFMSGFuZGxlcihcbiAgICAgIFwiYWxsXCIsXG4gICAgICBuZXcgUmVnRXhwKFwiLipcIiksXG4gICAgICB1cmwsXG4gICAgICByZXNvbHZlclxuICAgICk7XG4gIH07XG59XG52YXIgc3RhbmRhcmRHcmFwaFFMSGFuZGxlcnMgPSB7XG4gIG9wZXJhdGlvbjogY3JlYXRlR3JhcGhRTE9wZXJhdGlvbkhhbmRsZXIoXCIqXCIpLFxuICBxdWVyeTogY3JlYXRlU2NvcGVkR3JhcGhRTEhhbmRsZXIoXCJxdWVyeVwiLCBcIipcIiksXG4gIG11dGF0aW9uOiBjcmVhdGVTY29wZWRHcmFwaFFMSGFuZGxlcihcIm11dGF0aW9uXCIsIFwiKlwiKVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUdyYXBoUUxMaW5rKHVybCkge1xuICByZXR1cm4ge1xuICAgIG9wZXJhdGlvbjogY3JlYXRlR3JhcGhRTE9wZXJhdGlvbkhhbmRsZXIodXJsKSxcbiAgICBxdWVyeTogY3JlYXRlU2NvcGVkR3JhcGhRTEhhbmRsZXIoXCJxdWVyeVwiLCB1cmwpLFxuICAgIG11dGF0aW9uOiBjcmVhdGVTY29wZWRHcmFwaFFMSGFuZGxlcihcIm11dGF0aW9uXCIsIHVybClcbiAgfTtcbn1cbnZhciBncmFwaHFsID0ge1xuICAuLi5zdGFuZGFyZEdyYXBoUUxIYW5kbGVycyxcbiAgbGluazogY3JlYXRlR3JhcGhRTExpbmtcbn07XG5cbi8vIHNyYy9pbmRleC50c1xuY2hlY2tHbG9iYWxzKCk7XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgR3JhcGhRTEhhbmRsZXIsXG4gIE1vY2tlZFJlcXVlc3QsXG4gIFJFU1RNZXRob2RzLFxuICBSZXF1ZXN0SGFuZGxlcixcbiAgUmVzdEhhbmRsZXIsXG4gIFNldHVwQXBpLFxuICBTZXR1cFdvcmtlckFwaSxcbiAgY2xlYW5VcmwsXG4gIGNvbXBvc2UsXG4gIGNvbnRleHQsXG4gIGNyZWF0ZVJlc3BvbnNlQ29tcG9zaXRpb24sXG4gIGRlZmF1bHRDb250ZXh0LFxuICBkZWZhdWx0UmVzcG9uc2UsXG4gIGdyYXBocWwsXG4gIGdyYXBocWxDb250ZXh0LFxuICBoYW5kbGVSZXF1ZXN0LFxuICBtYXRjaFJlcXVlc3RVcmwsXG4gIHJlc3BvbnNlLFxuICByZXN0LFxuICByZXN0Q29udGV4dCxcbiAgc2V0dXBXb3JrZXJcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/msw/lib/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/msw/node_modules/path-to-regexp/dist.es2015/index.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/msw/node_modules/path-to-regexp/dist.es2015/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compile: () => (/* binding */ compile),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   pathToRegexp: () => (/* binding */ pathToRegexp),\n/* harmony export */   regexpToFunction: () => (/* binding */ regexpToFunction),\n/* harmony export */   tokensToFunction: () => (/* binding */ tokensToFunction),\n/* harmony export */   tokensToRegexp: () => (/* binding */ tokensToRegexp)\n/* harmony export */ });\n/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \".concat(i));\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \".concat(j));\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \".concat(j));\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \".concat(i));\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \".concat(i));\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\".concat(escapeString(options.delimiter || \"/#?\"), \"]+?\");\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \".concat(nextType, \" at \").concat(index, \", expected \").concat(type));\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\".concat(token.pattern, \")$\"), reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not repeat, but got an array\"));\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not be empty\"));\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to be \").concat(typeOfMessage));\n        }\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nfunction regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    var groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n    var index = 0;\n    var execResult = groupsRegex.exec(path.source);\n    while (execResult) {\n        keys.push({\n            // Use parenthesized substring match if available, index otherwise\n            name: execResult[1] || index++,\n            prefix: \"\",\n            suffix: \"\",\n            modifier: \"\",\n            pattern: \"\",\n        });\n        execResult = groupsRegex.exec(path.source);\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\".concat(parts.join(\"|\"), \")\"), flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d, _e = options.delimiter, delimiter = _e === void 0 ? \"/#?\" : _e, _f = options.endsWith, endsWith = _f === void 0 ? \"\" : _f;\n    var endsWithRe = \"[\".concat(escapeString(endsWith), \"]|$\");\n    var delimiterRe = \"[\".concat(escapeString(delimiter), \"]\");\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\".concat(prefix, \"((?:\").concat(token.pattern, \")(?:\").concat(suffix).concat(prefix, \"(?:\").concat(token.pattern, \"))*)\").concat(suffix, \")\").concat(mod);\n                    }\n                    else {\n                        route += \"(?:\".concat(prefix, \"(\").concat(token.pattern, \")\").concat(suffix, \")\").concat(token.modifier);\n                    }\n                }\n                else {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        route += \"((?:\".concat(token.pattern, \")\").concat(token.modifier, \")\");\n                    }\n                    else {\n                        route += \"(\".concat(token.pattern, \")\").concat(token.modifier);\n                    }\n                }\n            }\n            else {\n                route += \"(?:\".concat(prefix).concat(suffix, \")\").concat(token.modifier);\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += \"\".concat(delimiterRe, \"?\");\n        route += !options.endsWith ? \"$\" : \"(?=\".concat(endsWithRe, \")\");\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n            : endToken === undefined;\n        if (!strict) {\n            route += \"(?:\".concat(delimiterRe, \"(?=\").concat(endsWithRe, \"))?\");\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\".concat(delimiterRe, \"|\").concat(endsWithRe, \")\");\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nfunction pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL21zdy9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvZGlzdC5lczIwMTUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBNkM7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1EQUFtRDtBQUM3RTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDBCQUEwQix5Q0FBeUM7QUFDbkU7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiwwQkFBMEIsMENBQTBDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUNBQXFDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJDQUEyQztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUNBQXlDO0FBQy9EO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsOEJBQThCO0FBQzlCO0FBQ0EscUVBQXFFLFlBQVk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw4QkFBOEI7QUFDOUIscUVBQXFFLFlBQVk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGtEQUFrRDtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw4QkFBOEI7QUFDOUIseU9BQXlPLFlBQVk7QUFDclA7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNERBQTREO0FBQzNFO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvbXN3L25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9kaXN0LmVzMjAxNS9pbmRleC5qcz9hYTJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVG9rZW5pemUgaW5wdXQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBsZXhlcihzdHIpIHtcbiAgICB2YXIgdG9rZW5zID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICB2YXIgY2hhciA9IHN0cltpXTtcbiAgICAgICAgaWYgKGNoYXIgPT09IFwiKlwiIHx8IGNoYXIgPT09IFwiK1wiIHx8IGNoYXIgPT09IFwiP1wiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiTU9ESUZJRVJcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkVTQ0FQRURfQ0hBUlwiLCBpbmRleDogaSsrLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJPUEVOXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJDTE9TRVwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwiOlwiKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgaiA9IGkgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChqKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gYDAtOWBcbiAgICAgICAgICAgICAgICAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBgQS1aYFxuICAgICAgICAgICAgICAgICAgICAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBgYS16YFxuICAgICAgICAgICAgICAgICAgICAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEyMikgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYF9gXG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPT09IDk1KSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgKz0gc3RyW2orK107XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyBwYXJhbWV0ZXIgbmFtZSBhdCBcIi5jb25jYXQoaSkpO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk5BTUVcIiwgaW5kZXg6IGksIHZhbHVlOiBuYW1lIH0pO1xuICAgICAgICAgICAgaSA9IGo7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDE7XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgaiA9IGkgKyAxO1xuICAgICAgICAgICAgaWYgKHN0cltqXSA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0dGVybiBjYW5ub3Qgc3RhcnQgd2l0aCBcXFwiP1xcXCIgYXQgXCIuY29uY2F0KGopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChqIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJbal0gPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gc3RyW2orK10gKyBzdHJbaisrXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHJbal0gPT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyW2pdID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyW2ogKyAxXSAhPT0gXCI/XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYXB0dXJpbmcgZ3JvdXBzIGFyZSBub3QgYWxsb3dlZCBhdCBcIi5jb25jYXQoaikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gc3RyW2orK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuYmFsYW5jZWQgcGF0dGVybiBhdCBcIi5jb25jYXQoaSkpO1xuICAgICAgICAgICAgaWYgKCFwYXR0ZXJuKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNaXNzaW5nIHBhdHRlcm4gYXQgXCIuY29uY2F0KGkpKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJQQVRURVJOXCIsIGluZGV4OiBpLCB2YWx1ZTogcGF0dGVybiB9KTtcbiAgICAgICAgICAgIGkgPSBqO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkNIQVJcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICB9XG4gICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkVORFwiLCBpbmRleDogaSwgdmFsdWU6IFwiXCIgfSk7XG4gICAgcmV0dXJuIHRva2Vucztcbn1cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2Uoc3RyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgdG9rZW5zID0gbGV4ZXIoc3RyKTtcbiAgICB2YXIgX2EgPSBvcHRpb25zLnByZWZpeGVzLCBwcmVmaXhlcyA9IF9hID09PSB2b2lkIDAgPyBcIi4vXCIgOiBfYTtcbiAgICB2YXIgZGVmYXVsdFBhdHRlcm4gPSBcIlteXCIuY29uY2F0KGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCBcIi8jP1wiKSwgXCJdKz9cIik7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBrZXkgPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcGF0aCA9IFwiXCI7XG4gICAgdmFyIHRyeUNvbnN1bWUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAoaSA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2ldLnR5cGUgPT09IHR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zW2krK10udmFsdWU7XG4gICAgfTtcbiAgICB2YXIgbXVzdENvbnN1bWUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0cnlDb25zdW1lKHR5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFyIF9hID0gdG9rZW5zW2ldLCBuZXh0VHlwZSA9IF9hLnR5cGUsIGluZGV4ID0gX2EuaW5kZXg7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIFwiLmNvbmNhdChuZXh0VHlwZSwgXCIgYXQgXCIpLmNvbmNhdChpbmRleCwgXCIsIGV4cGVjdGVkIFwiKS5jb25jYXQodHlwZSkpO1xuICAgIH07XG4gICAgdmFyIGNvbnN1bWVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICB3aGlsZSAoKHZhbHVlID0gdHJ5Q29uc3VtZShcIkNIQVJcIikgfHwgdHJ5Q29uc3VtZShcIkVTQ0FQRURfQ0hBUlwiKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgd2hpbGUgKGkgPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGFyID0gdHJ5Q29uc3VtZShcIkNIQVJcIik7XG4gICAgICAgIHZhciBuYW1lID0gdHJ5Q29uc3VtZShcIk5BTUVcIik7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gdHJ5Q29uc3VtZShcIlBBVFRFUk5cIik7XG4gICAgICAgIGlmIChuYW1lIHx8IHBhdHRlcm4pIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBjaGFyIHx8IFwiXCI7XG4gICAgICAgICAgICBpZiAocHJlZml4ZXMuaW5kZXhPZihwcmVmaXgpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHBhdGggKz0gcHJlZml4O1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgICAgIHBhdGggPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4gfHwgZGVmYXVsdFBhdHRlcm4sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IHRyeUNvbnN1bWUoXCJNT0RJRklFUlwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBjaGFyIHx8IHRyeUNvbnN1bWUoXCJFU0NBUEVEX0NIQVJcIik7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcGF0aCArPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXRoKTtcbiAgICAgICAgICAgIHBhdGggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVuID0gdHJ5Q29uc3VtZShcIk9QRU5cIik7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0cnlDb25zdW1lKFwiTkFNRVwiKSB8fCBcIlwiO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm5fMSA9IHRyeUNvbnN1bWUoXCJQQVRURVJOXCIpIHx8IFwiXCI7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgIG11c3RDb25zdW1lKFwiQ0xPU0VcIik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZV8xIHx8IChwYXR0ZXJuXzEgPyBrZXkrKyA6IFwiXCIpLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IG5hbWVfMSAmJiAhcGF0dGVybl8xID8gZGVmYXVsdFBhdHRlcm4gOiBwYXR0ZXJuXzEsXG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBzdWZmaXgsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IHRyeUNvbnN1bWUoXCJNT0RJRklFUlwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtdXN0Q29uc3VtZShcIkVORFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGUoc3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbih0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciByZUZsYWdzID0gZmxhZ3Mob3B0aW9ucyk7XG4gICAgdmFyIF9hID0gb3B0aW9ucy5lbmNvZGUsIGVuY29kZSA9IF9hID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9hLCBfYiA9IG9wdGlvbnMudmFsaWRhdGUsIHZhbGlkYXRlID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYjtcbiAgICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgICB2YXIgbWF0Y2hlcyA9IHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiLmNvbmNhdCh0b2tlbi5wYXR0ZXJuLCBcIikkXCIpLCByZUZsYWdzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcGF0aCA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGEgPyBkYXRhW3Rva2VuLm5hbWVdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIG9wdGlvbmFsID0gdG9rZW4ubW9kaWZpZXIgPT09IFwiP1wiIHx8IHRva2VuLm1vZGlmaWVyID09PSBcIipcIjtcbiAgICAgICAgICAgIHZhciByZXBlYXQgPSB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCIgfHwgdG9rZW4ubW9kaWZpZXIgPT09IFwiK1wiO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXBlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFxcXCJcIi5jb25jYXQodG9rZW4ubmFtZSwgXCJcXFwiIHRvIG5vdCByZXBlYXQsIGJ1dCBnb3QgYW4gYXJyYXlcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiLmNvbmNhdCh0b2tlbi5uYW1lLCBcIlxcXCIgdG8gbm90IGJlIGVtcHR5XCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGUgJiYgIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGFsbCBcXFwiXCIuY29uY2F0KHRva2VuLm5hbWUsIFwiXFxcIiB0byBtYXRjaCBcXFwiXCIpLmNvbmNhdCh0b2tlbi5wYXR0ZXJuLCBcIlxcXCIsIGJ1dCBnb3QgXFxcIlwiKS5jb25jYXQoc2VnbWVudCwgXCJcXFwiXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnQgKyB0b2tlbi5zdWZmaXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IGVuY29kZShTdHJpbmcodmFsdWUpLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlICYmICFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFxcXCJcIi5jb25jYXQodG9rZW4ubmFtZSwgXCJcXFwiIHRvIG1hdGNoIFxcXCJcIikuY29uY2F0KHRva2VuLnBhdHRlcm4sIFwiXFxcIiwgYnV0IGdvdCBcXFwiXCIpLmNvbmNhdChzZWdtZW50LCBcIlxcXCJcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnQgKyB0b2tlbi5zdWZmaXg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdHlwZU9mTWVzc2FnZSA9IHJlcGVhdCA/IFwiYW4gYXJyYXlcIiA6IFwiYSBzdHJpbmdcIjtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIuY29uY2F0KHRva2VuLm5hbWUsIFwiXFxcIiB0byBiZSBcIikuY29uY2F0KHR5cGVPZk1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgcGF0aCBtYXRjaCBmdW5jdGlvbiBmcm9tIGBwYXRoLXRvLXJlZ2V4cGAgc3BlYy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoKHN0ciwgb3B0aW9ucykge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgdmFyIHJlID0gcGF0aFRvUmVnZXhwKHN0ciwga2V5cywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlZ2V4cFRvRnVuY3Rpb24ocmUsIGtleXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIG1hdGNoIGZ1bmN0aW9uIGZyb20gYHBhdGgtdG8tcmVnZXhwYCBvdXRwdXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdleHBUb0Z1bmN0aW9uKHJlLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgX2EgPSBvcHRpb25zLmRlY29kZSwgZGVjb2RlID0gX2EgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9IDogX2E7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgICAgICB2YXIgbSA9IHJlLmV4ZWMocGF0aG5hbWUpO1xuICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBwYXRoID0gbVswXSwgaW5kZXggPSBtLmluZGV4O1xuICAgICAgICB2YXIgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgaWYgKG1baV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaSAtIDFdO1xuICAgICAgICAgICAgaWYgKGtleS5tb2RpZmllciA9PT0gXCIqXCIgfHwga2V5Lm1vZGlmaWVyID09PSBcIitcIikge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trZXkubmFtZV0gPSBtW2ldLnNwbGl0KGtleS5wcmVmaXggKyBrZXkuc3VmZml4KS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGUodmFsdWUsIGtleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gZGVjb2RlKG1baV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwYXRoOiBwYXRoLCBpbmRleDogaW5kZXgsIHBhcmFtczogcGFyYW1zIH07XG4gICAgfTtcbn1cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXwvXFxcXF0pL2csIFwiXFxcXCQxXCIpO1xufVxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBmbGFncyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5zZW5zaXRpdmUgPyBcIlwiIDogXCJpXCI7XG59XG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAocGF0aCwga2V5cykge1xuICAgIGlmICgha2V5cylcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgdmFyIGdyb3Vwc1JlZ2V4ID0gL1xcKCg/OlxcPzwoLio/KT4pPyg/IVxcPykvZztcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBleGVjUmVzdWx0ID0gZ3JvdXBzUmVnZXguZXhlYyhwYXRoLnNvdXJjZSk7XG4gICAgd2hpbGUgKGV4ZWNSZXN1bHQpIHtcbiAgICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgICAgIC8vIFVzZSBwYXJlbnRoZXNpemVkIHN1YnN0cmluZyBtYXRjaCBpZiBhdmFpbGFibGUsIGluZGV4IG90aGVyd2lzZVxuICAgICAgICAgICAgbmFtZTogZXhlY1Jlc3VsdFsxXSB8fCBpbmRleCsrLFxuICAgICAgICAgICAgcHJlZml4OiBcIlwiLFxuICAgICAgICAgICAgc3VmZml4OiBcIlwiLFxuICAgICAgICAgICAgbW9kaWZpZXI6IFwiXCIsXG4gICAgICAgICAgICBwYXR0ZXJuOiBcIlwiLFxuICAgICAgICB9KTtcbiAgICAgICAgZXhlY1Jlc3VsdCA9IGdyb3Vwc1JlZ2V4LmV4ZWMocGF0aC5zb3VyY2UpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAocGF0aHMsIGtleXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFydHMgPSBwYXRocy5tYXAoZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIHBhdGhUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKS5zb3VyY2U7IH0pO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86XCIuY29uY2F0KHBhcnRzLmpvaW4oXCJ8XCIpLCBcIilcIiksIGZsYWdzKG9wdGlvbnMpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9rZW5zVG9SZWdleHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9rZW5zVG9SZWdleHAodG9rZW5zLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgX2EgPSBvcHRpb25zLnN0cmljdCwgc3RyaWN0ID0gX2EgPT09IHZvaWQgMCA/IGZhbHNlIDogX2EsIF9iID0gb3B0aW9ucy5zdGFydCwgc3RhcnQgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBfYyA9IG9wdGlvbnMuZW5kLCBlbmQgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBfZCA9IG9wdGlvbnMuZW5jb2RlLCBlbmNvZGUgPSBfZCA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0gOiBfZCwgX2UgPSBvcHRpb25zLmRlbGltaXRlciwgZGVsaW1pdGVyID0gX2UgPT09IHZvaWQgMCA/IFwiLyM/XCIgOiBfZSwgX2YgPSBvcHRpb25zLmVuZHNXaXRoLCBlbmRzV2l0aCA9IF9mID09PSB2b2lkIDAgPyBcIlwiIDogX2Y7XG4gICAgdmFyIGVuZHNXaXRoUmUgPSBcIltcIi5jb25jYXQoZXNjYXBlU3RyaW5nKGVuZHNXaXRoKSwgXCJdfCRcIik7XG4gICAgdmFyIGRlbGltaXRlclJlID0gXCJbXCIuY29uY2F0KGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpLCBcIl1cIik7XG4gICAgdmFyIHJvdXRlID0gc3RhcnQgPyBcIl5cIiA6IFwiXCI7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgICBmb3IgKHZhciBfaSA9IDAsIHRva2Vuc18xID0gdG9rZW5zOyBfaSA8IHRva2Vuc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNfMVtfaV07XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyhlbmNvZGUodG9rZW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuLnByZWZpeCkpO1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IGVzY2FwZVN0cmluZyhlbmNvZGUodG9rZW4uc3VmZml4KSk7XG4gICAgICAgICAgICBpZiAodG9rZW4ucGF0dGVybikge1xuICAgICAgICAgICAgICAgIGlmIChrZXlzKVxuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmaXggfHwgc3VmZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi5tb2RpZmllciA9PT0gXCIrXCIgfHwgdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kID0gdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiID8gXCI/XCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIi5jb25jYXQocHJlZml4LCBcIigoPzpcIikuY29uY2F0KHRva2VuLnBhdHRlcm4sIFwiKSg/OlwiKS5jb25jYXQoc3VmZml4KS5jb25jYXQocHJlZml4LCBcIig/OlwiKS5jb25jYXQodG9rZW4ucGF0dGVybiwgXCIpKSopXCIpLmNvbmNhdChzdWZmaXgsIFwiKVwiKS5jb25jYXQobW9kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIuY29uY2F0KHByZWZpeCwgXCIoXCIpLmNvbmNhdCh0b2tlbi5wYXR0ZXJuLCBcIilcIikuY29uY2F0KHN1ZmZpeCwgXCIpXCIpLmNvbmNhdCh0b2tlbi5tb2RpZmllcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi5tb2RpZmllciA9PT0gXCIrXCIgfHwgdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZSArPSBcIigoPzpcIi5jb25jYXQodG9rZW4ucGF0dGVybiwgXCIpXCIpLmNvbmNhdCh0b2tlbi5tb2RpZmllciwgXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoXCIuY29uY2F0KHRva2VuLnBhdHRlcm4sIFwiKVwiKS5jb25jYXQodG9rZW4ubW9kaWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIi5jb25jYXQocHJlZml4KS5jb25jYXQoc3VmZml4LCBcIilcIikuY29uY2F0KHRva2VuLm1vZGlmaWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kKSB7XG4gICAgICAgIGlmICghc3RyaWN0KVxuICAgICAgICAgICAgcm91dGUgKz0gXCJcIi5jb25jYXQoZGVsaW1pdGVyUmUsIFwiP1wiKTtcbiAgICAgICAgcm91dGUgKz0gIW9wdGlvbnMuZW5kc1dpdGggPyBcIiRcIiA6IFwiKD89XCIuY29uY2F0KGVuZHNXaXRoUmUsIFwiKVwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBlbmRUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBpc0VuZERlbGltaXRlZCA9IHR5cGVvZiBlbmRUb2tlbiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBkZWxpbWl0ZXJSZS5pbmRleE9mKGVuZFRva2VuW2VuZFRva2VuLmxlbmd0aCAtIDFdKSA+IC0xXG4gICAgICAgICAgICA6IGVuZFRva2VuID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghc3RyaWN0KSB7XG4gICAgICAgICAgICByb3V0ZSArPSBcIig/OlwiLmNvbmNhdChkZWxpbWl0ZXJSZSwgXCIoPz1cIikuY29uY2F0KGVuZHNXaXRoUmUsIFwiKSk/XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNFbmREZWxpbWl0ZWQpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IFwiKD89XCIuY29uY2F0KGRlbGltaXRlclJlLCBcInxcIikuY29uY2F0KGVuZHNXaXRoUmUsIFwiKVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZ0V4cChyb3V0ZSwgZmxhZ3Mob3B0aW9ucykpO1xufVxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIGtleXMpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKVxuICAgICAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gc3RyaW5nVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/msw/node_modules/path-to-regexp/dist.es2015/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/msw/lib/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/msw/lib/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  GraphQLHandler: () => GraphQLHandler,\n  MockedRequest: () => MockedRequest,\n  RESTMethods: () => RESTMethods,\n  RequestHandler: () => RequestHandler,\n  RestHandler: () => RestHandler,\n  SetupApi: () => SetupApi,\n  SetupWorkerApi: () => SetupWorkerApi,\n  cleanUrl: () => cleanUrl,\n  compose: () => compose,\n  context: () => context_exports,\n  createResponseComposition: () => createResponseComposition,\n  defaultContext: () => defaultContext,\n  defaultResponse: () => defaultResponse,\n  graphql: () => graphql,\n  graphqlContext: () => graphqlContext,\n  handleRequest: () => handleRequest,\n  matchRequestUrl: () => matchRequestUrl,\n  response: () => response,\n  rest: () => rest,\n  restContext: () => restContext,\n  setupWorker: () => setupWorker\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/context/index.ts\nvar context_exports = {};\n__export(context_exports, {\n  body: () => body,\n  cookie: () => cookie,\n  data: () => data,\n  delay: () => delay,\n  errors: () => errors,\n  extensions: () => extensions,\n  fetch: () => fetch,\n  json: () => json,\n  set: () => set,\n  status: () => status,\n  text: () => text,\n  xml: () => xml\n});\n\n// node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json\nvar codes_default = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"103\": \"Early Hints\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a Teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Too Early\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n};\n\n// src/context/status.ts\nvar status = (statusCode, statusText) => {\n  return (res) => {\n    res.status = statusCode;\n    res.statusText = statusText || codes_default[String(statusCode)];\n    return res;\n  };\n};\n\n// src/context/set.ts\nvar import_headers_polyfill = __webpack_require__(/*! headers-polyfill */ \"(rsc)/../../node_modules/headers-polyfill/lib/index.js\");\nfunction set(...args) {\n  return (res) => {\n    const [name, value] = args;\n    if (typeof name === \"string\") {\n      res.headers.append(name, value);\n    } else {\n      const headers = (0, import_headers_polyfill.objectToHeaders)(name);\n      headers.forEach((value2, name2) => {\n        res.headers.append(name2, value2);\n      });\n    }\n    return res;\n  };\n}\n\n// src/context/cookie.ts\nvar cookieUtils = __toESM(__webpack_require__(/*! cookie */ \"(rsc)/../../node_modules/cookie/index.js\"));\nvar cookie = (name, value, options) => {\n  return (res) => {\n    const serializedCookie = cookieUtils.serialize(name, value, options);\n    res.headers.append(\"Set-Cookie\", serializedCookie);\n    if (typeof document !== \"undefined\") {\n      document.cookie = serializedCookie;\n    }\n    return res;\n  };\n};\n\n// src/context/body.ts\nvar body = (value) => {\n  return (res) => {\n    res.body = value;\n    return res;\n  };\n};\n\n// src/utils/internal/jsonParse.ts\nfunction jsonParse(value) {\n  try {\n    return JSON.parse(value);\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/internal/isObject.ts\nfunction isObject(value) {\n  return value != null && typeof value === \"object\" && !Array.isArray(value);\n}\n\n// src/utils/internal/mergeRight.ts\nfunction mergeRight(left, right) {\n  return Object.entries(right).reduce((result, [key, rightValue]) => {\n    const leftValue = result[key];\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue);\n      return result;\n    }\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue);\n      return result;\n    }\n    result[key] = rightValue;\n    return result;\n  }, Object.assign({}, left));\n}\n\n// src/context/json.ts\nvar json = (body2) => {\n  return (res) => {\n    res.headers.set(\"Content-Type\", \"application/json\");\n    res.body = JSON.stringify(body2);\n    return res;\n  };\n};\n\n// src/context/data.ts\nvar data = (payload) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { data: payload });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/extensions.ts\nvar extensions = (payload) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { extensions: payload });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/delay.ts\nvar import_is_node_process = __webpack_require__(/*! is-node-process */ \"(rsc)/../../node_modules/is-node-process/lib/index.js\");\nvar SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;\nvar MIN_SERVER_RESPONSE_TIME = 100;\nvar MAX_SERVER_RESPONSE_TIME = 400;\nvar NODE_SERVER_RESPONSE_TIME = 5;\nvar getRandomServerResponseTime = () => {\n  if ((0, import_is_node_process.isNodeProcess)()) {\n    return NODE_SERVER_RESPONSE_TIME;\n  }\n  return Math.floor(\n    Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME\n  );\n};\nvar delay = (durationOrMode) => {\n  return (res) => {\n    let delayTime;\n    if (typeof durationOrMode === \"string\") {\n      switch (durationOrMode) {\n        case \"infinite\": {\n          delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;\n          break;\n        }\n        case \"real\": {\n          delayTime = getRandomServerResponseTime();\n          break;\n        }\n        default: {\n          throw new Error(\n            `Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`\n          );\n        }\n      }\n    } else if (typeof durationOrMode === \"undefined\") {\n      delayTime = getRandomServerResponseTime();\n    } else {\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\n          `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`\n        );\n      }\n      delayTime = durationOrMode;\n    }\n    res.delay = delayTime;\n    return res;\n  };\n};\n\n// src/context/errors.ts\nvar errors = (errorsList) => {\n  return (res) => {\n    if (errorsList == null) {\n      return res;\n    }\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { errors: errorsList });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/fetch.ts\nvar import_is_node_process2 = __webpack_require__(/*! is-node-process */ \"(rsc)/../../node_modules/is-node-process/lib/index.js\");\nvar import_headers_polyfill2 = __webpack_require__(/*! headers-polyfill */ \"(rsc)/../../node_modules/headers-polyfill/lib/index.js\");\nvar useFetch = (0, import_is_node_process2.isNodeProcess)() ? (input, init) => Promise.resolve().then(() => __toESM(__webpack_require__(/*! node-fetch */ \"(rsc)/../../node_modules/node-fetch/lib/index.mjs\"))).then(\n  ({ default: nodeFetch }) => nodeFetch(input, init)\n) : globalThis.fetch;\nvar augmentRequestInit = (requestInit) => {\n  const headers = new import_headers_polyfill2.Headers(requestInit.headers);\n  headers.set(\"x-msw-bypass\", \"true\");\n  return {\n    ...requestInit,\n    headers: headers.all()\n  };\n};\nvar createFetchRequestParameters = (input) => {\n  const { body: body2, method } = input;\n  const requestParameters = {\n    ...input,\n    body: void 0\n  };\n  if ([\"GET\", \"HEAD\"].includes(method)) {\n    return requestParameters;\n  }\n  if (typeof body2 === \"object\" || typeof body2 === \"number\" || typeof body2 === \"boolean\") {\n    requestParameters.body = JSON.stringify(body2);\n  } else {\n    requestParameters.body = body2;\n  }\n  return requestParameters;\n};\nvar fetch = (input, requestInit = {}) => {\n  if (typeof input === \"string\") {\n    return useFetch(input, augmentRequestInit(requestInit));\n  }\n  const requestParameters = createFetchRequestParameters(input);\n  const derivedRequestInit = augmentRequestInit(requestParameters);\n  return useFetch(input.url.href, derivedRequestInit);\n};\n\n// src/context/text.ts\nvar text = (body2) => {\n  return (res) => {\n    res.headers.set(\"Content-Type\", \"text/plain\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/context/xml.ts\nvar xml = (body2) => {\n  return (res) => {\n    res.headers.set(\"Content-Type\", \"text/xml\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/utils/internal/checkGlobals.ts\nvar import_outvariant2 = __webpack_require__(/*! outvariant */ \"(rsc)/../../node_modules/outvariant/lib/index.js\");\n\n// src/utils/internal/devUtils.ts\nvar import_outvariant = __webpack_require__(/*! outvariant */ \"(rsc)/../../node_modules/outvariant/lib/index.js\");\nvar LIBRARY_PREFIX = \"[MSW]\";\nfunction formatMessage(message, ...positionals) {\n  const interpolatedMessage = (0, import_outvariant.format)(message, ...positionals);\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`;\n}\nfunction warn(message, ...positionals) {\n  console.warn(formatMessage(message, ...positionals));\n}\nfunction error(message, ...positionals) {\n  console.error(formatMessage(message, ...positionals));\n}\nvar devUtils = {\n  formatMessage,\n  warn,\n  error\n};\n\n// src/utils/internal/checkGlobals.ts\nfunction checkGlobals() {\n  (0, import_outvariant2.invariant)(\n    typeof URL !== \"undefined\",\n    devUtils.formatMessage(\n      `Global \"URL\" class is not defined. This likely means that you're running MSW in an environment that doesn't support all Node.js standard API (e.g. React Native). If that's the case, please use an appropriate polyfill for the \"URL\" class, like \"react-native-url-polyfill\".`\n    )\n  );\n}\n\n// src/setupWorker/setupWorker.ts\nvar import_outvariant5 = __webpack_require__(/*! outvariant */ \"(rsc)/../../node_modules/outvariant/lib/index.js\");\nvar import_is_node_process3 = __webpack_require__(/*! is-node-process */ \"(rsc)/../../node_modules/is-node-process/lib/index.js\");\n\n// src/setupWorker/start/createStartHandler.ts\nvar import_until4 = __webpack_require__(/*! @open-draft/until */ \"(rsc)/../../node_modules/@open-draft/until/lib/index.js\");\n\n// src/setupWorker/start/utils/getWorkerInstance.ts\nvar import_until = __webpack_require__(/*! @open-draft/until */ \"(rsc)/../../node_modules/@open-draft/until/lib/index.js\");\n\n// src/setupWorker/start/utils/getWorkerByRegistration.ts\nfunction getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker) {\n  const allStates = [\n    registration.active,\n    registration.installing,\n    registration.waiting\n  ];\n  const relevantStates = allStates.filter((state) => {\n    return state != null;\n  });\n  const worker = relevantStates.find((worker2) => {\n    return findWorker(worker2.scriptURL, absoluteWorkerUrl);\n  });\n  return worker || null;\n}\n\n// src/utils/url/getAbsoluteWorkerUrl.ts\nfunction getAbsoluteWorkerUrl(workerUrl) {\n  return new URL(workerUrl, location.href).href;\n}\n\n// src/setupWorker/start/utils/getWorkerInstance.ts\nvar getWorkerInstance = async (url, options = {}, findWorker) => {\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n  const mockRegistrations = await navigator.serviceWorker.getRegistrations().then(\n    (registrations) => registrations.filter(\n      (registration) => getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker)\n    )\n  );\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    location.reload();\n  }\n  const [existingRegistration] = mockRegistrations;\n  if (existingRegistration) {\n    return existingRegistration.update().then(() => {\n      return [\n        getWorkerByRegistration(\n          existingRegistration,\n          absoluteWorkerUrl,\n          findWorker\n        ),\n        existingRegistration\n      ];\n    });\n  }\n  const [error2, instance] = await (0, import_until.until)(\n    async () => {\n      const registration = await navigator.serviceWorker.register(url, options);\n      return [\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n        registration\n      ];\n    }\n  );\n  if (error2) {\n    const isWorkerMissing = error2.message.includes(\"(404)\");\n    if (isWorkerMissing) {\n      const scopeUrl = new URL((options == null ? void 0 : options.scope) || \"/\", location.href);\n      throw new Error(\n        devUtils.formatMessage(`Failed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`)\n      );\n    }\n    throw new Error(\n      devUtils.formatMessage(\n        \"Failed to register the Service Worker:\\n\\n%s\",\n        error2.message\n      )\n    );\n  }\n  return instance;\n};\n\n// src/setupWorker/start/utils/printStartMessage.ts\nfunction printStartMessage(args = {}) {\n  if (args.quiet) {\n    return;\n  }\n  const message = args.message || \"Mocking enabled.\";\n  console.groupCollapsed(\n    `%c${devUtils.formatMessage(message)}`,\n    \"color:orangered;font-weight:bold;\"\n  );\n  console.log(\n    \"%cDocumentation: %chttps://mswjs.io/docs\",\n    \"font-weight:bold\",\n    \"font-weight:normal\"\n  );\n  console.log(\"Found an issue? https://github.com/mswjs/msw/issues\");\n  if (args.workerUrl) {\n    console.log(\"Worker script URL:\", args.workerUrl);\n  }\n  if (args.workerScope) {\n    console.log(\"Worker scope:\", args.workerScope);\n  }\n  console.groupEnd();\n}\n\n// src/setupWorker/start/utils/enableMocking.ts\nasync function enableMocking(context, options) {\n  var _a, _b;\n  context.workerChannel.send(\"MOCK_ACTIVATE\");\n  await context.events.once(\"MOCKING_ENABLED\");\n  if (context.isMockingEnabled) {\n    devUtils.warn(\n      `Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`\n    );\n    return;\n  }\n  context.isMockingEnabled = true;\n  printStartMessage({\n    quiet: options.quiet,\n    workerScope: (_a = context.registration) == null ? void 0 : _a.scope,\n    workerUrl: (_b = context.worker) == null ? void 0 : _b.scriptURL\n  });\n}\n\n// src/setupWorker/start/utils/createMessageChannel.ts\nvar WorkerChannel = class {\n  constructor(port) {\n    this.port = port;\n  }\n  postMessage(event, ...rest2) {\n    const [data2, transfer] = rest2;\n    this.port.postMessage({ type: event, data: data2 }, { transfer });\n  }\n};\n\n// src/utils/NetworkError.ts\nvar NetworkError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"NetworkError\";\n  }\n};\n\n// src/utils/request/parseWorkerRequest.ts\nvar import_interceptors2 = __webpack_require__(/*! @mswjs/interceptors */ \"(rsc)/../../node_modules/@mswjs/interceptors/lib/index.js\");\nvar import_headers_polyfill5 = __webpack_require__(/*! headers-polyfill */ \"(rsc)/../../node_modules/headers-polyfill/lib/index.js\");\n\n// src/utils/request/MockedRequest.ts\nvar cookieUtils3 = __toESM(__webpack_require__(/*! cookie */ \"(rsc)/../../node_modules/cookie/index.js\"));\nvar import_cookies = __webpack_require__(/*! @mswjs/cookies */ \"(rsc)/../../node_modules/@mswjs/cookies/lib/index.js\");\nvar import_interceptors = __webpack_require__(/*! @mswjs/interceptors */ \"(rsc)/../../node_modules/@mswjs/interceptors/lib/index.js\");\nvar import_bufferUtils = __webpack_require__(/*! @mswjs/interceptors/lib/utils/bufferUtils.js */ \"(rsc)/../../node_modules/@mswjs/interceptors/lib/utils/bufferUtils.js\");\nvar import_headers_polyfill4 = __webpack_require__(/*! headers-polyfill */ \"(rsc)/../../node_modules/headers-polyfill/lib/index.js\");\n\n// src/utils/request/getRequestCookies.ts\nvar cookieUtils2 = __toESM(__webpack_require__(/*! cookie */ \"(rsc)/../../node_modules/cookie/index.js\"));\nfunction getAllCookies() {\n  return cookieUtils2.parse(document.cookie);\n}\nfunction getRequestCookies(request) {\n  if (typeof document === \"undefined\" || typeof location === \"undefined\") {\n    return {};\n  }\n  switch (request.credentials) {\n    case \"same-origin\": {\n      return location.origin === request.url.origin ? getAllCookies() : {};\n    }\n    case \"include\": {\n      return getAllCookies();\n    }\n    default: {\n      return {};\n    }\n  }\n}\n\n// src/utils/internal/parseMultipartData.ts\nvar import_headers_polyfill3 = __webpack_require__(/*! headers-polyfill */ \"(rsc)/../../node_modules/headers-polyfill/lib/index.js\");\nfunction parseContentHeaders(headersString) {\n  var _a, _b;\n  const headers = (0, import_headers_polyfill3.stringToHeaders)(headersString);\n  const contentType = headers.get(\"content-type\") || \"text/plain\";\n  const disposition = headers.get(\"content-disposition\");\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.');\n  }\n  const directives = disposition.split(\";\").reduce((acc, chunk) => {\n    const [name2, ...rest2] = chunk.trim().split(\"=\");\n    acc[name2] = rest2.join(\"=\");\n    return acc;\n  }, {});\n  const name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);\n  const filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);\n  return {\n    name,\n    filename,\n    contentType\n  };\n}\nfunction parseMultipartData(data2, headers) {\n  const contentType = headers == null ? void 0 : headers.get(\"content-type\");\n  if (!contentType) {\n    return void 0;\n  }\n  const [, ...directives] = contentType.split(/; */);\n  const boundary = directives.filter((d) => d.startsWith(\"boundary=\")).map((s) => s.replace(/^boundary=/, \"\"))[0];\n  if (!boundary) {\n    return void 0;\n  }\n  const boundaryRegExp = new RegExp(`--+${boundary}`);\n  const fields = data2.split(boundaryRegExp).filter((chunk) => chunk.startsWith(\"\\r\\n\") && chunk.endsWith(\"\\r\\n\")).map((chunk) => chunk.trimStart().replace(/\\r\\n$/, \"\"));\n  if (!fields.length) {\n    return void 0;\n  }\n  const parsedBody = {};\n  try {\n    for (const field2 of fields) {\n      const [contentHeaders, ...rest2] = field2.split(\"\\r\\n\\r\\n\");\n      const contentBody = rest2.join(\"\\r\\n\\r\\n\");\n      const { contentType: contentType2, filename, name } = parseContentHeaders(contentHeaders);\n      const value = filename === void 0 ? contentBody : new File([contentBody], filename, { type: contentType2 });\n      const parsedValue = parsedBody[name];\n      if (parsedValue === void 0) {\n        parsedBody[name] = value;\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value];\n      } else {\n        parsedBody[name] = [parsedValue, value];\n      }\n    }\n    return parsedBody;\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/request/parseBody.ts\nfunction parseBody(body2, headers) {\n  var _a;\n  if (!body2) {\n    return body2;\n  }\n  const contentType = ((_a = headers == null ? void 0 : headers.get(\"content-type\")) == null ? void 0 : _a.toLowerCase()) || \"\";\n  const hasMultipartContent = contentType.startsWith(\"multipart/form-data\");\n  if (hasMultipartContent && typeof body2 !== \"object\") {\n    return parseMultipartData(body2.toString(), headers) || body2;\n  }\n  const hasJsonContent = contentType.includes(\"json\");\n  if (hasJsonContent && typeof body2 !== \"object\") {\n    return jsonParse(body2.toString()) || body2;\n  }\n  return body2;\n}\n\n// src/utils/internal/isStringEqual.ts\nfunction isStringEqual(actual, expected) {\n  return actual.toLowerCase() === expected.toLowerCase();\n}\n\n// src/utils/request/MockedRequest.ts\nvar MockedRequest = class extends import_interceptors.IsomorphicRequest {\n  constructor(url, init = {}) {\n    super(url, init);\n    if (init.id) {\n      this.id = init.id;\n    }\n    this.cache = init.cache || \"default\";\n    this.destination = init.destination || \"\";\n    this.integrity = init.integrity || \"\";\n    this.keepalive = init.keepalive || false;\n    this.mode = init.mode || \"cors\";\n    this.priority = init.priority || \"auto\";\n    this.redirect = init.redirect || \"follow\";\n    this.referrer = init.referrer || \"\";\n    this.referrerPolicy = init.referrerPolicy || \"no-referrer\";\n    this.cookies = init.cookies || this.getCookies();\n  }\n  get body() {\n    const text2 = (0, import_bufferUtils.decodeBuffer)(this[\"_body\"]);\n    const body2 = parseBody(text2, this.headers);\n    if (isStringEqual(this.method, \"GET\") && body2 === \"\") {\n      return void 0;\n    }\n    return body2;\n  }\n  passthrough() {\n    return {\n      status: 101,\n      statusText: \"Continue\",\n      headers: new import_headers_polyfill4.Headers(),\n      body: null,\n      passthrough: true,\n      once: false\n    };\n  }\n  getCookies() {\n    var _a;\n    const requestCookiesString = this.headers.get(\"cookie\");\n    const ownCookies = requestCookiesString ? cookieUtils3.parse(requestCookiesString) : {};\n    import_cookies.store.hydrate();\n    const cookiesFromStore = Array.from(\n      (_a = import_cookies.store.get({ ...this, url: this.url.href })) == null ? void 0 : _a.entries()\n    ).reduce((cookies, [name, { value }]) => {\n      return Object.assign(cookies, { [name.trim()]: value });\n    }, {});\n    const cookiesFromDocument = getRequestCookies(this);\n    const forwardedCookies = {\n      ...cookiesFromDocument,\n      ...cookiesFromStore\n    };\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append(\"cookie\", `${name}=${value}`);\n    }\n    return {\n      ...forwardedCookies,\n      ...ownCookies\n    };\n  }\n};\n\n// src/utils/request/parseWorkerRequest.ts\nfunction parseWorkerRequest(rawRequest) {\n  const url = new URL(rawRequest.url);\n  const headers = new import_headers_polyfill5.Headers(rawRequest.headers);\n  return new MockedRequest(url, {\n    ...rawRequest,\n    body: (0, import_interceptors2.encodeBuffer)(rawRequest.body || \"\"),\n    headers\n  });\n}\n\n// src/utils/handleRequest.ts\nvar import_until2 = __webpack_require__(/*! @open-draft/until */ \"(rsc)/../../node_modules/@open-draft/until/lib/index.js\");\n\n// src/utils/getResponse.ts\nvar getResponse = async (request, handlers, resolutionContext) => {\n  const relevantHandlers = handlers.filter((handler) => {\n    return handler.test(request, resolutionContext);\n  });\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  const result = await relevantHandlers.reduce(async (executionResult, handler) => {\n    const previousResults = await executionResult;\n    if (!!(previousResults == null ? void 0 : previousResults.response)) {\n      return executionResult;\n    }\n    const result2 = await handler.run(request, resolutionContext);\n    if (result2 === null || result2.handler.shouldSkip) {\n      return null;\n    }\n    if (!result2.response) {\n      return {\n        request: result2.request,\n        handler: result2.handler,\n        response: void 0,\n        parsedResult: result2.parsedResult\n      };\n    }\n    if (result2.response.once) {\n      handler.markAsSkipped(true);\n    }\n    return result2;\n  }, Promise.resolve(null));\n  if (!result) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response\n  };\n};\n\n// src/utils/request/onUnhandledRequest.ts\nvar import_js_levenshtein = __toESM(__webpack_require__(/*! js-levenshtein */ \"(rsc)/../../node_modules/js-levenshtein/index.js\"));\n\n// src/utils/internal/parseGraphQLRequest.ts\nvar import_graphql = __webpack_require__(/*! graphql */ \"(rsc)/../../node_modules/graphql/index.mjs\");\n\n// src/utils/request/getPublicUrlFromRequest.ts\nvar getPublicUrlFromRequest = (request) => {\n  return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(\n    request.url.pathname,\n    `${request.url.protocol}//${request.url.host}`\n  ).href;\n};\n\n// src/utils/internal/parseGraphQLRequest.ts\nfunction parseDocumentNode(node) {\n  var _a;\n  const operationDef = node.definitions.find((def) => {\n    return def.kind === \"OperationDefinition\";\n  });\n  return {\n    operationType: operationDef == null ? void 0 : operationDef.operation,\n    operationName: (_a = operationDef == null ? void 0 : operationDef.name) == null ? void 0 : _a.value\n  };\n}\nfunction parseQuery(query) {\n  try {\n    const ast = (0, import_graphql.parse)(query);\n    return parseDocumentNode(ast);\n  } catch (error2) {\n    return error2;\n  }\n}\nfunction extractMultipartVariables(variables, map, files) {\n  const operations = { variables };\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`);\n    }\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split(\".\").reverse();\n      const paths = reversedPaths.reverse();\n      let target = operations;\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`);\n        }\n        target = target[path];\n      }\n      target[lastPath] = files[key];\n    }\n  }\n  return operations.variables;\n}\nfunction getGraphQLInput(request) {\n  var _a, _b;\n  switch (request.method) {\n    case \"GET\": {\n      const query = request.url.searchParams.get(\"query\");\n      const variables = request.url.searchParams.get(\"variables\") || \"\";\n      return {\n        query,\n        variables: jsonParse(variables)\n      };\n    }\n    case \"POST\": {\n      if ((_a = request.body) == null ? void 0 : _a.query) {\n        const { query, variables } = request.body;\n        return {\n          query,\n          variables\n        };\n      }\n      if ((_b = request.body) == null ? void 0 : _b.operations) {\n        const { operations, map, ...files } = request.body;\n        const parsedOperations = jsonParse(\n          operations\n        ) || {};\n        if (!parsedOperations.query) {\n          return null;\n        }\n        const parsedMap = jsonParse(map || \"\") || {};\n        const variables = parsedOperations.variables ? extractMultipartVariables(\n          parsedOperations.variables,\n          parsedMap,\n          files\n        ) : {};\n        return {\n          query: parsedOperations.query,\n          variables\n        };\n      }\n    }\n    default:\n      return null;\n  }\n}\nfunction parseGraphQLRequest(request) {\n  const input = getGraphQLInput(request);\n  if (!input || !input.query) {\n    return void 0;\n  }\n  const { query, variables } = input;\n  const parsedResult = parseQuery(query);\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s',\n        request.method,\n        requestPublicUrl,\n        parsedResult.message\n      )\n    );\n  }\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables\n  };\n}\n\n// src/utils/logging/getStatusCodeColor.ts\nfunction getStatusCodeColor(status2) {\n  if (status2 < 300) {\n    return \"#69AB32\" /* Success */;\n  }\n  if (status2 < 400) {\n    return \"#F0BB4B\" /* Warning */;\n  }\n  return \"#E95F5D\" /* Danger */;\n}\n\n// src/utils/logging/getTimestamp.ts\nfunction getTimestamp() {\n  const now = new Date();\n  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map((chunk) => chunk.slice(0, 2)).map((chunk) => chunk.padStart(2, \"0\")).join(\":\");\n}\n\n// src/utils/logging/prepareRequest.ts\nfunction prepareRequest(request) {\n  return {\n    ...request,\n    body: request.body,\n    headers: request.headers.all()\n  };\n}\n\n// src/utils/logging/prepareResponse.ts\nvar import_headers_polyfill6 = __webpack_require__(/*! headers-polyfill */ \"(rsc)/../../node_modules/headers-polyfill/lib/index.js\");\nfunction prepareResponse(res) {\n  const responseHeaders = (0, import_headers_polyfill6.objectToHeaders)(res.headers);\n  const parsedBody = parseBody(res.body, responseHeaders);\n  return {\n    ...res,\n    body: parsedBody\n  };\n}\n\n// src/utils/matching/matchRequestUrl.ts\nvar import_path_to_regexp = __webpack_require__(/*! path-to-regexp */ \"(rsc)/../../node_modules/msw/node_modules/path-to-regexp/dist.es2015/index.js\");\nvar import_getCleanUrl = __webpack_require__(/*! @mswjs/interceptors/lib/utils/getCleanUrl.js */ \"(rsc)/../../node_modules/@mswjs/interceptors/lib/utils/getCleanUrl.js\");\n\n// src/utils/url/cleanUrl.ts\nvar REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g;\nfunction getSearchParams(path) {\n  return new URL(`/${path}`, \"http://localhost\").searchParams;\n}\nfunction cleanUrl(path) {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, \"\");\n}\n\n// src/utils/url/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n}\n\n// src/utils/url/getAbsoluteUrl.ts\nfunction getAbsoluteUrl(path, baseUrl) {\n  if (isAbsoluteUrl(path)) {\n    return path;\n  }\n  if (path.startsWith(\"*\")) {\n    return path;\n  }\n  const origin = baseUrl || typeof document !== \"undefined\" && document.baseURI;\n  return origin ? decodeURI(new URL(encodeURI(path), origin).href) : path;\n}\n\n// src/utils/matching/normalizePath.ts\nfunction normalizePath(path, baseUrl) {\n  if (path instanceof RegExp) {\n    return path;\n  }\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);\n  return cleanUrl(maybeAbsoluteUrl);\n}\n\n// src/utils/matching/matchRequestUrl.ts\nfunction coercePath(path) {\n  return path.replace(\n    /([:a-zA-Z_-]*)(\\*{1,2})+/g,\n    (_, parameterName, wildcard) => {\n      const expression = \"(.*)\";\n      if (!parameterName) {\n        return expression;\n      }\n      return parameterName.startsWith(\":\") ? `${parameterName}${wildcard}` : `${parameterName}${expression}`;\n    }\n  ).replace(/([^\\/])(:)(?=\\d+)/, \"$1\\\\$2\").replace(/^([^\\/]+)(:)(?=\\/\\/)/, \"$1\\\\$2\");\n}\nfunction matchRequestUrl(url, path, baseUrl) {\n  const normalizedPath = normalizePath(path, baseUrl);\n  const cleanPath = typeof normalizedPath === \"string\" ? coercePath(normalizedPath) : normalizedPath;\n  const cleanUrl2 = (0, import_getCleanUrl.getCleanUrl)(url);\n  const result = (0, import_path_to_regexp.match)(cleanPath, { decode: decodeURIComponent })(cleanUrl2);\n  const params = result && result.params || {};\n  return {\n    matches: result !== false,\n    params\n  };\n}\n\n// src/handlers/RequestHandler.ts\nvar import_headers_polyfill8 = __webpack_require__(/*! headers-polyfill */ \"(rsc)/../../node_modules/headers-polyfill/lib/index.js\");\n\n// src/response.ts\nvar import_headers_polyfill7 = __webpack_require__(/*! headers-polyfill */ \"(rsc)/../../node_modules/headers-polyfill/lib/index.js\");\n\n// src/utils/internal/compose.ts\nfunction compose(...fns) {\n  return (...args) => {\n    return fns.reduceRight((leftFn, rightFn) => {\n      return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);\n    }, args[0]);\n  };\n}\n\n// src/response.ts\nvar defaultResponse = {\n  status: 200,\n  statusText: \"OK\",\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false\n};\nvar defaultResponseTransformers = [];\nfunction createResponseComposition(responseOverrides, defaultTransformers = defaultResponseTransformers) {\n  return async (...transformers) => {\n    const initialResponse = Object.assign(\n      {},\n      defaultResponse,\n      {\n        headers: new import_headers_polyfill7.Headers({\n          \"x-powered-by\": \"msw\"\n        })\n      },\n      responseOverrides\n    );\n    const resolvedTransformers = [\n      ...defaultTransformers,\n      ...transformers\n    ].filter(Boolean);\n    const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;\n    return resolvedResponse;\n  };\n}\nvar response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({ once: true }),\n  networkError(message) {\n    throw new NetworkError(message);\n  }\n});\n\n// src/utils/internal/getCallFrame.ts\nvar SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/;\nvar BUILD_FRAME = /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/;\nfunction getCallFrame(error2) {\n  const stack = error2.stack;\n  if (!stack) {\n    return;\n  }\n  const frames = stack.split(\"\\n\").slice(1);\n  const declarationFrame = frames.find((frame) => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame));\n  });\n  if (!declarationFrame) {\n    return;\n  }\n  const declarationPath = declarationFrame.replace(/\\s*at [^()]*\\(([^)]+)\\)/, \"$1\").replace(/^@/, \"\");\n  return declarationPath;\n}\n\n// src/utils/internal/isIterable.ts\nfunction isIterable(fn) {\n  if (!fn) {\n    return false;\n  }\n  return typeof fn[Symbol.iterator] == \"function\";\n}\n\n// src/handlers/RequestHandler.ts\nvar defaultContext = {\n  status,\n  set,\n  delay,\n  fetch\n};\nvar RequestHandler = class {\n  constructor(options) {\n    this.shouldSkip = false;\n    this.ctx = options.ctx || defaultContext;\n    this.resolver = options.resolver;\n    const callFrame = getCallFrame(new Error());\n    this.info = {\n      ...options.info,\n      callFrame\n    };\n  }\n  parse(_request, _resolutionContext) {\n    return null;\n  }\n  test(request, resolutionContext) {\n    return this.predicate(\n      request,\n      this.parse(request, resolutionContext),\n      resolutionContext\n    );\n  }\n  getPublicRequest(request, _parsedResult) {\n    return request;\n  }\n  markAsSkipped(shouldSkip = true) {\n    this.shouldSkip = shouldSkip;\n  }\n  async run(request, resolutionContext) {\n    if (this.shouldSkip) {\n      return null;\n    }\n    const parsedResult = this.parse(request, resolutionContext);\n    const shouldIntercept = this.predicate(\n      request,\n      parsedResult,\n      resolutionContext\n    );\n    if (!shouldIntercept) {\n      return null;\n    }\n    const publicRequest = this.getPublicRequest(request, parsedResult);\n    const executeResolver = this.wrapResolver(this.resolver);\n    const mockedResponse = await executeResolver(\n      publicRequest,\n      response,\n      this.ctx\n    );\n    return this.createExecutionResult(\n      parsedResult,\n      publicRequest,\n      mockedResponse\n    );\n  }\n  wrapResolver(resolver) {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || await resolver(req, res, ctx);\n      if (isIterable(result)) {\n        const { value, done } = result[Symbol.iterator]().next();\n        const nextResponse = await value;\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult;\n        }\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result;\n        }\n        this.resolverGeneratorResult = nextResponse;\n        return nextResponse;\n      }\n      return result;\n    };\n  }\n  createExecutionResult(parsedResult, request, response2) {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response2 || null\n    };\n  }\n};\n\n// src/handlers/RestHandler.ts\nvar RESTMethods = /* @__PURE__ */ ((RESTMethods2) => {\n  RESTMethods2[\"HEAD\"] = \"HEAD\";\n  RESTMethods2[\"GET\"] = \"GET\";\n  RESTMethods2[\"POST\"] = \"POST\";\n  RESTMethods2[\"PUT\"] = \"PUT\";\n  RESTMethods2[\"PATCH\"] = \"PATCH\";\n  RESTMethods2[\"OPTIONS\"] = \"OPTIONS\";\n  RESTMethods2[\"DELETE\"] = \"DELETE\";\n  return RESTMethods2;\n})(RESTMethods || {});\nvar restContext = {\n  ...defaultContext,\n  cookie,\n  body,\n  text,\n  json,\n  xml\n};\nvar RestRequest = class extends MockedRequest {\n  constructor(request, params) {\n    super(request.url, {\n      ...request,\n      body: request[\"_body\"]\n    });\n    this.params = params;\n    this.id = request.id;\n  }\n};\nvar RestHandler = class extends RequestHandler {\n  constructor(method, path, resolver) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method\n      },\n      ctx: restContext,\n      resolver\n    });\n    this.checkRedundantQueryParameters();\n  }\n  checkRedundantQueryParameters() {\n    const { method, path } = this.info;\n    if (path instanceof RegExp) {\n      return;\n    }\n    const url = cleanUrl(path);\n    if (url === path) {\n      return;\n    }\n    const searchParams = getSearchParams(path);\n    const queryParams = [];\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName);\n    });\n    devUtils.warn(\n      `Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`\n    );\n  }\n  parse(request, resolutionContext) {\n    return matchRequestUrl(\n      request.url,\n      this.info.path,\n      resolutionContext == null ? void 0 : resolutionContext.baseUrl\n    );\n  }\n  getPublicRequest(request, parsedResult) {\n    return new RestRequest(request, parsedResult.params || {});\n  }\n  predicate(request, parsedResult) {\n    const matchesMethod = this.info.method instanceof RegExp ? this.info.method.test(request.method) : isStringEqual(this.info.method, request.method);\n    return matchesMethod && parsedResult.matches;\n  }\n  log(request, response2) {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    console.groupCollapsed(\n      devUtils.formatMessage(\"%s %s %s (%c%s%c)\"),\n      getTimestamp(),\n      request.method,\n      publicUrl,\n      `color:${statusColor}`,\n      `${response2.status} ${response2.statusText}`,\n      \"color:inherit\"\n    );\n    console.log(\"Request\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/context/field.ts\nvar import_outvariant3 = __webpack_require__(/*! outvariant */ \"(rsc)/../../node_modules/outvariant/lib/index.js\");\nvar field = (fieldName, fieldValue) => {\n  return (res) => {\n    validateFieldName(fieldName);\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { [fieldName]: fieldValue });\n    return json(nextBody)(res);\n  };\n};\nfunction validateFieldName(fieldName) {\n  (0, import_outvariant3.invariant)(\n    fieldName.trim() !== \"\",\n    devUtils.formatMessage(\n      \"Failed to set a custom field on a GraphQL response: field name cannot be empty.\"\n    )\n  );\n  (0, import_outvariant3.invariant)(\n    fieldName !== \"data\",\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?',\n      fieldName\n    )\n  );\n  (0, import_outvariant3.invariant)(\n    fieldName !== \"errors\",\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?',\n      fieldName\n    )\n  );\n  (0, import_outvariant3.invariant)(\n    fieldName !== \"extensions\",\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?',\n      fieldName\n    )\n  );\n}\n\n// src/utils/internal/tryCatch.ts\nfunction tryCatch(fn, onException) {\n  try {\n    const result = fn();\n    return result;\n  } catch (error2) {\n    onException == null ? void 0 : onException(error2);\n  }\n}\n\n// src/handlers/GraphQLHandler.ts\nvar graphqlContext = {\n  ...defaultContext,\n  data,\n  extensions,\n  errors,\n  cookie,\n  field\n};\nfunction isDocumentNode(value) {\n  if (value == null) {\n    return false;\n  }\n  return typeof value === \"object\" && \"kind\" in value && \"definitions\" in value;\n}\nvar GraphQLRequest = class extends MockedRequest {\n  constructor(request, variables, operationName) {\n    super(request.url, {\n      ...request,\n      body: request[\"_body\"]\n    });\n    this.variables = variables;\n    this.operationName = operationName;\n  }\n};\nvar GraphQLHandler = class extends RequestHandler {\n  constructor(operationType, operationName, endpoint, resolver) {\n    let resolvedOperationName = operationName;\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName);\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`\n        );\n      }\n      if (!parsedNode.operationName) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`\n        );\n      }\n      resolvedOperationName = parsedNode.operationName;\n    }\n    const header = operationType === \"all\" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`;\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName\n      },\n      ctx: graphqlContext,\n      resolver\n    });\n    this.endpoint = endpoint;\n  }\n  parse(request) {\n    return tryCatch(\n      () => parseGraphQLRequest(request),\n      (error2) => console.error(error2.message)\n    );\n  }\n  getPublicRequest(request, parsedResult) {\n    var _a, _b;\n    return new GraphQLRequest(\n      request,\n      (_a = parsedResult == null ? void 0 : parsedResult.variables) != null ? _a : {},\n      (_b = parsedResult == null ? void 0 : parsedResult.operationName) != null ? _b : \"\"\n    );\n  }\n  predicate(request, parsedResult) {\n    if (!parsedResult) {\n      return false;\n    }\n    if (!parsedResult.operationName && this.info.operationType !== \"all\") {\n      const publicUrl = getPublicUrlFromRequest(request);\n      devUtils.warn(`Failed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation()\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation      `);\n      return false;\n    }\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint);\n    const hasMatchingOperationType = this.info.operationType === \"all\" || parsedResult.operationType === this.info.operationType;\n    const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(parsedResult.operationName || \"\") : parsedResult.operationName === this.info.operationName;\n    return hasMatchingUrl.matches && hasMatchingOperationType && hasMatchingOperationName;\n  }\n  log(request, response2, parsedRequest) {\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    const requestInfo = (parsedRequest == null ? void 0 : parsedRequest.operationName) ? `${parsedRequest == null ? void 0 : parsedRequest.operationType} ${parsedRequest == null ? void 0 : parsedRequest.operationName}` : `anonymous ${parsedRequest == null ? void 0 : parsedRequest.operationType}`;\n    console.groupCollapsed(\n      devUtils.formatMessage(\"%s %s (%c%s%c)\"),\n      getTimestamp(),\n      `${requestInfo}`,\n      `color:${statusColor}`,\n      `${response2.status} ${response2.statusText}`,\n      \"color:inherit\"\n    );\n    console.log(\"Request:\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response:\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/utils/request/onUnhandledRequest.ts\nvar MAX_MATCH_SCORE = 3;\nvar MAX_SUGGESTION_COUNT = 4;\nvar TYPE_MATCH_DELTA = 0.5;\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce(\n    (groups, handler) => {\n      if (handler instanceof RestHandler) {\n        groups.rest.push(handler);\n      }\n      if (handler instanceof GraphQLHandler) {\n        groups.graphql.push(handler);\n      }\n      return groups;\n    },\n    {\n      rest: [],\n      graphql: []\n    }\n  );\n}\nfunction getRestHandlerScore() {\n  return (request, handler) => {\n    const { path, method } = handler.info;\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n    const hasSameMethod = isStringEqual(request.method, method);\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    const score = (0, import_js_levenshtein.default)(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === \"undefined\") {\n      return Infinity;\n    }\n    const { operationType, operationName } = handler.info;\n    if (typeof operationName !== \"string\") {\n      return Infinity;\n    }\n    const hasSameOperationType = parsedQuery.operationType === operationType;\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    const score = (0, import_js_levenshtein.default)(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\nfunction getSuggestedHandler(request, handlers, getScore) {\n  const suggestedHandlers = handlers.reduce((suggestions, handler) => {\n    const score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort(([leftScore], [rightScore]) => leftScore - rightScore).filter(([score]) => score <= MAX_MATCH_SCORE).slice(0, MAX_SUGGESTION_COUNT).map(([, handler]) => handler);\n  return suggestedHandlers;\n}\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return `Did you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `  \\u2022 ${handler.info.header}`).join(\"\\n\")}`;\n  }\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`;\n}\nfunction onUnhandledRequest(request, handlers, strategy = \"warn\") {\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));\n  function generateHandlerSuggestion() {\n    const handlerGroups = groupHandlersByType(handlers);\n    const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n    const suggestedHandlers = getSuggestedHandler(\n      request,\n      relevantHandlers,\n      parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore()\n    );\n    return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : \"\";\n  }\n  function generateUnhandledRequestMessage() {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;\n    const handlerSuggestion = generateHandlerSuggestion();\n    const messageTemplate = [\n      `captured a request without a matching request handler:`,\n      `  \\u2022 ${requestHeader}`,\n      handlerSuggestion,\n      `If you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks`\n    ].filter(Boolean);\n    return messageTemplate.join(\"\\n\\n\");\n  }\n  function applyStrategy(strategy2) {\n    const message = generateUnhandledRequestMessage();\n    switch (strategy2) {\n      case \"error\": {\n        devUtils.error(\"Error: %s\", message);\n        throw new Error(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'\n          )\n        );\n      }\n      case \"warn\": {\n        devUtils.warn(\"Warning: %s\", message);\n        break;\n      }\n      case \"bypass\":\n        break;\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy2\n          )\n        );\n    }\n  }\n  if (typeof strategy === \"function\") {\n    strategy(request, {\n      warning: applyStrategy.bind(null, \"warn\"),\n      error: applyStrategy.bind(null, \"error\")\n    });\n    return;\n  }\n  applyStrategy(strategy);\n}\n\n// src/utils/request/readResponseCookies.ts\nvar import_cookies2 = __webpack_require__(/*! @mswjs/cookies */ \"(rsc)/../../node_modules/@mswjs/cookies/lib/index.js\");\nfunction readResponseCookies(request, response2) {\n  import_cookies2.store.add({ ...request, url: request.url.toString() }, response2);\n  import_cookies2.store.persist();\n}\n\n// src/utils/handleRequest.ts\nasync function handleRequest(request, handlers, options, emitter, handleRequestOptions) {\n  var _a, _b, _c, _d, _e, _f;\n  emitter.emit(\"request:start\", request);\n  if (request.headers.get(\"x-msw-bypass\") === \"true\") {\n    emitter.emit(\"request:end\", request);\n    (_a = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _a.call(handleRequestOptions, request);\n    return;\n  }\n  const [lookupError, lookupResult] = await (0, import_until2.until)(() => {\n    return getResponse(\n      request,\n      handlers,\n      handleRequestOptions == null ? void 0 : handleRequestOptions.resolutionContext\n    );\n  });\n  if (lookupError) {\n    emitter.emit(\"unhandledException\", lookupError, request);\n    throw lookupError;\n  }\n  const { handler, response: response2 } = lookupResult;\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n    emitter.emit(\"request:unhandled\", request);\n    emitter.emit(\"request:end\", request);\n    (_b = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _b.call(handleRequestOptions, request);\n    return;\n  }\n  if (!response2) {\n    devUtils.warn(\n      `Expected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\n\n  \\u2022 %s\n    %s`,\n      response2,\n      handler.info.header,\n      handler.info.callFrame\n    );\n    emitter.emit(\"request:end\", request);\n    (_c = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _c.call(handleRequestOptions, request);\n    return;\n  }\n  if (response2.passthrough) {\n    emitter.emit(\"request:end\", request);\n    (_d = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _d.call(handleRequestOptions, request);\n    return;\n  }\n  readResponseCookies(request, response2);\n  emitter.emit(\"request:match\", request);\n  const requiredLookupResult = lookupResult;\n  const transformedResponse = ((_e = handleRequestOptions == null ? void 0 : handleRequestOptions.transformResponse) == null ? void 0 : _e.call(handleRequestOptions, response2)) || response2;\n  (_f = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponse) == null ? void 0 : _f.call(\n    handleRequestOptions,\n    transformedResponse,\n    requiredLookupResult\n  );\n  emitter.emit(\"request:end\", request);\n  return transformedResponse;\n}\n\n// src/utils/logging/serializeResponse.ts\nvar import_headers_polyfill9 = __webpack_require__(/*! headers-polyfill */ \"(rsc)/../../node_modules/headers-polyfill/lib/index.js\");\nasync function serializeResponse(response2) {\n  return {\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: (0, import_headers_polyfill9.flattenHeadersObject)((0, import_headers_polyfill9.headersToObject)(response2.headers)),\n    body: await response2.clone().text()\n  };\n}\n\n// src/setupWorker/start/createRequestListener.ts\nvar createRequestListener = (context, options) => {\n  return async (event, message) => {\n    var _a;\n    const messageChannel = new WorkerChannel(event.ports[0]);\n    const request = parseWorkerRequest(message.payload);\n    try {\n      await handleRequest(\n        request,\n        context.requestHandlers,\n        options,\n        context.emitter,\n        {\n          transformResponse,\n          onPassthroughResponse() {\n            messageChannel.postMessage(\"NOT_FOUND\");\n          },\n          async onMockedResponse(response2, { handler, publicRequest, parsedRequest }) {\n            if (response2.body instanceof ReadableStream) {\n              throw new Error(\n                devUtils.formatMessage(\n                  'Failed to construct a mocked response with a \"ReadableStream\" body: mocked streams are not supported. Follow https://github.com/mswjs/msw/issues/1336 for more details.'\n                )\n              );\n            }\n            const responseInstance = new Response(response2.body, response2);\n            const responseForLogs = responseInstance.clone();\n            const responseBodyBuffer = await responseInstance.arrayBuffer();\n            const responseBody = response2.body == null ? null : responseBodyBuffer;\n            messageChannel.postMessage(\n              \"MOCK_RESPONSE\",\n              {\n                ...response2,\n                body: responseBody\n              },\n              [responseBodyBuffer]\n            );\n            if (!options.quiet) {\n              context.emitter.once(\"response:mocked\", async () => {\n                handler.log(\n                  publicRequest,\n                  await serializeResponse(responseForLogs),\n                  parsedRequest\n                );\n              });\n            }\n          }\n        }\n      );\n    } catch (error2) {\n      if (error2 instanceof NetworkError) {\n        messageChannel.postMessage(\"NETWORK_ERROR\", {\n          name: error2.name,\n          message: error2.message\n        });\n        return;\n      }\n      if (error2 instanceof Error) {\n        devUtils.error(\n          `Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`,\n          request.method,\n          request.url,\n          (_a = error2.stack) != null ? _a : error2\n        );\n        messageChannel.postMessage(\"MOCK_RESPONSE\", {\n          status: 500,\n          statusText: \"Request Handler Error\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({\n            name: error2.name,\n            message: error2.message,\n            stack: error2.stack\n          })\n        });\n      }\n    }\n  };\n};\nfunction transformResponse(response2) {\n  return {\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: response2.headers.all(),\n    body: response2.body,\n    delay: response2.delay\n  };\n}\n\n// src/utils/internal/requestIntegrityCheck.ts\nasync function requestIntegrityCheck(context, serviceWorker) {\n  context.workerChannel.send(\"INTEGRITY_CHECK_REQUEST\");\n  const { payload: actualChecksum } = await context.events.once(\n    \"INTEGRITY_CHECK_RESPONSE\"\n  );\n  if (actualChecksum !== \"3d6b9f06410d179a7f7404d4bf4c3c70\") {\n    throw new Error(\n      `Currently active Service Worker (${actualChecksum}) is behind the latest published one (${\"3d6b9f06410d179a7f7404d4bf4c3c70\"}).`\n    );\n  }\n  return serviceWorker;\n}\n\n// src/utils/deferNetworkRequestsUntil.ts\nvar import_until3 = __webpack_require__(/*! @open-draft/until */ \"(rsc)/../../node_modules/@open-draft/until/lib/index.js\");\nfunction deferNetworkRequestsUntil(predicatePromise) {\n  const originalXhrSend = window.XMLHttpRequest.prototype.send;\n  window.XMLHttpRequest.prototype.send = function(...args) {\n    (0, import_until3.until)(() => predicatePromise).then(() => {\n      window.XMLHttpRequest.prototype.send = originalXhrSend;\n      this.send(...args);\n    });\n  };\n  const originalFetch = window.fetch;\n  window.fetch = async (...args) => {\n    await (0, import_until3.until)(() => predicatePromise);\n    window.fetch = originalFetch;\n    return window.fetch(...args);\n  };\n}\n\n// src/setupWorker/start/createResponseListener.ts\nfunction createResponseListener(context) {\n  return (_, message) => {\n    var _a;\n    const { payload: responseJson } = message;\n    if ((_a = responseJson.type) == null ? void 0 : _a.includes(\"opaque\")) {\n      return;\n    }\n    const response2 = new Response(responseJson.body || null, responseJson);\n    const isMockedResponse = response2.headers.get(\"x-powered-by\") === \"msw\";\n    if (isMockedResponse) {\n      context.emitter.emit(\"response:mocked\", response2, responseJson.requestId);\n    } else {\n      context.emitter.emit(\"response:bypass\", response2, responseJson.requestId);\n    }\n  };\n}\n\n// src/setupWorker/start/utils/validateWorkerScope.ts\nfunction validateWorkerScope(registration, options) {\n  if (!(options == null ? void 0 : options.quiet) && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(\n      `Cannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.`\n    );\n  }\n}\n\n// src/setupWorker/start/createStartHandler.ts\nvar createStartHandler = (context) => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      context.events.removeAllListeners();\n      context.workerChannel.on(\n        \"REQUEST\",\n        createRequestListener(context, options)\n      );\n      context.workerChannel.on(\"RESPONSE\", createResponseListener(context));\n      const instance = await getWorkerInstance(\n        options.serviceWorker.url,\n        options.serviceWorker.options,\n        options.findWorker\n      );\n      const [worker, registration] = instance;\n      if (!worker) {\n        const missingWorkerMessage = (customOptions == null ? void 0 : customOptions.findWorker) ? devUtils.formatMessage(\n          `Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`,\n          options.serviceWorker.url\n        ) : devUtils.formatMessage(\n          `Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,\n          options.serviceWorker.url,\n          location.host\n        );\n        throw new Error(missingWorkerMessage);\n      }\n      context.worker = worker;\n      context.registration = registration;\n      context.events.addListener(window, \"beforeunload\", () => {\n        if (worker.state !== \"redundant\") {\n          context.workerChannel.send(\"CLIENT_CLOSED\");\n        }\n        window.clearInterval(context.keepAliveInterval);\n      });\n      const [integrityError] = await (0, import_until4.until)(\n        () => requestIntegrityCheck(context, worker)\n      );\n      if (integrityError) {\n        devUtils.error(`Detected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues      `);\n      }\n      context.keepAliveInterval = window.setInterval(\n        () => context.workerChannel.send(\"KEEPALIVE_REQUEST\"),\n        5e3\n      );\n      validateWorkerScope(registration, context.startOptions);\n      return registration;\n    };\n    const workerRegistration = startWorkerInstance().then(\n      async (registration) => {\n        const pendingInstance = registration.installing || registration.waiting;\n        if (pendingInstance) {\n          await new Promise((resolve) => {\n            pendingInstance.addEventListener(\"statechange\", () => {\n              if (pendingInstance.state === \"activated\") {\n                return resolve();\n              }\n            });\n          });\n        }\n        await enableMocking(context, options).catch((error2) => {\n          throw new Error(`Failed to enable mocking: ${error2 == null ? void 0 : error2.message}`);\n        });\n        return registration;\n      }\n    );\n    if (options.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration);\n    }\n    return workerRegistration;\n  };\n};\n\n// src/setupWorker/stop/utils/printStopMessage.ts\nfunction printStopMessage(args = {}) {\n  if (args.quiet) {\n    return;\n  }\n  console.log(\n    `%c${devUtils.formatMessage(\"Mocking disabled.\")}`,\n    \"color:orangered;font-weight:bold;\"\n  );\n}\n\n// src/setupWorker/stop/createStop.ts\nvar createStop = (context) => {\n  return function stop() {\n    var _a;\n    if (!context.isMockingEnabled) {\n      devUtils.warn(\n        'Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.'\n      );\n      return;\n    }\n    context.workerChannel.send(\"MOCK_DEACTIVATE\");\n    context.isMockingEnabled = false;\n    window.clearInterval(context.keepAliveInterval);\n    printStopMessage({ quiet: (_a = context.startOptions) == null ? void 0 : _a.quiet });\n  };\n};\n\n// src/setupWorker/start/utils/prepareStartHandler.ts\nvar DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: \"/mockServiceWorker.js\",\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: \"warn\",\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl;\n  }\n};\n\n// src/setupWorker/start/createFallbackRequestListener.ts\nvar import_interceptors3 = __webpack_require__(/*! @mswjs/interceptors */ \"(rsc)/../../node_modules/@mswjs/interceptors/lib/index.js\");\nvar import_fetch3 = __webpack_require__(/*! @mswjs/interceptors/lib/interceptors/fetch */ \"(rsc)/../../node_modules/@mswjs/interceptors/lib/interceptors/fetch/index.js\");\nvar import_XMLHttpRequest = __webpack_require__(/*! @mswjs/interceptors/lib/interceptors/XMLHttpRequest */ \"(rsc)/../../node_modules/@mswjs/interceptors/lib/interceptors/XMLHttpRequest/index.js\");\n\n// src/utils/request/createResponseFromIsomorphicResponse.ts\nfunction createResponseFromIsomorphicResponse(response2) {\n  return new Response(response2.body, {\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: response2.headers\n  });\n}\n\n// src/setupWorker/start/createFallbackRequestListener.ts\nfunction createFallbackRequestListener(context, options) {\n  const interceptor = new import_interceptors3.BatchInterceptor({\n    name: \"fallback\",\n    interceptors: [new import_fetch3.FetchInterceptor(), new import_XMLHttpRequest.XMLHttpRequestInterceptor()]\n  });\n  interceptor.on(\"request\", async (request) => {\n    const mockedRequest = new MockedRequest(request.url, {\n      ...request,\n      body: await request.arrayBuffer()\n    });\n    const response2 = await handleRequest(\n      mockedRequest,\n      context.requestHandlers,\n      options,\n      context.emitter,\n      {\n        transformResponse(response3) {\n          return {\n            status: response3.status,\n            statusText: response3.statusText,\n            headers: response3.headers.all(),\n            body: response3.body,\n            delay: response3.delay\n          };\n        },\n        onMockedResponse(_, { handler, publicRequest, parsedRequest }) {\n          if (!options.quiet) {\n            context.emitter.once(\"response:mocked\", async (response3) => {\n              handler.log(\n                publicRequest,\n                await serializeResponse(response3),\n                parsedRequest\n              );\n            });\n          }\n        }\n      }\n    );\n    if (response2) {\n      request.respondWith(response2);\n    }\n  });\n  interceptor.on(\"response\", (request, response2) => {\n    if (!request.id) {\n      return;\n    }\n    const browserResponse = createResponseFromIsomorphicResponse(response2);\n    if (response2.headers.get(\"x-powered-by\") === \"msw\") {\n      context.emitter.emit(\"response:mocked\", browserResponse, request.id);\n    } else {\n      context.emitter.emit(\"response:bypass\", browserResponse, request.id);\n    }\n  });\n  interceptor.apply();\n  return interceptor;\n}\n\n// src/setupWorker/start/createFallbackStart.ts\nfunction createFallbackStart(context) {\n  return async function start(options) {\n    context.fallbackInterceptor = createFallbackRequestListener(\n      context,\n      options\n    );\n    printStartMessage({\n      message: \"Mocking enabled (fallback mode).\",\n      quiet: options.quiet\n    });\n    return void 0;\n  };\n}\n\n// src/setupWorker/stop/createFallbackStop.ts\nfunction createFallbackStop(context) {\n  return function stop() {\n    var _a, _b;\n    (_a = context.fallbackInterceptor) == null ? void 0 : _a.dispose();\n    printStopMessage({ quiet: (_b = context.startOptions) == null ? void 0 : _b.quiet });\n  };\n}\n\n// src/SetupApi.ts\nvar import_outvariant4 = __webpack_require__(/*! outvariant */ \"(rsc)/../../node_modules/outvariant/lib/index.js\");\nvar import_strict_event_emitter = __webpack_require__(/*! strict-event-emitter */ \"(rsc)/../../node_modules/strict-event-emitter/lib/index.js\");\n\n// src/utils/internal/pipeEvents.ts\nfunction pipeEvents(source, destination) {\n  const rawEmit = source.emit;\n  if (rawEmit._isPiped) {\n    return;\n  }\n  source.emit = function(event, ...data2) {\n    destination.emit(event, ...data2);\n    return rawEmit.call(this, event, ...data2);\n  };\n  source.emit._isPiped = true;\n}\n\n// src/utils/internal/toReadonlyArray.ts\nfunction toReadonlyArray(source) {\n  const clone = [...source];\n  Object.freeze(clone);\n  return clone;\n}\n\n// src/SetupApi.ts\nvar SetupApi = class {\n  constructor(...initialHandlers) {\n    this.validateHandlers(...initialHandlers);\n    this.initialHandlers = toReadonlyArray(initialHandlers);\n    this.currentHandlers = [...initialHandlers];\n    this.emitter = new import_strict_event_emitter.Emitter();\n    this.publicEmitter = new import_strict_event_emitter.Emitter();\n    pipeEvents(this.emitter, this.publicEmitter);\n    this.events = this.createLifeCycleEvents();\n  }\n  validateHandlers(...handlers) {\n    for (const handler of handlers) {\n      (0, import_outvariant4.invariant)(\n        !Array.isArray(handler),\n        devUtils.formatMessage(\n          'Failed to construct \"%s\" given an Array of request handlers. Make sure you spread the request handlers when calling the respective setup function.'\n        ),\n        this.constructor.name\n      );\n    }\n  }\n  dispose() {\n    this.emitter.removeAllListeners();\n    this.publicEmitter.removeAllListeners();\n  }\n  use(...runtimeHandlers) {\n    this.currentHandlers.unshift(...runtimeHandlers);\n  }\n  restoreHandlers() {\n    this.currentHandlers.forEach((handler) => {\n      handler.markAsSkipped(false);\n    });\n  }\n  resetHandlers(...nextHandlers) {\n    this.currentHandlers = nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers];\n  }\n  listHandlers() {\n    return toReadonlyArray(this.currentHandlers);\n  }\n  createLifeCycleEvents() {\n    return {\n      on: (...args) => {\n        return this.publicEmitter.on(...args);\n      },\n      removeListener: (...args) => {\n        return this.publicEmitter.removeListener(...args);\n      },\n      removeAllListeners: (...args) => {\n        return this.publicEmitter.removeAllListeners(...args);\n      }\n    };\n  }\n};\n\n// src/setupWorker/setupWorker.ts\nvar SetupWorkerApi = class extends SetupApi {\n  constructor(...handlers) {\n    super(...handlers);\n    this.startHandler = null;\n    this.stopHandler = null;\n    (0, import_outvariant5.invariant)(\n      !(0, import_is_node_process3.isNodeProcess)(),\n      devUtils.formatMessage(\n        \"Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.\"\n      )\n    );\n    this.listeners = [];\n    this.context = this.createWorkerContext();\n  }\n  createWorkerContext() {\n    const context = {\n      isMockingEnabled: false,\n      startOptions: null,\n      worker: null,\n      registration: null,\n      requestHandlers: this.currentHandlers,\n      emitter: this.emitter,\n      workerChannel: {\n        on: (eventType, callback) => {\n          this.context.events.addListener(\n            navigator.serviceWorker,\n            \"message\",\n            (event) => {\n              if (event.source !== this.context.worker) {\n                return;\n              }\n              const message = event.data;\n              if (!message) {\n                return;\n              }\n              if (message.type === eventType) {\n                callback(event, message);\n              }\n            }\n          );\n        },\n        send: (type) => {\n          var _a;\n          (_a = this.context.worker) == null ? void 0 : _a.postMessage(type);\n        }\n      },\n      events: {\n        addListener: (target, eventType, callback) => {\n          target.addEventListener(eventType, callback);\n          this.listeners.push({ eventType, target, callback });\n          return () => {\n            target.removeEventListener(eventType, callback);\n          };\n        },\n        removeAllListeners: () => {\n          for (const { target, eventType, callback } of this.listeners) {\n            target.removeEventListener(eventType, callback);\n          }\n          this.listeners = [];\n        },\n        once: (eventType) => {\n          const bindings = [];\n          return new Promise((resolve, reject) => {\n            const handleIncomingMessage = (event) => {\n              try {\n                const message = event.data;\n                if (message.type === eventType) {\n                  resolve(message);\n                }\n              } catch (error2) {\n                reject(error2);\n              }\n            };\n            bindings.push(\n              this.context.events.addListener(\n                navigator.serviceWorker,\n                \"message\",\n                handleIncomingMessage\n              ),\n              this.context.events.addListener(\n                navigator.serviceWorker,\n                \"messageerror\",\n                reject\n              )\n            );\n          }).finally(() => {\n            bindings.forEach((unbind) => unbind());\n          });\n        }\n      },\n      useFallbackMode: !(\"serviceWorker\" in navigator) || location.protocol === \"file:\"\n    };\n    Object.defineProperties(context, {\n      requestHandlers: {\n        get: () => this.currentHandlers\n      }\n    });\n    this.startHandler = context.useFallbackMode ? createFallbackStart(context) : createStartHandler(context);\n    this.stopHandler = context.useFallbackMode ? createFallbackStop(context) : createStop(context);\n    return context;\n  }\n  async start(options = {}) {\n    this.context.startOptions = mergeRight(\n      DEFAULT_START_OPTIONS,\n      options\n    );\n    return await this.startHandler(this.context.startOptions, options);\n  }\n  printHandlers() {\n    const handlers = this.listHandlers();\n    handlers.forEach((handler) => {\n      const { header, callFrame } = handler.info;\n      const pragma = handler.info.hasOwnProperty(\"operationType\") ? \"[graphql]\" : \"[rest]\";\n      console.groupCollapsed(`${pragma} ${header}`);\n      if (callFrame) {\n        console.log(`Declaration: ${callFrame}`);\n      }\n      console.log(\"Handler:\", handler);\n      console.groupEnd();\n    });\n  }\n  stop() {\n    super.dispose();\n    this.context.events.removeAllListeners();\n    this.context.emitter.removeAllListeners();\n    this.stopHandler();\n  }\n};\nfunction setupWorker(...handlers) {\n  return new SetupWorkerApi(...handlers);\n}\n\n// src/rest.ts\nfunction createRestHandler(method) {\n  return (path, resolver) => {\n    return new RestHandler(method, path, resolver);\n  };\n}\nvar rest = {\n  all: createRestHandler(/.+/),\n  head: createRestHandler(\"HEAD\" /* HEAD */),\n  get: createRestHandler(\"GET\" /* GET */),\n  post: createRestHandler(\"POST\" /* POST */),\n  put: createRestHandler(\"PUT\" /* PUT */),\n  delete: createRestHandler(\"DELETE\" /* DELETE */),\n  patch: createRestHandler(\"PATCH\" /* PATCH */),\n  options: createRestHandler(\"OPTIONS\" /* OPTIONS */)\n};\n\n// src/graphql.ts\nfunction createScopedGraphQLHandler(operationType, url) {\n  return (operationName, resolver) => {\n    return new GraphQLHandler(\n      operationType,\n      operationName,\n      url,\n      resolver\n    );\n  };\n}\nfunction createGraphQLOperationHandler(url) {\n  return (resolver) => {\n    return new GraphQLHandler(\n      \"all\",\n      new RegExp(\".*\"),\n      url,\n      resolver\n    );\n  };\n}\nvar standardGraphQLHandlers = {\n  operation: createGraphQLOperationHandler(\"*\"),\n  query: createScopedGraphQLHandler(\"query\", \"*\"),\n  mutation: createScopedGraphQLHandler(\"mutation\", \"*\")\n};\nfunction createGraphQLLink(url) {\n  return {\n    operation: createGraphQLOperationHandler(url),\n    query: createScopedGraphQLHandler(\"query\", url),\n    mutation: createScopedGraphQLHandler(\"mutation\", url)\n  };\n}\nvar graphql = {\n  ...standardGraphQLHandlers,\n  link: createGraphQLLink\n};\n\n// src/index.ts\ncheckGlobals();\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL21zdy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkcseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixtQkFBTyxDQUFDLGdGQUFrQjtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQXNCTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9tc3cvbGliL2luZGV4LmpzP2QxYTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgc3JjX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNyY19leHBvcnRzLCB7XG4gIEdyYXBoUUxIYW5kbGVyOiAoKSA9PiBHcmFwaFFMSGFuZGxlcixcbiAgTW9ja2VkUmVxdWVzdDogKCkgPT4gTW9ja2VkUmVxdWVzdCxcbiAgUkVTVE1ldGhvZHM6ICgpID0+IFJFU1RNZXRob2RzLFxuICBSZXF1ZXN0SGFuZGxlcjogKCkgPT4gUmVxdWVzdEhhbmRsZXIsXG4gIFJlc3RIYW5kbGVyOiAoKSA9PiBSZXN0SGFuZGxlcixcbiAgU2V0dXBBcGk6ICgpID0+IFNldHVwQXBpLFxuICBTZXR1cFdvcmtlckFwaTogKCkgPT4gU2V0dXBXb3JrZXJBcGksXG4gIGNsZWFuVXJsOiAoKSA9PiBjbGVhblVybCxcbiAgY29tcG9zZTogKCkgPT4gY29tcG9zZSxcbiAgY29udGV4dDogKCkgPT4gY29udGV4dF9leHBvcnRzLFxuICBjcmVhdGVSZXNwb25zZUNvbXBvc2l0aW9uOiAoKSA9PiBjcmVhdGVSZXNwb25zZUNvbXBvc2l0aW9uLFxuICBkZWZhdWx0Q29udGV4dDogKCkgPT4gZGVmYXVsdENvbnRleHQsXG4gIGRlZmF1bHRSZXNwb25zZTogKCkgPT4gZGVmYXVsdFJlc3BvbnNlLFxuICBncmFwaHFsOiAoKSA9PiBncmFwaHFsLFxuICBncmFwaHFsQ29udGV4dDogKCkgPT4gZ3JhcGhxbENvbnRleHQsXG4gIGhhbmRsZVJlcXVlc3Q6ICgpID0+IGhhbmRsZVJlcXVlc3QsXG4gIG1hdGNoUmVxdWVzdFVybDogKCkgPT4gbWF0Y2hSZXF1ZXN0VXJsLFxuICByZXNwb25zZTogKCkgPT4gcmVzcG9uc2UsXG4gIHJlc3Q6ICgpID0+IHJlc3QsXG4gIHJlc3RDb250ZXh0OiAoKSA9PiByZXN0Q29udGV4dCxcbiAgc2V0dXBXb3JrZXI6ICgpID0+IHNldHVwV29ya2VyXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHNyY19leHBvcnRzKTtcblxuLy8gc3JjL2NvbnRleHQvaW5kZXgudHNcbnZhciBjb250ZXh0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNvbnRleHRfZXhwb3J0cywge1xuICBib2R5OiAoKSA9PiBib2R5LFxuICBjb29raWU6ICgpID0+IGNvb2tpZSxcbiAgZGF0YTogKCkgPT4gZGF0YSxcbiAgZGVsYXk6ICgpID0+IGRlbGF5LFxuICBlcnJvcnM6ICgpID0+IGVycm9ycyxcbiAgZXh0ZW5zaW9uczogKCkgPT4gZXh0ZW5zaW9ucyxcbiAgZmV0Y2g6ICgpID0+IGZldGNoLFxuICBqc29uOiAoKSA9PiBqc29uLFxuICBzZXQ6ICgpID0+IHNldCxcbiAgc3RhdHVzOiAoKSA9PiBzdGF0dXMsXG4gIHRleHQ6ICgpID0+IHRleHQsXG4gIHhtbDogKCkgPT4geG1sXG59KTtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3N0YXR1c2VzQDIuMC4xL25vZGVfbW9kdWxlcy9zdGF0dXNlcy9jb2Rlcy5qc29uXG52YXIgY29kZXNfZGVmYXVsdCA9IHtcbiAgXCIxMDBcIjogXCJDb250aW51ZVwiLFxuICBcIjEwMVwiOiBcIlN3aXRjaGluZyBQcm90b2NvbHNcIixcbiAgXCIxMDJcIjogXCJQcm9jZXNzaW5nXCIsXG4gIFwiMTAzXCI6IFwiRWFybHkgSGludHNcIixcbiAgXCIyMDBcIjogXCJPS1wiLFxuICBcIjIwMVwiOiBcIkNyZWF0ZWRcIixcbiAgXCIyMDJcIjogXCJBY2NlcHRlZFwiLFxuICBcIjIwM1wiOiBcIk5vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uXCIsXG4gIFwiMjA0XCI6IFwiTm8gQ29udGVudFwiLFxuICBcIjIwNVwiOiBcIlJlc2V0IENvbnRlbnRcIixcbiAgXCIyMDZcIjogXCJQYXJ0aWFsIENvbnRlbnRcIixcbiAgXCIyMDdcIjogXCJNdWx0aS1TdGF0dXNcIixcbiAgXCIyMDhcIjogXCJBbHJlYWR5IFJlcG9ydGVkXCIsXG4gIFwiMjI2XCI6IFwiSU0gVXNlZFwiLFxuICBcIjMwMFwiOiBcIk11bHRpcGxlIENob2ljZXNcIixcbiAgXCIzMDFcIjogXCJNb3ZlZCBQZXJtYW5lbnRseVwiLFxuICBcIjMwMlwiOiBcIkZvdW5kXCIsXG4gIFwiMzAzXCI6IFwiU2VlIE90aGVyXCIsXG4gIFwiMzA0XCI6IFwiTm90IE1vZGlmaWVkXCIsXG4gIFwiMzA1XCI6IFwiVXNlIFByb3h5XCIsXG4gIFwiMzA3XCI6IFwiVGVtcG9yYXJ5IFJlZGlyZWN0XCIsXG4gIFwiMzA4XCI6IFwiUGVybWFuZW50IFJlZGlyZWN0XCIsXG4gIFwiNDAwXCI6IFwiQmFkIFJlcXVlc3RcIixcbiAgXCI0MDFcIjogXCJVbmF1dGhvcml6ZWRcIixcbiAgXCI0MDJcIjogXCJQYXltZW50IFJlcXVpcmVkXCIsXG4gIFwiNDAzXCI6IFwiRm9yYmlkZGVuXCIsXG4gIFwiNDA0XCI6IFwiTm90IEZvdW5kXCIsXG4gIFwiNDA1XCI6IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsXG4gIFwiNDA2XCI6IFwiTm90IEFjY2VwdGFibGVcIixcbiAgXCI0MDdcIjogXCJQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQwOFwiOiBcIlJlcXVlc3QgVGltZW91dFwiLFxuICBcIjQwOVwiOiBcIkNvbmZsaWN0XCIsXG4gIFwiNDEwXCI6IFwiR29uZVwiLFxuICBcIjQxMVwiOiBcIkxlbmd0aCBSZXF1aXJlZFwiLFxuICBcIjQxMlwiOiBcIlByZWNvbmRpdGlvbiBGYWlsZWRcIixcbiAgXCI0MTNcIjogXCJQYXlsb2FkIFRvbyBMYXJnZVwiLFxuICBcIjQxNFwiOiBcIlVSSSBUb28gTG9uZ1wiLFxuICBcIjQxNVwiOiBcIlVuc3VwcG9ydGVkIE1lZGlhIFR5cGVcIixcbiAgXCI0MTZcIjogXCJSYW5nZSBOb3QgU2F0aXNmaWFibGVcIixcbiAgXCI0MTdcIjogXCJFeHBlY3RhdGlvbiBGYWlsZWRcIixcbiAgXCI0MThcIjogXCJJJ20gYSBUZWFwb3RcIixcbiAgXCI0MjFcIjogXCJNaXNkaXJlY3RlZCBSZXF1ZXN0XCIsXG4gIFwiNDIyXCI6IFwiVW5wcm9jZXNzYWJsZSBFbnRpdHlcIixcbiAgXCI0MjNcIjogXCJMb2NrZWRcIixcbiAgXCI0MjRcIjogXCJGYWlsZWQgRGVwZW5kZW5jeVwiLFxuICBcIjQyNVwiOiBcIlRvbyBFYXJseVwiLFxuICBcIjQyNlwiOiBcIlVwZ3JhZGUgUmVxdWlyZWRcIixcbiAgXCI0MjhcIjogXCJQcmVjb25kaXRpb24gUmVxdWlyZWRcIixcbiAgXCI0MjlcIjogXCJUb28gTWFueSBSZXF1ZXN0c1wiLFxuICBcIjQzMVwiOiBcIlJlcXVlc3QgSGVhZGVyIEZpZWxkcyBUb28gTGFyZ2VcIixcbiAgXCI0NTFcIjogXCJVbmF2YWlsYWJsZSBGb3IgTGVnYWwgUmVhc29uc1wiLFxuICBcIjUwMFwiOiBcIkludGVybmFsIFNlcnZlciBFcnJvclwiLFxuICBcIjUwMVwiOiBcIk5vdCBJbXBsZW1lbnRlZFwiLFxuICBcIjUwMlwiOiBcIkJhZCBHYXRld2F5XCIsXG4gIFwiNTAzXCI6IFwiU2VydmljZSBVbmF2YWlsYWJsZVwiLFxuICBcIjUwNFwiOiBcIkdhdGV3YXkgVGltZW91dFwiLFxuICBcIjUwNVwiOiBcIkhUVFAgVmVyc2lvbiBOb3QgU3VwcG9ydGVkXCIsXG4gIFwiNTA2XCI6IFwiVmFyaWFudCBBbHNvIE5lZ290aWF0ZXNcIixcbiAgXCI1MDdcIjogXCJJbnN1ZmZpY2llbnQgU3RvcmFnZVwiLFxuICBcIjUwOFwiOiBcIkxvb3AgRGV0ZWN0ZWRcIixcbiAgXCI1MDlcIjogXCJCYW5kd2lkdGggTGltaXQgRXhjZWVkZWRcIixcbiAgXCI1MTBcIjogXCJOb3QgRXh0ZW5kZWRcIixcbiAgXCI1MTFcIjogXCJOZXR3b3JrIEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXCJcbn07XG5cbi8vIHNyYy9jb250ZXh0L3N0YXR1cy50c1xudmFyIHN0YXR1cyA9IChzdGF0dXNDb2RlLCBzdGF0dXNUZXh0KSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgcmVzLnN0YXR1cyA9IHN0YXR1c0NvZGU7XG4gICAgcmVzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0IHx8IGNvZGVzX2RlZmF1bHRbU3RyaW5nKHN0YXR1c0NvZGUpXTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQvc2V0LnRzXG52YXIgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGwgPSByZXF1aXJlKFwiaGVhZGVycy1wb2x5ZmlsbFwiKTtcbmZ1bmN0aW9uIHNldCguLi5hcmdzKSB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgY29uc3QgW25hbWUsIHZhbHVlXSA9IGFyZ3M7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXMuaGVhZGVycy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gKDAsIGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsLm9iamVjdFRvSGVhZGVycykobmFtZSk7XG4gICAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlMiwgbmFtZTIpID0+IHtcbiAgICAgICAgcmVzLmhlYWRlcnMuYXBwZW5kKG5hbWUyLCB2YWx1ZTIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG59XG5cbi8vIHNyYy9jb250ZXh0L2Nvb2tpZS50c1xudmFyIGNvb2tpZVV0aWxzID0gX190b0VTTShyZXF1aXJlKFwiY29va2llXCIpKTtcbnZhciBjb29raWUgPSAobmFtZSwgdmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICBjb25zdCBzZXJpYWxpemVkQ29va2llID0gY29va2llVXRpbHMuc2VyaWFsaXplKG5hbWUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICByZXMuaGVhZGVycy5hcHBlbmQoXCJTZXQtQ29va2llXCIsIHNlcmlhbGl6ZWRDb29raWUpO1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGRvY3VtZW50LmNvb2tpZSA9IHNlcmlhbGl6ZWRDb29raWU7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dC9ib2R5LnRzXG52YXIgYm9keSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIHJlcy5ib2R5ID0gdmFsdWU7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9qc29uUGFyc2UudHNcbmZ1bmN0aW9uIGpzb25QYXJzZSh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvaXNPYmplY3QudHNcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9tZXJnZVJpZ2h0LnRzXG5mdW5jdGlvbiBtZXJnZVJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyaWdodCkucmVkdWNlKChyZXN1bHQsIFtrZXksIHJpZ2h0VmFsdWVdKSA9PiB7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gcmVzdWx0W2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGVmdFZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHJpZ2h0VmFsdWUpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGxlZnRWYWx1ZS5jb25jYXQocmlnaHRWYWx1ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QobGVmdFZhbHVlKSAmJiBpc09iamVjdChyaWdodFZhbHVlKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZVJpZ2h0KGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXN1bHRba2V5XSA9IHJpZ2h0VmFsdWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgT2JqZWN0LmFzc2lnbih7fSwgbGVmdCkpO1xufVxuXG4vLyBzcmMvY29udGV4dC9qc29uLnRzXG52YXIganNvbiA9IChib2R5MikgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIHJlcy5oZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgcmVzLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5Mik7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L2RhdGEudHNcbnZhciBkYXRhID0gKHBheWxvYWQpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICBjb25zdCBwcmV2Qm9keSA9IGpzb25QYXJzZShyZXMuYm9keSkgfHwge307XG4gICAgY29uc3QgbmV4dEJvZHkgPSBtZXJnZVJpZ2h0KHByZXZCb2R5LCB7IGRhdGE6IHBheWxvYWQgfSk7XG4gICAgcmV0dXJuIGpzb24obmV4dEJvZHkpKHJlcyk7XG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dC9leHRlbnNpb25zLnRzXG52YXIgZXh0ZW5zaW9ucyA9IChwYXlsb2FkKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgY29uc3QgcHJldkJvZHkgPSBqc29uUGFyc2UocmVzLmJvZHkpIHx8IHt9O1xuICAgIGNvbnN0IG5leHRCb2R5ID0gbWVyZ2VSaWdodChwcmV2Qm9keSwgeyBleHRlbnNpb25zOiBwYXlsb2FkIH0pO1xuICAgIHJldHVybiBqc29uKG5leHRCb2R5KShyZXMpO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQvZGVsYXkudHNcbnZhciBpbXBvcnRfaXNfbm9kZV9wcm9jZXNzID0gcmVxdWlyZShcImlzLW5vZGUtcHJvY2Vzc1wiKTtcbnZhciBTRVRfVElNRU9VVF9NQVhfQUxMT1dFRF9JTlQgPSAyMTQ3NDgzNjQ3O1xudmFyIE1JTl9TRVJWRVJfUkVTUE9OU0VfVElNRSA9IDEwMDtcbnZhciBNQVhfU0VSVkVSX1JFU1BPTlNFX1RJTUUgPSA0MDA7XG52YXIgTk9ERV9TRVJWRVJfUkVTUE9OU0VfVElNRSA9IDU7XG52YXIgZ2V0UmFuZG9tU2VydmVyUmVzcG9uc2VUaW1lID0gKCkgPT4ge1xuICBpZiAoKDAsIGltcG9ydF9pc19ub2RlX3Byb2Nlc3MuaXNOb2RlUHJvY2VzcykoKSkge1xuICAgIHJldHVybiBOT0RFX1NFUlZFUl9SRVNQT05TRV9USU1FO1xuICB9XG4gIHJldHVybiBNYXRoLmZsb29yKFxuICAgIE1hdGgucmFuZG9tKCkgKiAoTUFYX1NFUlZFUl9SRVNQT05TRV9USU1FIC0gTUlOX1NFUlZFUl9SRVNQT05TRV9USU1FKSArIE1JTl9TRVJWRVJfUkVTUE9OU0VfVElNRVxuICApO1xufTtcbnZhciBkZWxheSA9IChkdXJhdGlvbk9yTW9kZSkgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIGxldCBkZWxheVRpbWU7XG4gICAgaWYgKHR5cGVvZiBkdXJhdGlvbk9yTW9kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgc3dpdGNoIChkdXJhdGlvbk9yTW9kZSkge1xuICAgICAgICBjYXNlIFwiaW5maW5pdGVcIjoge1xuICAgICAgICAgIGRlbGF5VGltZSA9IFNFVF9USU1FT1VUX01BWF9BTExPV0VEX0lOVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicmVhbFwiOiB7XG4gICAgICAgICAgZGVsYXlUaW1lID0gZ2V0UmFuZG9tU2VydmVyUmVzcG9uc2VUaW1lKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZGVsYXkgYSByZXNwb25zZTogdW5rbm93biBkZWxheSBtb2RlIFwiJHtkdXJhdGlvbk9yTW9kZX1cIi4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UgcHJvdmlkZSBvbmUgb2YgdGhlIHN1cHBvcnRlZCBtb2RlcyAoXCJyZWFsXCIsIFwiaW5maW5pdGVcIikgb3IgYSBudW1iZXIgdG8gXCJjdHguZGVsYXlcIi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uT3JNb2RlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBkZWxheVRpbWUgPSBnZXRSYW5kb21TZXJ2ZXJSZXNwb25zZVRpbWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGR1cmF0aW9uT3JNb2RlID4gU0VUX1RJTUVPVVRfTUFYX0FMTE9XRURfSU5UKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRmFpbGVkIHRvIGRlbGF5IGEgcmVzcG9uc2U6IHByb3ZpZGVkIGRlbGF5IGR1cmF0aW9uICgke2R1cmF0aW9uT3JNb2RlfSkgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIGR1cmF0aW9uIGZvciBcInNldFRpbWVvdXRcIiAoJHtTRVRfVElNRU9VVF9NQVhfQUxMT1dFRF9JTlR9KS4gVGhpcyB3aWxsIGNhdXNlIHRoZSByZXNwb25zZSB0byBiZSByZXR1cm5lZCBpbW1lZGlhdGVseS4gUGxlYXNlIHVzZSBhIG51bWJlciB3aXRoaW4gdGhlIGFsbG93ZWQgcmFuZ2UgdG8gZGVsYXkgdGhlIHJlc3BvbnNlIGJ5IGV4YWN0IGR1cmF0aW9uLCBvciBjb25zaWRlciB0aGUgXCJpbmZpbml0ZVwiIGRlbGF5IG1vZGUgdG8gZGVsYXkgdGhlIHJlc3BvbnNlIGluZGVmaW5pdGVseS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWxheVRpbWUgPSBkdXJhdGlvbk9yTW9kZTtcbiAgICB9XG4gICAgcmVzLmRlbGF5ID0gZGVsYXlUaW1lO1xuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dC9lcnJvcnMudHNcbnZhciBlcnJvcnMgPSAoZXJyb3JzTGlzdCkgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIGlmIChlcnJvcnNMaXN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGNvbnN0IHByZXZCb2R5ID0ganNvblBhcnNlKHJlcy5ib2R5KSB8fCB7fTtcbiAgICBjb25zdCBuZXh0Qm9keSA9IG1lcmdlUmlnaHQocHJldkJvZHksIHsgZXJyb3JzOiBlcnJvcnNMaXN0IH0pO1xuICAgIHJldHVybiBqc29uKG5leHRCb2R5KShyZXMpO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQvZmV0Y2gudHNcbnZhciBpbXBvcnRfaXNfbm9kZV9wcm9jZXNzMiA9IHJlcXVpcmUoXCJpcy1ub2RlLXByb2Nlc3NcIik7XG52YXIgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGwyID0gcmVxdWlyZShcImhlYWRlcnMtcG9seWZpbGxcIik7XG52YXIgdXNlRmV0Y2ggPSAoMCwgaW1wb3J0X2lzX25vZGVfcHJvY2VzczIuaXNOb2RlUHJvY2VzcykoKSA/IChpbnB1dCwgaW5pdCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBfX3RvRVNNKHJlcXVpcmUoXCJub2RlLWZldGNoXCIpKSkudGhlbihcbiAgKHsgZGVmYXVsdDogbm9kZUZldGNoIH0pID0+IG5vZGVGZXRjaChpbnB1dCwgaW5pdClcbikgOiBnbG9iYWxUaGlzLmZldGNoO1xudmFyIGF1Z21lbnRSZXF1ZXN0SW5pdCA9IChyZXF1ZXN0SW5pdCkgPT4ge1xuICBjb25zdCBoZWFkZXJzID0gbmV3IGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsMi5IZWFkZXJzKHJlcXVlc3RJbml0LmhlYWRlcnMpO1xuICBoZWFkZXJzLnNldChcIngtbXN3LWJ5cGFzc1wiLCBcInRydWVcIik7XG4gIHJldHVybiB7XG4gICAgLi4ucmVxdWVzdEluaXQsXG4gICAgaGVhZGVyczogaGVhZGVycy5hbGwoKVxuICB9O1xufTtcbnZhciBjcmVhdGVGZXRjaFJlcXVlc3RQYXJhbWV0ZXJzID0gKGlucHV0KSA9PiB7XG4gIGNvbnN0IHsgYm9keTogYm9keTIsIG1ldGhvZCB9ID0gaW5wdXQ7XG4gIGNvbnN0IHJlcXVlc3RQYXJhbWV0ZXJzID0ge1xuICAgIC4uLmlucHV0LFxuICAgIGJvZHk6IHZvaWQgMFxuICB9O1xuICBpZiAoW1wiR0VUXCIsIFwiSEVBRFwiXS5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RQYXJhbWV0ZXJzO1xuICB9XG4gIGlmICh0eXBlb2YgYm9keTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGJvZHkyID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBib2R5MiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXF1ZXN0UGFyYW1ldGVycy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keTIpO1xuICB9IGVsc2Uge1xuICAgIHJlcXVlc3RQYXJhbWV0ZXJzLmJvZHkgPSBib2R5MjtcbiAgfVxuICByZXR1cm4gcmVxdWVzdFBhcmFtZXRlcnM7XG59O1xudmFyIGZldGNoID0gKGlucHV0LCByZXF1ZXN0SW5pdCA9IHt9KSA9PiB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdXNlRmV0Y2goaW5wdXQsIGF1Z21lbnRSZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCkpO1xuICB9XG4gIGNvbnN0IHJlcXVlc3RQYXJhbWV0ZXJzID0gY3JlYXRlRmV0Y2hSZXF1ZXN0UGFyYW1ldGVycyhpbnB1dCk7XG4gIGNvbnN0IGRlcml2ZWRSZXF1ZXN0SW5pdCA9IGF1Z21lbnRSZXF1ZXN0SW5pdChyZXF1ZXN0UGFyYW1ldGVycyk7XG4gIHJldHVybiB1c2VGZXRjaChpbnB1dC51cmwuaHJlZiwgZGVyaXZlZFJlcXVlc3RJbml0KTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L3RleHQudHNcbnZhciB0ZXh0ID0gKGJvZHkyKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgcmVzLmhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwidGV4dC9wbGFpblwiKTtcbiAgICByZXMuYm9keSA9IGJvZHkyO1xuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dC94bWwudHNcbnZhciB4bWwgPSAoYm9keTIpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICByZXMuaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJ0ZXh0L3htbFwiKTtcbiAgICByZXMuYm9keSA9IGJvZHkyO1xuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvY2hlY2tHbG9iYWxzLnRzXG52YXIgaW1wb3J0X291dHZhcmlhbnQyID0gcmVxdWlyZShcIm91dHZhcmlhbnRcIik7XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9kZXZVdGlscy50c1xudmFyIGltcG9ydF9vdXR2YXJpYW50ID0gcmVxdWlyZShcIm91dHZhcmlhbnRcIik7XG52YXIgTElCUkFSWV9QUkVGSVggPSBcIltNU1ddXCI7XG5mdW5jdGlvbiBmb3JtYXRNZXNzYWdlKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSB7XG4gIGNvbnN0IGludGVycG9sYXRlZE1lc3NhZ2UgPSAoMCwgaW1wb3J0X291dHZhcmlhbnQuZm9ybWF0KShtZXNzYWdlLCAuLi5wb3NpdGlvbmFscyk7XG4gIHJldHVybiBgJHtMSUJSQVJZX1BSRUZJWH0gJHtpbnRlcnBvbGF0ZWRNZXNzYWdlfWA7XG59XG5mdW5jdGlvbiB3YXJuKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSB7XG4gIGNvbnNvbGUud2Fybihmb3JtYXRNZXNzYWdlKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSk7XG59XG5mdW5jdGlvbiBlcnJvcihtZXNzYWdlLCAuLi5wb3NpdGlvbmFscykge1xuICBjb25zb2xlLmVycm9yKGZvcm1hdE1lc3NhZ2UobWVzc2FnZSwgLi4ucG9zaXRpb25hbHMpKTtcbn1cbnZhciBkZXZVdGlscyA9IHtcbiAgZm9ybWF0TWVzc2FnZSxcbiAgd2FybixcbiAgZXJyb3Jcbn07XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9jaGVja0dsb2JhbHMudHNcbmZ1bmN0aW9uIGNoZWNrR2xvYmFscygpIHtcbiAgKDAsIGltcG9ydF9vdXR2YXJpYW50Mi5pbnZhcmlhbnQpKFxuICAgIHR5cGVvZiBVUkwgIT09IFwidW5kZWZpbmVkXCIsXG4gICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgIGBHbG9iYWwgXCJVUkxcIiBjbGFzcyBpcyBub3QgZGVmaW5lZC4gVGhpcyBsaWtlbHkgbWVhbnMgdGhhdCB5b3UncmUgcnVubmluZyBNU1cgaW4gYW4gZW52aXJvbm1lbnQgdGhhdCBkb2Vzbid0IHN1cHBvcnQgYWxsIE5vZGUuanMgc3RhbmRhcmQgQVBJIChlLmcuIFJlYWN0IE5hdGl2ZSkuIElmIHRoYXQncyB0aGUgY2FzZSwgcGxlYXNlIHVzZSBhbiBhcHByb3ByaWF0ZSBwb2x5ZmlsbCBmb3IgdGhlIFwiVVJMXCIgY2xhc3MsIGxpa2UgXCJyZWFjdC1uYXRpdmUtdXJsLXBvbHlmaWxsXCIuYFxuICAgIClcbiAgKTtcbn1cblxuLy8gc3JjL3NldHVwV29ya2VyL3NldHVwV29ya2VyLnRzXG52YXIgaW1wb3J0X291dHZhcmlhbnQ1ID0gcmVxdWlyZShcIm91dHZhcmlhbnRcIik7XG52YXIgaW1wb3J0X2lzX25vZGVfcHJvY2VzczMgPSByZXF1aXJlKFwiaXMtbm9kZS1wcm9jZXNzXCIpO1xuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvY3JlYXRlU3RhcnRIYW5kbGVyLnRzXG52YXIgaW1wb3J0X3VudGlsNCA9IHJlcXVpcmUoXCJAb3Blbi1kcmFmdC91bnRpbFwiKTtcblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L3V0aWxzL2dldFdvcmtlckluc3RhbmNlLnRzXG52YXIgaW1wb3J0X3VudGlsID0gcmVxdWlyZShcIkBvcGVuLWRyYWZ0L3VudGlsXCIpO1xuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvdXRpbHMvZ2V0V29ya2VyQnlSZWdpc3RyYXRpb24udHNcbmZ1bmN0aW9uIGdldFdvcmtlckJ5UmVnaXN0cmF0aW9uKHJlZ2lzdHJhdGlvbiwgYWJzb2x1dGVXb3JrZXJVcmwsIGZpbmRXb3JrZXIpIHtcbiAgY29uc3QgYWxsU3RhdGVzID0gW1xuICAgIHJlZ2lzdHJhdGlvbi5hY3RpdmUsXG4gICAgcmVnaXN0cmF0aW9uLmluc3RhbGxpbmcsXG4gICAgcmVnaXN0cmF0aW9uLndhaXRpbmdcbiAgXTtcbiAgY29uc3QgcmVsZXZhbnRTdGF0ZXMgPSBhbGxTdGF0ZXMuZmlsdGVyKChzdGF0ZSkgPT4ge1xuICAgIHJldHVybiBzdGF0ZSAhPSBudWxsO1xuICB9KTtcbiAgY29uc3Qgd29ya2VyID0gcmVsZXZhbnRTdGF0ZXMuZmluZCgod29ya2VyMikgPT4ge1xuICAgIHJldHVybiBmaW5kV29ya2VyKHdvcmtlcjIuc2NyaXB0VVJMLCBhYnNvbHV0ZVdvcmtlclVybCk7XG4gIH0pO1xuICByZXR1cm4gd29ya2VyIHx8IG51bGw7XG59XG5cbi8vIHNyYy91dGlscy91cmwvZ2V0QWJzb2x1dGVXb3JrZXJVcmwudHNcbmZ1bmN0aW9uIGdldEFic29sdXRlV29ya2VyVXJsKHdvcmtlclVybCkge1xuICByZXR1cm4gbmV3IFVSTCh3b3JrZXJVcmwsIGxvY2F0aW9uLmhyZWYpLmhyZWY7XG59XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC91dGlscy9nZXRXb3JrZXJJbnN0YW5jZS50c1xudmFyIGdldFdvcmtlckluc3RhbmNlID0gYXN5bmMgKHVybCwgb3B0aW9ucyA9IHt9LCBmaW5kV29ya2VyKSA9PiB7XG4gIGNvbnN0IGFic29sdXRlV29ya2VyVXJsID0gZ2V0QWJzb2x1dGVXb3JrZXJVcmwodXJsKTtcbiAgY29uc3QgbW9ja1JlZ2lzdHJhdGlvbnMgPSBhd2FpdCBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5nZXRSZWdpc3RyYXRpb25zKCkudGhlbihcbiAgICAocmVnaXN0cmF0aW9ucykgPT4gcmVnaXN0cmF0aW9ucy5maWx0ZXIoXG4gICAgICAocmVnaXN0cmF0aW9uKSA9PiBnZXRXb3JrZXJCeVJlZ2lzdHJhdGlvbihyZWdpc3RyYXRpb24sIGFic29sdXRlV29ya2VyVXJsLCBmaW5kV29ya2VyKVxuICAgIClcbiAgKTtcbiAgaWYgKCFuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyICYmIG1vY2tSZWdpc3RyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgfVxuICBjb25zdCBbZXhpc3RpbmdSZWdpc3RyYXRpb25dID0gbW9ja1JlZ2lzdHJhdGlvbnM7XG4gIGlmIChleGlzdGluZ1JlZ2lzdHJhdGlvbikge1xuICAgIHJldHVybiBleGlzdGluZ1JlZ2lzdHJhdGlvbi51cGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGdldFdvcmtlckJ5UmVnaXN0cmF0aW9uKFxuICAgICAgICAgIGV4aXN0aW5nUmVnaXN0cmF0aW9uLFxuICAgICAgICAgIGFic29sdXRlV29ya2VyVXJsLFxuICAgICAgICAgIGZpbmRXb3JrZXJcbiAgICAgICAgKSxcbiAgICAgICAgZXhpc3RpbmdSZWdpc3RyYXRpb25cbiAgICAgIF07XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgW2Vycm9yMiwgaW5zdGFuY2VdID0gYXdhaXQgKDAsIGltcG9ydF91bnRpbC51bnRpbCkoXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVnaXN0cmF0aW9uID0gYXdhaXQgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIucmVnaXN0ZXIodXJsLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGdldFdvcmtlckJ5UmVnaXN0cmF0aW9uKHJlZ2lzdHJhdGlvbiwgYWJzb2x1dGVXb3JrZXJVcmwsIGZpbmRXb3JrZXIpLFxuICAgICAgICByZWdpc3RyYXRpb25cbiAgICAgIF07XG4gICAgfVxuICApO1xuICBpZiAoZXJyb3IyKSB7XG4gICAgY29uc3QgaXNXb3JrZXJNaXNzaW5nID0gZXJyb3IyLm1lc3NhZ2UuaW5jbHVkZXMoXCIoNDA0KVwiKTtcbiAgICBpZiAoaXNXb3JrZXJNaXNzaW5nKSB7XG4gICAgICBjb25zdCBzY29wZVVybCA9IG5ldyBVUkwoKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2NvcGUpIHx8IFwiL1wiLCBsb2NhdGlvbi5ocmVmKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShgRmFpbGVkIHRvIHJlZ2lzdGVyIGEgU2VydmljZSBXb3JrZXIgZm9yIHNjb3BlICgnJHtzY29wZVVybC5ocmVmfScpIHdpdGggc2NyaXB0ICgnJHthYnNvbHV0ZVdvcmtlclVybH0nKTogU2VydmljZSBXb3JrZXIgc2NyaXB0IGRvZXMgbm90IGV4aXN0IGF0IHRoZSBnaXZlbiBwYXRoLlxuXG5EaWQgeW91IGZvcmdldCB0byBydW4gXCJucHggbXN3IGluaXQgPFBVQkxJQ19ESVI+XCI/XG5cbkxlYXJuIG1vcmUgYWJvdXQgY3JlYXRpbmcgdGhlIFNlcnZpY2UgV29ya2VyIHNjcmlwdDogaHR0cHM6Ly9tc3dqcy5pby9kb2NzL2NsaS9pbml0YClcbiAgICAgICk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlZ2lzdGVyIHRoZSBTZXJ2aWNlIFdvcmtlcjpcXG5cXG4lc1wiLFxuICAgICAgICBlcnJvcjIubWVzc2FnZVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlO1xufTtcblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L3V0aWxzL3ByaW50U3RhcnRNZXNzYWdlLnRzXG5mdW5jdGlvbiBwcmludFN0YXJ0TWVzc2FnZShhcmdzID0ge30pIHtcbiAgaWYgKGFyZ3MucXVpZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbWVzc2FnZSA9IGFyZ3MubWVzc2FnZSB8fCBcIk1vY2tpbmcgZW5hYmxlZC5cIjtcbiAgY29uc29sZS5ncm91cENvbGxhcHNlZChcbiAgICBgJWMke2RldlV0aWxzLmZvcm1hdE1lc3NhZ2UobWVzc2FnZSl9YCxcbiAgICBcImNvbG9yOm9yYW5nZXJlZDtmb250LXdlaWdodDpib2xkO1wiXG4gICk7XG4gIGNvbnNvbGUubG9nKFxuICAgIFwiJWNEb2N1bWVudGF0aW9uOiAlY2h0dHBzOi8vbXN3anMuaW8vZG9jc1wiLFxuICAgIFwiZm9udC13ZWlnaHQ6Ym9sZFwiLFxuICAgIFwiZm9udC13ZWlnaHQ6bm9ybWFsXCJcbiAgKTtcbiAgY29uc29sZS5sb2coXCJGb3VuZCBhbiBpc3N1ZT8gaHR0cHM6Ly9naXRodWIuY29tL21zd2pzL21zdy9pc3N1ZXNcIik7XG4gIGlmIChhcmdzLndvcmtlclVybCkge1xuICAgIGNvbnNvbGUubG9nKFwiV29ya2VyIHNjcmlwdCBVUkw6XCIsIGFyZ3Mud29ya2VyVXJsKTtcbiAgfVxuICBpZiAoYXJncy53b3JrZXJTY29wZSkge1xuICAgIGNvbnNvbGUubG9nKFwiV29ya2VyIHNjb3BlOlwiLCBhcmdzLndvcmtlclNjb3BlKTtcbiAgfVxuICBjb25zb2xlLmdyb3VwRW5kKCk7XG59XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC91dGlscy9lbmFibGVNb2NraW5nLnRzXG5hc3luYyBmdW5jdGlvbiBlbmFibGVNb2NraW5nKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29udGV4dC53b3JrZXJDaGFubmVsLnNlbmQoXCJNT0NLX0FDVElWQVRFXCIpO1xuICBhd2FpdCBjb250ZXh0LmV2ZW50cy5vbmNlKFwiTU9DS0lOR19FTkFCTEVEXCIpO1xuICBpZiAoY29udGV4dC5pc01vY2tpbmdFbmFibGVkKSB7XG4gICAgZGV2VXRpbHMud2FybihcbiAgICAgIGBGb3VuZCBhIHJlZHVuZGFudCBcIndvcmtlci5zdGFydCgpXCIgY2FsbC4gTm90ZSB0aGF0IHN0YXJ0aW5nIHRoZSB3b3JrZXIgd2hpbGUgbW9ja2luZyBpcyBhbHJlYWR5IGVuYWJsZWQgd2lsbCBoYXZlIG5vIGVmZmVjdC4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhpcyBcIndvcmtlci5zdGFydCgpXCIgY2FsbC5gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29udGV4dC5pc01vY2tpbmdFbmFibGVkID0gdHJ1ZTtcbiAgcHJpbnRTdGFydE1lc3NhZ2Uoe1xuICAgIHF1aWV0OiBvcHRpb25zLnF1aWV0LFxuICAgIHdvcmtlclNjb3BlOiAoX2EgPSBjb250ZXh0LnJlZ2lzdHJhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNjb3BlLFxuICAgIHdvcmtlclVybDogKF9iID0gY29udGV4dC53b3JrZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zY3JpcHRVUkxcbiAgfSk7XG59XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC91dGlscy9jcmVhdGVNZXNzYWdlQ2hhbm5lbC50c1xudmFyIFdvcmtlckNoYW5uZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBvcnQpIHtcbiAgICB0aGlzLnBvcnQgPSBwb3J0O1xuICB9XG4gIHBvc3RNZXNzYWdlKGV2ZW50LCAuLi5yZXN0Mikge1xuICAgIGNvbnN0IFtkYXRhMiwgdHJhbnNmZXJdID0gcmVzdDI7XG4gICAgdGhpcy5wb3J0LnBvc3RNZXNzYWdlKHsgdHlwZTogZXZlbnQsIGRhdGE6IGRhdGEyIH0sIHsgdHJhbnNmZXIgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9OZXR3b3JrRXJyb3IudHNcbnZhciBOZXR3b3JrRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiTmV0d29ya0Vycm9yXCI7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L3BhcnNlV29ya2VyUmVxdWVzdC50c1xudmFyIGltcG9ydF9pbnRlcmNlcHRvcnMyID0gcmVxdWlyZShcIkBtc3dqcy9pbnRlcmNlcHRvcnNcIik7XG52YXIgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGw1ID0gcmVxdWlyZShcImhlYWRlcnMtcG9seWZpbGxcIik7XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L01vY2tlZFJlcXVlc3QudHNcbnZhciBjb29raWVVdGlsczMgPSBfX3RvRVNNKHJlcXVpcmUoXCJjb29raWVcIikpO1xudmFyIGltcG9ydF9jb29raWVzID0gcmVxdWlyZShcIkBtc3dqcy9jb29raWVzXCIpO1xudmFyIGltcG9ydF9pbnRlcmNlcHRvcnMgPSByZXF1aXJlKFwiQG1zd2pzL2ludGVyY2VwdG9yc1wiKTtcbnZhciBpbXBvcnRfYnVmZmVyVXRpbHMgPSByZXF1aXJlKFwiQG1zd2pzL2ludGVyY2VwdG9ycy9saWIvdXRpbHMvYnVmZmVyVXRpbHMuanNcIik7XG52YXIgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGw0ID0gcmVxdWlyZShcImhlYWRlcnMtcG9seWZpbGxcIik7XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L2dldFJlcXVlc3RDb29raWVzLnRzXG52YXIgY29va2llVXRpbHMyID0gX190b0VTTShyZXF1aXJlKFwiY29va2llXCIpKTtcbmZ1bmN0aW9uIGdldEFsbENvb2tpZXMoKSB7XG4gIHJldHVybiBjb29raWVVdGlsczIucGFyc2UoZG9jdW1lbnQuY29va2llKTtcbn1cbmZ1bmN0aW9uIGdldFJlcXVlc3RDb29raWVzKHJlcXVlc3QpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgbG9jYXRpb24gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgc3dpdGNoIChyZXF1ZXN0LmNyZWRlbnRpYWxzKSB7XG4gICAgY2FzZSBcInNhbWUtb3JpZ2luXCI6IHtcbiAgICAgIHJldHVybiBsb2NhdGlvbi5vcmlnaW4gPT09IHJlcXVlc3QudXJsLm9yaWdpbiA/IGdldEFsbENvb2tpZXMoKSA6IHt9O1xuICAgIH1cbiAgICBjYXNlIFwiaW5jbHVkZVwiOiB7XG4gICAgICByZXR1cm4gZ2V0QWxsQ29va2llcygpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9wYXJzZU11bHRpcGFydERhdGEudHNcbnZhciBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDMgPSByZXF1aXJlKFwiaGVhZGVycy1wb2x5ZmlsbFwiKTtcbmZ1bmN0aW9uIHBhcnNlQ29udGVudEhlYWRlcnMoaGVhZGVyc1N0cmluZykge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBoZWFkZXJzID0gKDAsIGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsMy5zdHJpbmdUb0hlYWRlcnMpKGhlYWRlcnNTdHJpbmcpO1xuICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IFwidGV4dC9wbGFpblwiO1xuICBjb25zdCBkaXNwb3NpdGlvbiA9IGhlYWRlcnMuZ2V0KFwiY29udGVudC1kaXNwb3NpdGlvblwiKTtcbiAgaWYgKCFkaXNwb3NpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJDb250ZW50LURpc3Bvc2l0aW9uXCIgaGVhZGVyIGlzIHJlcXVpcmVkLicpO1xuICB9XG4gIGNvbnN0IGRpcmVjdGl2ZXMgPSBkaXNwb3NpdGlvbi5zcGxpdChcIjtcIikucmVkdWNlKChhY2MsIGNodW5rKSA9PiB7XG4gICAgY29uc3QgW25hbWUyLCAuLi5yZXN0Ml0gPSBjaHVuay50cmltKCkuc3BsaXQoXCI9XCIpO1xuICAgIGFjY1tuYW1lMl0gPSByZXN0Mi5qb2luKFwiPVwiKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIGNvbnN0IG5hbWUgPSAoX2EgPSBkaXJlY3RpdmVzLm5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zbGljZSgxLCAtMSk7XG4gIGNvbnN0IGZpbGVuYW1lID0gKF9iID0gZGlyZWN0aXZlcy5maWxlbmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnNsaWNlKDEsIC0xKTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIGZpbGVuYW1lLFxuICAgIGNvbnRlbnRUeXBlXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZU11bHRpcGFydERhdGEoZGF0YTIsIGhlYWRlcnMpIHtcbiAgY29uc3QgY29udGVudFR5cGUgPSBoZWFkZXJzID09IG51bGwgPyB2b2lkIDAgOiBoZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgaWYgKCFjb250ZW50VHlwZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgWywgLi4uZGlyZWN0aXZlc10gPSBjb250ZW50VHlwZS5zcGxpdCgvOyAqLyk7XG4gIGNvbnN0IGJvdW5kYXJ5ID0gZGlyZWN0aXZlcy5maWx0ZXIoKGQpID0+IGQuc3RhcnRzV2l0aChcImJvdW5kYXJ5PVwiKSkubWFwKChzKSA9PiBzLnJlcGxhY2UoL15ib3VuZGFyeT0vLCBcIlwiKSlbMF07XG4gIGlmICghYm91bmRhcnkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IGJvdW5kYXJ5UmVnRXhwID0gbmV3IFJlZ0V4cChgLS0rJHtib3VuZGFyeX1gKTtcbiAgY29uc3QgZmllbGRzID0gZGF0YTIuc3BsaXQoYm91bmRhcnlSZWdFeHApLmZpbHRlcigoY2h1bmspID0+IGNodW5rLnN0YXJ0c1dpdGgoXCJcXHJcXG5cIikgJiYgY2h1bmsuZW5kc1dpdGgoXCJcXHJcXG5cIikpLm1hcCgoY2h1bmspID0+IGNodW5rLnRyaW1TdGFydCgpLnJlcGxhY2UoL1xcclxcbiQvLCBcIlwiKSk7XG4gIGlmICghZmllbGRzLmxlbmd0aCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgcGFyc2VkQm9keSA9IHt9O1xuICB0cnkge1xuICAgIGZvciAoY29uc3QgZmllbGQyIG9mIGZpZWxkcykge1xuICAgICAgY29uc3QgW2NvbnRlbnRIZWFkZXJzLCAuLi5yZXN0Ml0gPSBmaWVsZDIuc3BsaXQoXCJcXHJcXG5cXHJcXG5cIik7XG4gICAgICBjb25zdCBjb250ZW50Qm9keSA9IHJlc3QyLmpvaW4oXCJcXHJcXG5cXHJcXG5cIik7XG4gICAgICBjb25zdCB7IGNvbnRlbnRUeXBlOiBjb250ZW50VHlwZTIsIGZpbGVuYW1lLCBuYW1lIH0gPSBwYXJzZUNvbnRlbnRIZWFkZXJzKGNvbnRlbnRIZWFkZXJzKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZmlsZW5hbWUgPT09IHZvaWQgMCA/IGNvbnRlbnRCb2R5IDogbmV3IEZpbGUoW2NvbnRlbnRCb2R5XSwgZmlsZW5hbWUsIHsgdHlwZTogY29udGVudFR5cGUyIH0pO1xuICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZWRCb2R5W25hbWVdO1xuICAgICAgaWYgKHBhcnNlZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgcGFyc2VkQm9keVtuYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZFZhbHVlKSkge1xuICAgICAgICBwYXJzZWRCb2R5W25hbWVdID0gWy4uLnBhcnNlZFZhbHVlLCB2YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRCb2R5W25hbWVdID0gW3BhcnNlZFZhbHVlLCB2YWx1ZV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWRCb2R5O1xuICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L3BhcnNlQm9keS50c1xuZnVuY3Rpb24gcGFyc2VCb2R5KGJvZHkyLCBoZWFkZXJzKSB7XG4gIHZhciBfYTtcbiAgaWYgKCFib2R5Mikge1xuICAgIHJldHVybiBib2R5MjtcbiAgfVxuICBjb25zdCBjb250ZW50VHlwZSA9ICgoX2EgPSBoZWFkZXJzID09IG51bGwgPyB2b2lkIDAgOiBoZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRvTG93ZXJDYXNlKCkpIHx8IFwiXCI7XG4gIGNvbnN0IGhhc011bHRpcGFydENvbnRlbnQgPSBjb250ZW50VHlwZS5zdGFydHNXaXRoKFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiKTtcbiAgaWYgKGhhc011bHRpcGFydENvbnRlbnQgJiYgdHlwZW9mIGJvZHkyICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIHBhcnNlTXVsdGlwYXJ0RGF0YShib2R5Mi50b1N0cmluZygpLCBoZWFkZXJzKSB8fCBib2R5MjtcbiAgfVxuICBjb25zdCBoYXNKc29uQ29udGVudCA9IGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwianNvblwiKTtcbiAgaWYgKGhhc0pzb25Db250ZW50ICYmIHR5cGVvZiBib2R5MiAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBqc29uUGFyc2UoYm9keTIudG9TdHJpbmcoKSkgfHwgYm9keTI7XG4gIH1cbiAgcmV0dXJuIGJvZHkyO1xufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvaXNTdHJpbmdFcXVhbC50c1xuZnVuY3Rpb24gaXNTdHJpbmdFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIHJldHVybiBhY3R1YWwudG9Mb3dlckNhc2UoKSA9PT0gZXhwZWN0ZWQudG9Mb3dlckNhc2UoKTtcbn1cblxuLy8gc3JjL3V0aWxzL3JlcXVlc3QvTW9ja2VkUmVxdWVzdC50c1xudmFyIE1vY2tlZFJlcXVlc3QgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9pbnRlcmNlcHRvcnMuSXNvbW9ycGhpY1JlcXVlc3Qge1xuICBjb25zdHJ1Y3Rvcih1cmwsIGluaXQgPSB7fSkge1xuICAgIHN1cGVyKHVybCwgaW5pdCk7XG4gICAgaWYgKGluaXQuaWQpIHtcbiAgICAgIHRoaXMuaWQgPSBpbml0LmlkO1xuICAgIH1cbiAgICB0aGlzLmNhY2hlID0gaW5pdC5jYWNoZSB8fCBcImRlZmF1bHRcIjtcbiAgICB0aGlzLmRlc3RpbmF0aW9uID0gaW5pdC5kZXN0aW5hdGlvbiB8fCBcIlwiO1xuICAgIHRoaXMuaW50ZWdyaXR5ID0gaW5pdC5pbnRlZ3JpdHkgfHwgXCJcIjtcbiAgICB0aGlzLmtlZXBhbGl2ZSA9IGluaXQua2VlcGFsaXZlIHx8IGZhbHNlO1xuICAgIHRoaXMubW9kZSA9IGluaXQubW9kZSB8fCBcImNvcnNcIjtcbiAgICB0aGlzLnByaW9yaXR5ID0gaW5pdC5wcmlvcml0eSB8fCBcImF1dG9cIjtcbiAgICB0aGlzLnJlZGlyZWN0ID0gaW5pdC5yZWRpcmVjdCB8fCBcImZvbGxvd1wiO1xuICAgIHRoaXMucmVmZXJyZXIgPSBpbml0LnJlZmVycmVyIHx8IFwiXCI7XG4gICAgdGhpcy5yZWZlcnJlclBvbGljeSA9IGluaXQucmVmZXJyZXJQb2xpY3kgfHwgXCJuby1yZWZlcnJlclwiO1xuICAgIHRoaXMuY29va2llcyA9IGluaXQuY29va2llcyB8fCB0aGlzLmdldENvb2tpZXMoKTtcbiAgfVxuICBnZXQgYm9keSgpIHtcbiAgICBjb25zdCB0ZXh0MiA9ICgwLCBpbXBvcnRfYnVmZmVyVXRpbHMuZGVjb2RlQnVmZmVyKSh0aGlzW1wiX2JvZHlcIl0pO1xuICAgIGNvbnN0IGJvZHkyID0gcGFyc2VCb2R5KHRleHQyLCB0aGlzLmhlYWRlcnMpO1xuICAgIGlmIChpc1N0cmluZ0VxdWFsKHRoaXMubWV0aG9kLCBcIkdFVFwiKSAmJiBib2R5MiA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHkyO1xuICB9XG4gIHBhc3N0aHJvdWdoKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IDEwMSxcbiAgICAgIHN0YXR1c1RleHQ6IFwiQ29udGludWVcIixcbiAgICAgIGhlYWRlcnM6IG5ldyBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDQuSGVhZGVycygpLFxuICAgICAgYm9keTogbnVsbCxcbiAgICAgIHBhc3N0aHJvdWdoOiB0cnVlLFxuICAgICAgb25jZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGdldENvb2tpZXMoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJlcXVlc3RDb29raWVzU3RyaW5nID0gdGhpcy5oZWFkZXJzLmdldChcImNvb2tpZVwiKTtcbiAgICBjb25zdCBvd25Db29raWVzID0gcmVxdWVzdENvb2tpZXNTdHJpbmcgPyBjb29raWVVdGlsczMucGFyc2UocmVxdWVzdENvb2tpZXNTdHJpbmcpIDoge307XG4gICAgaW1wb3J0X2Nvb2tpZXMuc3RvcmUuaHlkcmF0ZSgpO1xuICAgIGNvbnN0IGNvb2tpZXNGcm9tU3RvcmUgPSBBcnJheS5mcm9tKFxuICAgICAgKF9hID0gaW1wb3J0X2Nvb2tpZXMuc3RvcmUuZ2V0KHsgLi4udGhpcywgdXJsOiB0aGlzLnVybC5ocmVmIH0pKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZW50cmllcygpXG4gICAgKS5yZWR1Y2UoKGNvb2tpZXMsIFtuYW1lLCB7IHZhbHVlIH1dKSA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihjb29raWVzLCB7IFtuYW1lLnRyaW0oKV06IHZhbHVlIH0pO1xuICAgIH0sIHt9KTtcbiAgICBjb25zdCBjb29raWVzRnJvbURvY3VtZW50ID0gZ2V0UmVxdWVzdENvb2tpZXModGhpcyk7XG4gICAgY29uc3QgZm9yd2FyZGVkQ29va2llcyA9IHtcbiAgICAgIC4uLmNvb2tpZXNGcm9tRG9jdW1lbnQsXG4gICAgICAuLi5jb29raWVzRnJvbVN0b3JlXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZm9yd2FyZGVkQ29va2llcykpIHtcbiAgICAgIHRoaXMuaGVhZGVycy5hcHBlbmQoXCJjb29raWVcIiwgYCR7bmFtZX09JHt2YWx1ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZvcndhcmRlZENvb2tpZXMsXG4gICAgICAuLi5vd25Db29raWVzXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3JlcXVlc3QvcGFyc2VXb3JrZXJSZXF1ZXN0LnRzXG5mdW5jdGlvbiBwYXJzZVdvcmtlclJlcXVlc3QocmF3UmVxdWVzdCkge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKHJhd1JlcXVlc3QudXJsKTtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDUuSGVhZGVycyhyYXdSZXF1ZXN0LmhlYWRlcnMpO1xuICByZXR1cm4gbmV3IE1vY2tlZFJlcXVlc3QodXJsLCB7XG4gICAgLi4ucmF3UmVxdWVzdCxcbiAgICBib2R5OiAoMCwgaW1wb3J0X2ludGVyY2VwdG9yczIuZW5jb2RlQnVmZmVyKShyYXdSZXF1ZXN0LmJvZHkgfHwgXCJcIiksXG4gICAgaGVhZGVyc1xuICB9KTtcbn1cblxuLy8gc3JjL3V0aWxzL2hhbmRsZVJlcXVlc3QudHNcbnZhciBpbXBvcnRfdW50aWwyID0gcmVxdWlyZShcIkBvcGVuLWRyYWZ0L3VudGlsXCIpO1xuXG4vLyBzcmMvdXRpbHMvZ2V0UmVzcG9uc2UudHNcbnZhciBnZXRSZXNwb25zZSA9IGFzeW5jIChyZXF1ZXN0LCBoYW5kbGVycywgcmVzb2x1dGlvbkNvbnRleHQpID0+IHtcbiAgY29uc3QgcmVsZXZhbnRIYW5kbGVycyA9IGhhbmRsZXJzLmZpbHRlcigoaGFuZGxlcikgPT4ge1xuICAgIHJldHVybiBoYW5kbGVyLnRlc3QocmVxdWVzdCwgcmVzb2x1dGlvbkNvbnRleHQpO1xuICB9KTtcbiAgaWYgKHJlbGV2YW50SGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIHJlc3BvbnNlOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlbGV2YW50SGFuZGxlcnMucmVkdWNlKGFzeW5jIChleGVjdXRpb25SZXN1bHQsIGhhbmRsZXIpID0+IHtcbiAgICBjb25zdCBwcmV2aW91c1Jlc3VsdHMgPSBhd2FpdCBleGVjdXRpb25SZXN1bHQ7XG4gICAgaWYgKCEhKHByZXZpb3VzUmVzdWx0cyA9PSBudWxsID8gdm9pZCAwIDogcHJldmlvdXNSZXN1bHRzLnJlc3BvbnNlKSkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGlvblJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IGhhbmRsZXIucnVuKHJlcXVlc3QsIHJlc29sdXRpb25Db250ZXh0KTtcbiAgICBpZiAocmVzdWx0MiA9PT0gbnVsbCB8fCByZXN1bHQyLmhhbmRsZXIuc2hvdWxkU2tpcCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghcmVzdWx0Mi5yZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVxdWVzdDogcmVzdWx0Mi5yZXF1ZXN0LFxuICAgICAgICBoYW5kbGVyOiByZXN1bHQyLmhhbmRsZXIsXG4gICAgICAgIHJlc3BvbnNlOiB2b2lkIDAsXG4gICAgICAgIHBhcnNlZFJlc3VsdDogcmVzdWx0Mi5wYXJzZWRSZXN1bHRcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChyZXN1bHQyLnJlc3BvbnNlLm9uY2UpIHtcbiAgICAgIGhhbmRsZXIubWFya0FzU2tpcHBlZCh0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH0sIFByb21pc2UucmVzb2x2ZShudWxsKSk7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIHJlc3BvbnNlOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaGFuZGxlcjogcmVzdWx0LmhhbmRsZXIsXG4gICAgcHVibGljUmVxdWVzdDogcmVzdWx0LnJlcXVlc3QsXG4gICAgcGFyc2VkUmVxdWVzdDogcmVzdWx0LnBhcnNlZFJlc3VsdCxcbiAgICByZXNwb25zZTogcmVzdWx0LnJlc3BvbnNlXG4gIH07XG59O1xuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9vblVuaGFuZGxlZFJlcXVlc3QudHNcbnZhciBpbXBvcnRfanNfbGV2ZW5zaHRlaW4gPSBfX3RvRVNNKHJlcXVpcmUoXCJqcy1sZXZlbnNodGVpblwiKSk7XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9wYXJzZUdyYXBoUUxSZXF1ZXN0LnRzXG52YXIgaW1wb3J0X2dyYXBocWwgPSByZXF1aXJlKFwiZ3JhcGhxbFwiKTtcblxuLy8gc3JjL3V0aWxzL3JlcXVlc3QvZ2V0UHVibGljVXJsRnJvbVJlcXVlc3QudHNcbnZhciBnZXRQdWJsaWNVcmxGcm9tUmVxdWVzdCA9IChyZXF1ZXN0KSA9PiB7XG4gIHJldHVybiByZXF1ZXN0LnJlZmVycmVyLnN0YXJ0c1dpdGgocmVxdWVzdC51cmwub3JpZ2luKSA/IHJlcXVlc3QudXJsLnBhdGhuYW1lIDogbmV3IFVSTChcbiAgICByZXF1ZXN0LnVybC5wYXRobmFtZSxcbiAgICBgJHtyZXF1ZXN0LnVybC5wcm90b2NvbH0vLyR7cmVxdWVzdC51cmwuaG9zdH1gXG4gICkuaHJlZjtcbn07XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9wYXJzZUdyYXBoUUxSZXF1ZXN0LnRzXG5mdW5jdGlvbiBwYXJzZURvY3VtZW50Tm9kZShub2RlKSB7XG4gIHZhciBfYTtcbiAgY29uc3Qgb3BlcmF0aW9uRGVmID0gbm9kZS5kZWZpbml0aW9ucy5maW5kKChkZWYpID0+IHtcbiAgICByZXR1cm4gZGVmLmtpbmQgPT09IFwiT3BlcmF0aW9uRGVmaW5pdGlvblwiO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBvcGVyYXRpb25UeXBlOiBvcGVyYXRpb25EZWYgPT0gbnVsbCA/IHZvaWQgMCA6IG9wZXJhdGlvbkRlZi5vcGVyYXRpb24sXG4gICAgb3BlcmF0aW9uTmFtZTogKF9hID0gb3BlcmF0aW9uRGVmID09IG51bGwgPyB2b2lkIDAgOiBvcGVyYXRpb25EZWYubmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVF1ZXJ5KHF1ZXJ5KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgYXN0ID0gKDAsIGltcG9ydF9ncmFwaHFsLnBhcnNlKShxdWVyeSk7XG4gICAgcmV0dXJuIHBhcnNlRG9jdW1lbnROb2RlKGFzdCk7XG4gIH0gY2F0Y2ggKGVycm9yMikge1xuICAgIHJldHVybiBlcnJvcjI7XG4gIH1cbn1cbmZ1bmN0aW9uIGV4dHJhY3RNdWx0aXBhcnRWYXJpYWJsZXModmFyaWFibGVzLCBtYXAsIGZpbGVzKSB7XG4gIGNvbnN0IG9wZXJhdGlvbnMgPSB7IHZhcmlhYmxlcyB9O1xuICBmb3IgKGNvbnN0IFtrZXksIHBhdGhBcnJheV0gb2YgT2JqZWN0LmVudHJpZXMobWFwKSkge1xuICAgIGlmICghKGtleSBpbiBmaWxlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgR2l2ZW4gZmlsZXMgZG8gbm90IGhhdmUgYSBrZXkgJyR7a2V5fScgLmApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRvdFBhdGggb2YgcGF0aEFycmF5KSB7XG4gICAgICBjb25zdCBbbGFzdFBhdGgsIC4uLnJldmVyc2VkUGF0aHNdID0gZG90UGF0aC5zcGxpdChcIi5cIikucmV2ZXJzZSgpO1xuICAgICAgY29uc3QgcGF0aHMgPSByZXZlcnNlZFBhdGhzLnJldmVyc2UoKTtcbiAgICAgIGxldCB0YXJnZXQgPSBvcGVyYXRpb25zO1xuICAgICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIGlmICghKHBhdGggaW4gdGFyZ2V0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvcGVydHkgJyR7cGF0aHN9JyBpcyBub3QgaW4gb3BlcmF0aW9ucy5gKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQgPSB0YXJnZXRbcGF0aF07XG4gICAgICB9XG4gICAgICB0YXJnZXRbbGFzdFBhdGhdID0gZmlsZXNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wZXJhdGlvbnMudmFyaWFibGVzO1xufVxuZnVuY3Rpb24gZ2V0R3JhcGhRTElucHV0KHJlcXVlc3QpIHtcbiAgdmFyIF9hLCBfYjtcbiAgc3dpdGNoIChyZXF1ZXN0Lm1ldGhvZCkge1xuICAgIGNhc2UgXCJHRVRcIjoge1xuICAgICAgY29uc3QgcXVlcnkgPSByZXF1ZXN0LnVybC5zZWFyY2hQYXJhbXMuZ2V0KFwicXVlcnlcIik7XG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSByZXF1ZXN0LnVybC5zZWFyY2hQYXJhbXMuZ2V0KFwidmFyaWFibGVzXCIpIHx8IFwiXCI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBxdWVyeSxcbiAgICAgICAgdmFyaWFibGVzOiBqc29uUGFyc2UodmFyaWFibGVzKVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIlBPU1RcIjoge1xuICAgICAgaWYgKChfYSA9IHJlcXVlc3QuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IHsgcXVlcnksIHZhcmlhYmxlcyB9ID0gcmVxdWVzdC5ib2R5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIHZhcmlhYmxlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKChfYiA9IHJlcXVlc3QuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm9wZXJhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBvcGVyYXRpb25zLCBtYXAsIC4uLmZpbGVzIH0gPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIGNvbnN0IHBhcnNlZE9wZXJhdGlvbnMgPSBqc29uUGFyc2UoXG4gICAgICAgICAgb3BlcmF0aW9uc1xuICAgICAgICApIHx8IHt9O1xuICAgICAgICBpZiAoIXBhcnNlZE9wZXJhdGlvbnMucXVlcnkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRNYXAgPSBqc29uUGFyc2UobWFwIHx8IFwiXCIpIHx8IHt9O1xuICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSBwYXJzZWRPcGVyYXRpb25zLnZhcmlhYmxlcyA/IGV4dHJhY3RNdWx0aXBhcnRWYXJpYWJsZXMoXG4gICAgICAgICAgcGFyc2VkT3BlcmF0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgcGFyc2VkTWFwLFxuICAgICAgICAgIGZpbGVzXG4gICAgICAgICkgOiB7fTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBxdWVyeTogcGFyc2VkT3BlcmF0aW9ucy5xdWVyeSxcbiAgICAgICAgICB2YXJpYWJsZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUdyYXBoUUxSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgY29uc3QgaW5wdXQgPSBnZXRHcmFwaFFMSW5wdXQocmVxdWVzdCk7XG4gIGlmICghaW5wdXQgfHwgIWlucHV0LnF1ZXJ5KSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCB7IHF1ZXJ5LCB2YXJpYWJsZXMgfSA9IGlucHV0O1xuICBjb25zdCBwYXJzZWRSZXN1bHQgPSBwYXJzZVF1ZXJ5KHF1ZXJ5KTtcbiAgaWYgKHBhcnNlZFJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgY29uc3QgcmVxdWVzdFB1YmxpY1VybCA9IGdldFB1YmxpY1VybEZyb21SZXF1ZXN0KHJlcXVlc3QpO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICdGYWlsZWQgdG8gaW50ZXJjZXB0IGEgR3JhcGhRTCByZXF1ZXN0IHRvIFwiJXMgJXNcIjogY2Fubm90IHBhcnNlIHF1ZXJ5LiBTZWUgdGhlIGVycm9yIG1lc3NhZ2UgZnJvbSB0aGUgcGFyc2VyIGJlbG93LlxcblxcbiVzJyxcbiAgICAgICAgcmVxdWVzdC5tZXRob2QsXG4gICAgICAgIHJlcXVlc3RQdWJsaWNVcmwsXG4gICAgICAgIHBhcnNlZFJlc3VsdC5tZXNzYWdlXG4gICAgICApXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9wZXJhdGlvblR5cGU6IHBhcnNlZFJlc3VsdC5vcGVyYXRpb25UeXBlLFxuICAgIG9wZXJhdGlvbk5hbWU6IHBhcnNlZFJlc3VsdC5vcGVyYXRpb25OYW1lLFxuICAgIHZhcmlhYmxlc1xuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMvbG9nZ2luZy9nZXRTdGF0dXNDb2RlQ29sb3IudHNcbmZ1bmN0aW9uIGdldFN0YXR1c0NvZGVDb2xvcihzdGF0dXMyKSB7XG4gIGlmIChzdGF0dXMyIDwgMzAwKSB7XG4gICAgcmV0dXJuIFwiIzY5QUIzMlwiIC8qIFN1Y2Nlc3MgKi87XG4gIH1cbiAgaWYgKHN0YXR1czIgPCA0MDApIHtcbiAgICByZXR1cm4gXCIjRjBCQjRCXCIgLyogV2FybmluZyAqLztcbiAgfVxuICByZXR1cm4gXCIjRTk1RjVEXCIgLyogRGFuZ2VyICovO1xufVxuXG4vLyBzcmMvdXRpbHMvbG9nZ2luZy9nZXRUaW1lc3RhbXAudHNcbmZ1bmN0aW9uIGdldFRpbWVzdGFtcCgpIHtcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgcmV0dXJuIFtub3cuZ2V0SG91cnMoKSwgbm93LmdldE1pbnV0ZXMoKSwgbm93LmdldFNlY29uZHMoKV0ubWFwKFN0cmluZykubWFwKChjaHVuaykgPT4gY2h1bmsuc2xpY2UoMCwgMikpLm1hcCgoY2h1bmspID0+IGNodW5rLnBhZFN0YXJ0KDIsIFwiMFwiKSkuam9pbihcIjpcIik7XG59XG5cbi8vIHNyYy91dGlscy9sb2dnaW5nL3ByZXBhcmVSZXF1ZXN0LnRzXG5mdW5jdGlvbiBwcmVwYXJlUmVxdWVzdChyZXF1ZXN0KSB7XG4gIHJldHVybiB7XG4gICAgLi4ucmVxdWVzdCxcbiAgICBib2R5OiByZXF1ZXN0LmJvZHksXG4gICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLmFsbCgpXG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9sb2dnaW5nL3ByZXBhcmVSZXNwb25zZS50c1xudmFyIGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsNiA9IHJlcXVpcmUoXCJoZWFkZXJzLXBvbHlmaWxsXCIpO1xuZnVuY3Rpb24gcHJlcGFyZVJlc3BvbnNlKHJlcykge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSAoMCwgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGw2Lm9iamVjdFRvSGVhZGVycykocmVzLmhlYWRlcnMpO1xuICBjb25zdCBwYXJzZWRCb2R5ID0gcGFyc2VCb2R5KHJlcy5ib2R5LCByZXNwb25zZUhlYWRlcnMpO1xuICByZXR1cm4ge1xuICAgIC4uLnJlcyxcbiAgICBib2R5OiBwYXJzZWRCb2R5XG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9tYXRjaGluZy9tYXRjaFJlcXVlc3RVcmwudHNcbnZhciBpbXBvcnRfcGF0aF90b19yZWdleHAgPSByZXF1aXJlKFwicGF0aC10by1yZWdleHBcIik7XG52YXIgaW1wb3J0X2dldENsZWFuVXJsID0gcmVxdWlyZShcIkBtc3dqcy9pbnRlcmNlcHRvcnMvbGliL3V0aWxzL2dldENsZWFuVXJsLmpzXCIpO1xuXG4vLyBzcmMvdXRpbHMvdXJsL2NsZWFuVXJsLnRzXG52YXIgUkVEVU5EQU5UX0NIQVJBQ1RFUlNfRVhQID0gL1tcXD98I10uKiQvZztcbmZ1bmN0aW9uIGdldFNlYXJjaFBhcmFtcyhwYXRoKSB7XG4gIHJldHVybiBuZXcgVVJMKGAvJHtwYXRofWAsIFwiaHR0cDovL2xvY2FsaG9zdFwiKS5zZWFyY2hQYXJhbXM7XG59XG5mdW5jdGlvbiBjbGVhblVybChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoUkVEVU5EQU5UX0NIQVJBQ1RFUlNfRVhQLCBcIlwiKTtcbn1cblxuLy8gc3JjL3V0aWxzL3VybC9pc0Fic29sdXRlVXJsLnRzXG5mdW5jdGlvbiBpc0Fic29sdXRlVXJsKHVybCkge1xuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59XG5cbi8vIHNyYy91dGlscy91cmwvZ2V0QWJzb2x1dGVVcmwudHNcbmZ1bmN0aW9uIGdldEFic29sdXRlVXJsKHBhdGgsIGJhc2VVcmwpIHtcbiAgaWYgKGlzQWJzb2x1dGVVcmwocGF0aCkpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiKlwiKSkge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIGNvbnN0IG9yaWdpbiA9IGJhc2VVcmwgfHwgdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmJhc2VVUkk7XG4gIHJldHVybiBvcmlnaW4gPyBkZWNvZGVVUkkobmV3IFVSTChlbmNvZGVVUkkocGF0aCksIG9yaWdpbikuaHJlZikgOiBwYXRoO1xufVxuXG4vLyBzcmMvdXRpbHMvbWF0Y2hpbmcvbm9ybWFsaXplUGF0aC50c1xuZnVuY3Rpb24gbm9ybWFsaXplUGF0aChwYXRoLCBiYXNlVXJsKSB7XG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgY29uc3QgbWF5YmVBYnNvbHV0ZVVybCA9IGdldEFic29sdXRlVXJsKHBhdGgsIGJhc2VVcmwpO1xuICByZXR1cm4gY2xlYW5VcmwobWF5YmVBYnNvbHV0ZVVybCk7XG59XG5cbi8vIHNyYy91dGlscy9tYXRjaGluZy9tYXRjaFJlcXVlc3RVcmwudHNcbmZ1bmN0aW9uIGNvZXJjZVBhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKFxuICAgIC8oWzphLXpBLVpfLV0qKShcXCp7MSwyfSkrL2csXG4gICAgKF8sIHBhcmFtZXRlck5hbWUsIHdpbGRjYXJkKSA9PiB7XG4gICAgICBjb25zdCBleHByZXNzaW9uID0gXCIoLiopXCI7XG4gICAgICBpZiAoIXBhcmFtZXRlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1ldGVyTmFtZS5zdGFydHNXaXRoKFwiOlwiKSA/IGAke3BhcmFtZXRlck5hbWV9JHt3aWxkY2FyZH1gIDogYCR7cGFyYW1ldGVyTmFtZX0ke2V4cHJlc3Npb259YDtcbiAgICB9XG4gICkucmVwbGFjZSgvKFteXFwvXSkoOikoPz1cXGQrKS8sIFwiJDFcXFxcJDJcIikucmVwbGFjZSgvXihbXlxcL10rKSg6KSg/PVxcL1xcLykvLCBcIiQxXFxcXCQyXCIpO1xufVxuZnVuY3Rpb24gbWF0Y2hSZXF1ZXN0VXJsKHVybCwgcGF0aCwgYmFzZVVybCkge1xuICBjb25zdCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgocGF0aCwgYmFzZVVybCk7XG4gIGNvbnN0IGNsZWFuUGF0aCA9IHR5cGVvZiBub3JtYWxpemVkUGF0aCA9PT0gXCJzdHJpbmdcIiA/IGNvZXJjZVBhdGgobm9ybWFsaXplZFBhdGgpIDogbm9ybWFsaXplZFBhdGg7XG4gIGNvbnN0IGNsZWFuVXJsMiA9ICgwLCBpbXBvcnRfZ2V0Q2xlYW5VcmwuZ2V0Q2xlYW5VcmwpKHVybCk7XG4gIGNvbnN0IHJlc3VsdCA9ICgwLCBpbXBvcnRfcGF0aF90b19yZWdleHAubWF0Y2gpKGNsZWFuUGF0aCwgeyBkZWNvZGU6IGRlY29kZVVSSUNvbXBvbmVudCB9KShjbGVhblVybDIpO1xuICBjb25zdCBwYXJhbXMgPSByZXN1bHQgJiYgcmVzdWx0LnBhcmFtcyB8fCB7fTtcbiAgcmV0dXJuIHtcbiAgICBtYXRjaGVzOiByZXN1bHQgIT09IGZhbHNlLFxuICAgIHBhcmFtc1xuICB9O1xufVxuXG4vLyBzcmMvaGFuZGxlcnMvUmVxdWVzdEhhbmRsZXIudHNcbnZhciBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDggPSByZXF1aXJlKFwiaGVhZGVycy1wb2x5ZmlsbFwiKTtcblxuLy8gc3JjL3Jlc3BvbnNlLnRzXG52YXIgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGw3ID0gcmVxdWlyZShcImhlYWRlcnMtcG9seWZpbGxcIik7XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9jb21wb3NlLnRzXG5mdW5jdGlvbiBjb21wb3NlKC4uLmZucykge1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gZm5zLnJlZHVjZVJpZ2h0KChsZWZ0Rm4sIHJpZ2h0Rm4pID0+IHtcbiAgICAgIHJldHVybiBsZWZ0Rm4gaW5zdGFuY2VvZiBQcm9taXNlID8gUHJvbWlzZS5yZXNvbHZlKGxlZnRGbikudGhlbihyaWdodEZuKSA6IHJpZ2h0Rm4obGVmdEZuKTtcbiAgICB9LCBhcmdzWzBdKTtcbiAgfTtcbn1cblxuLy8gc3JjL3Jlc3BvbnNlLnRzXG52YXIgZGVmYXVsdFJlc3BvbnNlID0ge1xuICBzdGF0dXM6IDIwMCxcbiAgc3RhdHVzVGV4dDogXCJPS1wiLFxuICBib2R5OiBudWxsLFxuICBkZWxheTogMCxcbiAgb25jZTogZmFsc2UsXG4gIHBhc3N0aHJvdWdoOiBmYWxzZVxufTtcbnZhciBkZWZhdWx0UmVzcG9uc2VUcmFuc2Zvcm1lcnMgPSBbXTtcbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlQ29tcG9zaXRpb24ocmVzcG9uc2VPdmVycmlkZXMsIGRlZmF1bHRUcmFuc2Zvcm1lcnMgPSBkZWZhdWx0UmVzcG9uc2VUcmFuc2Zvcm1lcnMpIHtcbiAgcmV0dXJuIGFzeW5jICguLi50cmFuc2Zvcm1lcnMpID0+IHtcbiAgICBjb25zdCBpbml0aWFsUmVzcG9uc2UgPSBPYmplY3QuYXNzaWduKFxuICAgICAge30sXG4gICAgICBkZWZhdWx0UmVzcG9uc2UsXG4gICAgICB7XG4gICAgICAgIGhlYWRlcnM6IG5ldyBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDcuSGVhZGVycyh7XG4gICAgICAgICAgXCJ4LXBvd2VyZWQtYnlcIjogXCJtc3dcIlxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNlT3ZlcnJpZGVzXG4gICAgKTtcbiAgICBjb25zdCByZXNvbHZlZFRyYW5zZm9ybWVycyA9IFtcbiAgICAgIC4uLmRlZmF1bHRUcmFuc2Zvcm1lcnMsXG4gICAgICAuLi50cmFuc2Zvcm1lcnNcbiAgICBdLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCByZXNvbHZlZFJlc3BvbnNlID0gcmVzb2x2ZWRUcmFuc2Zvcm1lcnMubGVuZ3RoID4gMCA/IGNvbXBvc2UoLi4ucmVzb2x2ZWRUcmFuc2Zvcm1lcnMpKGluaXRpYWxSZXNwb25zZSkgOiBpbml0aWFsUmVzcG9uc2U7XG4gICAgcmV0dXJuIHJlc29sdmVkUmVzcG9uc2U7XG4gIH07XG59XG52YXIgcmVzcG9uc2UgPSBPYmplY3QuYXNzaWduKGNyZWF0ZVJlc3BvbnNlQ29tcG9zaXRpb24oKSwge1xuICBvbmNlOiBjcmVhdGVSZXNwb25zZUNvbXBvc2l0aW9uKHsgb25jZTogdHJ1ZSB9KSxcbiAgbmV0d29ya0Vycm9yKG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKG1lc3NhZ2UpO1xuICB9XG59KTtcblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL2dldENhbGxGcmFtZS50c1xudmFyIFNPVVJDRV9GUkFNRSA9IC9bXFwvXFxcXF1tc3dbXFwvXFxcXF1zcmNbXFwvXFxcXF0oLispLztcbnZhciBCVUlMRF9GUkFNRSA9IC8obm9kZV9tb2R1bGVzKT9bXFwvXFxcXF1saWJbXFwvXFxcXF0odW1kfGVzbXxpaWVmfGNqcylbXFwvXFxcXF18XlteXFwvXFxcXF0qJC87XG5mdW5jdGlvbiBnZXRDYWxsRnJhbWUoZXJyb3IyKSB7XG4gIGNvbnN0IHN0YWNrID0gZXJyb3IyLnN0YWNrO1xuICBpZiAoIXN0YWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZyYW1lcyA9IHN0YWNrLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDEpO1xuICBjb25zdCBkZWNsYXJhdGlvbkZyYW1lID0gZnJhbWVzLmZpbmQoKGZyYW1lKSA9PiB7XG4gICAgcmV0dXJuICEoU09VUkNFX0ZSQU1FLnRlc3QoZnJhbWUpIHx8IEJVSUxEX0ZSQU1FLnRlc3QoZnJhbWUpKTtcbiAgfSk7XG4gIGlmICghZGVjbGFyYXRpb25GcmFtZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkZWNsYXJhdGlvblBhdGggPSBkZWNsYXJhdGlvbkZyYW1lLnJlcGxhY2UoL1xccyphdCBbXigpXSpcXCgoW14pXSspXFwpLywgXCIkMVwiKS5yZXBsYWNlKC9eQC8sIFwiXCIpO1xuICByZXR1cm4gZGVjbGFyYXRpb25QYXRoO1xufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvaXNJdGVyYWJsZS50c1xuZnVuY3Rpb24gaXNJdGVyYWJsZShmbikge1xuICBpZiAoIWZuKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgZm5bU3ltYm9sLml0ZXJhdG9yXSA9PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8vIHNyYy9oYW5kbGVycy9SZXF1ZXN0SGFuZGxlci50c1xudmFyIGRlZmF1bHRDb250ZXh0ID0ge1xuICBzdGF0dXMsXG4gIHNldCxcbiAgZGVsYXksXG4gIGZldGNoXG59O1xudmFyIFJlcXVlc3RIYW5kbGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5zaG91bGRTa2lwID0gZmFsc2U7XG4gICAgdGhpcy5jdHggPSBvcHRpb25zLmN0eCB8fCBkZWZhdWx0Q29udGV4dDtcbiAgICB0aGlzLnJlc29sdmVyID0gb3B0aW9ucy5yZXNvbHZlcjtcbiAgICBjb25zdCBjYWxsRnJhbWUgPSBnZXRDYWxsRnJhbWUobmV3IEVycm9yKCkpO1xuICAgIHRoaXMuaW5mbyA9IHtcbiAgICAgIC4uLm9wdGlvbnMuaW5mbyxcbiAgICAgIGNhbGxGcmFtZVxuICAgIH07XG4gIH1cbiAgcGFyc2UoX3JlcXVlc3QsIF9yZXNvbHV0aW9uQ29udGV4dCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRlc3QocmVxdWVzdCwgcmVzb2x1dGlvbkNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGhpcy5wYXJzZShyZXF1ZXN0LCByZXNvbHV0aW9uQ29udGV4dCksXG4gICAgICByZXNvbHV0aW9uQ29udGV4dFxuICAgICk7XG4gIH1cbiAgZ2V0UHVibGljUmVxdWVzdChyZXF1ZXN0LCBfcGFyc2VkUmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cbiAgbWFya0FzU2tpcHBlZChzaG91bGRTa2lwID0gdHJ1ZSkge1xuICAgIHRoaXMuc2hvdWxkU2tpcCA9IHNob3VsZFNraXA7XG4gIH1cbiAgYXN5bmMgcnVuKHJlcXVlc3QsIHJlc29sdXRpb25Db250ZXh0KSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkU2tpcCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFJlc3VsdCA9IHRoaXMucGFyc2UocmVxdWVzdCwgcmVzb2x1dGlvbkNvbnRleHQpO1xuICAgIGNvbnN0IHNob3VsZEludGVyY2VwdCA9IHRoaXMucHJlZGljYXRlKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHBhcnNlZFJlc3VsdCxcbiAgICAgIHJlc29sdXRpb25Db250ZXh0XG4gICAgKTtcbiAgICBpZiAoIXNob3VsZEludGVyY2VwdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY1JlcXVlc3QgPSB0aGlzLmdldFB1YmxpY1JlcXVlc3QocmVxdWVzdCwgcGFyc2VkUmVzdWx0KTtcbiAgICBjb25zdCBleGVjdXRlUmVzb2x2ZXIgPSB0aGlzLndyYXBSZXNvbHZlcih0aGlzLnJlc29sdmVyKTtcbiAgICBjb25zdCBtb2NrZWRSZXNwb25zZSA9IGF3YWl0IGV4ZWN1dGVSZXNvbHZlcihcbiAgICAgIHB1YmxpY1JlcXVlc3QsXG4gICAgICByZXNwb25zZSxcbiAgICAgIHRoaXMuY3R4XG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVFeGVjdXRpb25SZXN1bHQoXG4gICAgICBwYXJzZWRSZXN1bHQsXG4gICAgICBwdWJsaWNSZXF1ZXN0LFxuICAgICAgbW9ja2VkUmVzcG9uc2VcbiAgICApO1xuICB9XG4gIHdyYXBSZXNvbHZlcihyZXNvbHZlcikge1xuICAgIHJldHVybiBhc3luYyAocmVxLCByZXMsIGN0eCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXNvbHZlckdlbmVyYXRvciB8fCBhd2FpdCByZXNvbHZlcihyZXEsIHJlcywgY3R4KTtcbiAgICAgIGlmIChpc0l0ZXJhYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gcmVzdWx0W1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCk7XG4gICAgICAgIGNvbnN0IG5leHRSZXNwb25zZSA9IGF3YWl0IHZhbHVlO1xuICAgICAgICBpZiAoIW5leHRSZXNwb25zZSAmJiBkb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZXJHZW5lcmF0b3JSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJlc29sdmVyR2VuZXJhdG9yKSB7XG4gICAgICAgICAgdGhpcy5yZXNvbHZlckdlbmVyYXRvciA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc29sdmVyR2VuZXJhdG9yUmVzdWx0ID0gbmV4dFJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gbmV4dFJlc3BvbnNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG4gIGNyZWF0ZUV4ZWN1dGlvblJlc3VsdChwYXJzZWRSZXN1bHQsIHJlcXVlc3QsIHJlc3BvbnNlMikge1xuICAgIHJldHVybiB7XG4gICAgICBoYW5kbGVyOiB0aGlzLFxuICAgICAgcGFyc2VkUmVzdWx0OiBwYXJzZWRSZXN1bHQgfHwgbnVsbCxcbiAgICAgIHJlcXVlc3QsXG4gICAgICByZXNwb25zZTogcmVzcG9uc2UyIHx8IG51bGxcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvaGFuZGxlcnMvUmVzdEhhbmRsZXIudHNcbnZhciBSRVNUTWV0aG9kcyA9IC8qIEBfX1BVUkVfXyAqLyAoKFJFU1RNZXRob2RzMikgPT4ge1xuICBSRVNUTWV0aG9kczJbXCJIRUFEXCJdID0gXCJIRUFEXCI7XG4gIFJFU1RNZXRob2RzMltcIkdFVFwiXSA9IFwiR0VUXCI7XG4gIFJFU1RNZXRob2RzMltcIlBPU1RcIl0gPSBcIlBPU1RcIjtcbiAgUkVTVE1ldGhvZHMyW1wiUFVUXCJdID0gXCJQVVRcIjtcbiAgUkVTVE1ldGhvZHMyW1wiUEFUQ0hcIl0gPSBcIlBBVENIXCI7XG4gIFJFU1RNZXRob2RzMltcIk9QVElPTlNcIl0gPSBcIk9QVElPTlNcIjtcbiAgUkVTVE1ldGhvZHMyW1wiREVMRVRFXCJdID0gXCJERUxFVEVcIjtcbiAgcmV0dXJuIFJFU1RNZXRob2RzMjtcbn0pKFJFU1RNZXRob2RzIHx8IHt9KTtcbnZhciByZXN0Q29udGV4dCA9IHtcbiAgLi4uZGVmYXVsdENvbnRleHQsXG4gIGNvb2tpZSxcbiAgYm9keSxcbiAgdGV4dCxcbiAganNvbixcbiAgeG1sXG59O1xudmFyIFJlc3RSZXF1ZXN0ID0gY2xhc3MgZXh0ZW5kcyBNb2NrZWRSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IocmVxdWVzdCwgcGFyYW1zKSB7XG4gICAgc3VwZXIocmVxdWVzdC51cmwsIHtcbiAgICAgIC4uLnJlcXVlc3QsXG4gICAgICBib2R5OiByZXF1ZXN0W1wiX2JvZHlcIl1cbiAgICB9KTtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLmlkID0gcmVxdWVzdC5pZDtcbiAgfVxufTtcbnZhciBSZXN0SGFuZGxlciA9IGNsYXNzIGV4dGVuZHMgUmVxdWVzdEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihtZXRob2QsIHBhdGgsIHJlc29sdmVyKSB7XG4gICAgc3VwZXIoe1xuICAgICAgaW5mbzoge1xuICAgICAgICBoZWFkZXI6IGAke21ldGhvZH0gJHtwYXRofWAsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG1ldGhvZFxuICAgICAgfSxcbiAgICAgIGN0eDogcmVzdENvbnRleHQsXG4gICAgICByZXNvbHZlclxuICAgIH0pO1xuICAgIHRoaXMuY2hlY2tSZWR1bmRhbnRRdWVyeVBhcmFtZXRlcnMoKTtcbiAgfVxuICBjaGVja1JlZHVuZGFudFF1ZXJ5UGFyYW1ldGVycygpIHtcbiAgICBjb25zdCB7IG1ldGhvZCwgcGF0aCB9ID0gdGhpcy5pbmZvO1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGNsZWFuVXJsKHBhdGgpO1xuICAgIGlmICh1cmwgPT09IHBhdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gZ2V0U2VhcmNoUGFyYW1zKHBhdGgpO1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gW107XG4gICAgc2VhcmNoUGFyYW1zLmZvckVhY2goKF8sIHBhcmFtTmFtZSkgPT4ge1xuICAgICAgcXVlcnlQYXJhbXMucHVzaChwYXJhbU5hbWUpO1xuICAgIH0pO1xuICAgIGRldlV0aWxzLndhcm4oXG4gICAgICBgRm91bmQgYSByZWR1bmRhbnQgdXNhZ2Ugb2YgcXVlcnkgcGFyYW1ldGVycyBpbiB0aGUgcmVxdWVzdCBoYW5kbGVyIFVSTCBmb3IgXCIke21ldGhvZH0gJHtwYXRofVwiLiBQbGVhc2UgbWF0Y2ggYWdhaW5zdCBhIHBhdGggaW5zdGVhZCBhbmQgYWNjZXNzIHF1ZXJ5IHBhcmFtZXRlcnMgaW4gdGhlIHJlc3BvbnNlIHJlc29sdmVyIGZ1bmN0aW9uIHVzaW5nIFwicmVxLnVybC5zZWFyY2hQYXJhbXNcIi5gXG4gICAgKTtcbiAgfVxuICBwYXJzZShyZXF1ZXN0LCByZXNvbHV0aW9uQ29udGV4dCkge1xuICAgIHJldHVybiBtYXRjaFJlcXVlc3RVcmwoXG4gICAgICByZXF1ZXN0LnVybCxcbiAgICAgIHRoaXMuaW5mby5wYXRoLFxuICAgICAgcmVzb2x1dGlvbkNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc29sdXRpb25Db250ZXh0LmJhc2VVcmxcbiAgICApO1xuICB9XG4gIGdldFB1YmxpY1JlcXVlc3QocmVxdWVzdCwgcGFyc2VkUmVzdWx0KSB7XG4gICAgcmV0dXJuIG5ldyBSZXN0UmVxdWVzdChyZXF1ZXN0LCBwYXJzZWRSZXN1bHQucGFyYW1zIHx8IHt9KTtcbiAgfVxuICBwcmVkaWNhdGUocmVxdWVzdCwgcGFyc2VkUmVzdWx0KSB7XG4gICAgY29uc3QgbWF0Y2hlc01ldGhvZCA9IHRoaXMuaW5mby5tZXRob2QgaW5zdGFuY2VvZiBSZWdFeHAgPyB0aGlzLmluZm8ubWV0aG9kLnRlc3QocmVxdWVzdC5tZXRob2QpIDogaXNTdHJpbmdFcXVhbCh0aGlzLmluZm8ubWV0aG9kLCByZXF1ZXN0Lm1ldGhvZCk7XG4gICAgcmV0dXJuIG1hdGNoZXNNZXRob2QgJiYgcGFyc2VkUmVzdWx0Lm1hdGNoZXM7XG4gIH1cbiAgbG9nKHJlcXVlc3QsIHJlc3BvbnNlMikge1xuICAgIGNvbnN0IHB1YmxpY1VybCA9IGdldFB1YmxpY1VybEZyb21SZXF1ZXN0KHJlcXVlc3QpO1xuICAgIGNvbnN0IGxvZ2dlZFJlcXVlc3QgPSBwcmVwYXJlUmVxdWVzdChyZXF1ZXN0KTtcbiAgICBjb25zdCBsb2dnZWRSZXNwb25zZSA9IHByZXBhcmVSZXNwb25zZShyZXNwb25zZTIpO1xuICAgIGNvbnN0IHN0YXR1c0NvbG9yID0gZ2V0U3RhdHVzQ29kZUNvbG9yKHJlc3BvbnNlMi5zdGF0dXMpO1xuICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXG4gICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFwiJXMgJXMgJXMgKCVjJXMlYylcIiksXG4gICAgICBnZXRUaW1lc3RhbXAoKSxcbiAgICAgIHJlcXVlc3QubWV0aG9kLFxuICAgICAgcHVibGljVXJsLFxuICAgICAgYGNvbG9yOiR7c3RhdHVzQ29sb3J9YCxcbiAgICAgIGAke3Jlc3BvbnNlMi5zdGF0dXN9ICR7cmVzcG9uc2UyLnN0YXR1c1RleHR9YCxcbiAgICAgIFwiY29sb3I6aW5oZXJpdFwiXG4gICAgKTtcbiAgICBjb25zb2xlLmxvZyhcIlJlcXVlc3RcIiwgbG9nZ2VkUmVxdWVzdCk7XG4gICAgY29uc29sZS5sb2coXCJIYW5kbGVyOlwiLCB0aGlzKTtcbiAgICBjb25zb2xlLmxvZyhcIlJlc3BvbnNlXCIsIGxvZ2dlZFJlc3BvbnNlKTtcbiAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb250ZXh0L2ZpZWxkLnRzXG52YXIgaW1wb3J0X291dHZhcmlhbnQzID0gcmVxdWlyZShcIm91dHZhcmlhbnRcIik7XG52YXIgZmllbGQgPSAoZmllbGROYW1lLCBmaWVsZFZhbHVlKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgdmFsaWRhdGVGaWVsZE5hbWUoZmllbGROYW1lKTtcbiAgICBjb25zdCBwcmV2Qm9keSA9IGpzb25QYXJzZShyZXMuYm9keSkgfHwge307XG4gICAgY29uc3QgbmV4dEJvZHkgPSBtZXJnZVJpZ2h0KHByZXZCb2R5LCB7IFtmaWVsZE5hbWVdOiBmaWVsZFZhbHVlIH0pO1xuICAgIHJldHVybiBqc29uKG5leHRCb2R5KShyZXMpO1xuICB9O1xufTtcbmZ1bmN0aW9uIHZhbGlkYXRlRmllbGROYW1lKGZpZWxkTmFtZSkge1xuICAoMCwgaW1wb3J0X291dHZhcmlhbnQzLmludmFyaWFudCkoXG4gICAgZmllbGROYW1lLnRyaW0oKSAhPT0gXCJcIixcbiAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgXCJGYWlsZWQgdG8gc2V0IGEgY3VzdG9tIGZpZWxkIG9uIGEgR3JhcGhRTCByZXNwb25zZTogZmllbGQgbmFtZSBjYW5ub3QgYmUgZW1wdHkuXCJcbiAgICApXG4gICk7XG4gICgwLCBpbXBvcnRfb3V0dmFyaWFudDMuaW52YXJpYW50KShcbiAgICBmaWVsZE5hbWUgIT09IFwiZGF0YVwiLFxuICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAnRmFpbGVkIHRvIHNldCBhIGN1c3RvbSBcIiVzXCIgZmllbGQgb24gYSBtb2NrZWQgR3JhcGhRTCByZXNwb25zZTogZm9yYmlkZGVuIGZpZWxkIG5hbWUuIERpZCB5b3UgbWVhbiB0byBjYWxsIFwiY3R4LmRhdGEoKVwiIGluc3RlYWQ/JyxcbiAgICAgIGZpZWxkTmFtZVxuICAgIClcbiAgKTtcbiAgKDAsIGltcG9ydF9vdXR2YXJpYW50My5pbnZhcmlhbnQpKFxuICAgIGZpZWxkTmFtZSAhPT0gXCJlcnJvcnNcIixcbiAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgJ0ZhaWxlZCB0byBzZXQgYSBjdXN0b20gXCIlc1wiIGZpZWxkIG9uIGEgbW9ja2VkIEdyYXBoUUwgcmVzcG9uc2U6IGZvcmJpZGRlbiBmaWVsZCBuYW1lLiBEaWQgeW91IG1lYW4gdG8gY2FsbCBcImN0eC5lcnJvcnMoKVwiIGluc3RlYWQ/JyxcbiAgICAgIGZpZWxkTmFtZVxuICAgIClcbiAgKTtcbiAgKDAsIGltcG9ydF9vdXR2YXJpYW50My5pbnZhcmlhbnQpKFxuICAgIGZpZWxkTmFtZSAhPT0gXCJleHRlbnNpb25zXCIsXG4gICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICdGYWlsZWQgdG8gc2V0IGEgY3VzdG9tIFwiJXNcIiBmaWVsZCBvbiBhIG1vY2tlZCBHcmFwaFFMIHJlc3BvbnNlOiBmb3JiaWRkZW4gZmllbGQgbmFtZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgXCJjdHguZXh0ZW5zaW9ucygpXCIgaW5zdGVhZD8nLFxuICAgICAgZmllbGROYW1lXG4gICAgKVxuICApO1xufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvdHJ5Q2F0Y2gudHNcbmZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvbkV4Y2VwdGlvbikge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGZuKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgb25FeGNlcHRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IG9uRXhjZXB0aW9uKGVycm9yMik7XG4gIH1cbn1cblxuLy8gc3JjL2hhbmRsZXJzL0dyYXBoUUxIYW5kbGVyLnRzXG52YXIgZ3JhcGhxbENvbnRleHQgPSB7XG4gIC4uLmRlZmF1bHRDb250ZXh0LFxuICBkYXRhLFxuICBleHRlbnNpb25zLFxuICBlcnJvcnMsXG4gIGNvb2tpZSxcbiAgZmllbGRcbn07XG5mdW5jdGlvbiBpc0RvY3VtZW50Tm9kZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwia2luZFwiIGluIHZhbHVlICYmIFwiZGVmaW5pdGlvbnNcIiBpbiB2YWx1ZTtcbn1cbnZhciBHcmFwaFFMUmVxdWVzdCA9IGNsYXNzIGV4dGVuZHMgTW9ja2VkUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yKHJlcXVlc3QsIHZhcmlhYmxlcywgb3BlcmF0aW9uTmFtZSkge1xuICAgIHN1cGVyKHJlcXVlc3QudXJsLCB7XG4gICAgICAuLi5yZXF1ZXN0LFxuICAgICAgYm9keTogcmVxdWVzdFtcIl9ib2R5XCJdXG4gICAgfSk7XG4gICAgdGhpcy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgdGhpcy5vcGVyYXRpb25OYW1lID0gb3BlcmF0aW9uTmFtZTtcbiAgfVxufTtcbnZhciBHcmFwaFFMSGFuZGxlciA9IGNsYXNzIGV4dGVuZHMgUmVxdWVzdEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihvcGVyYXRpb25UeXBlLCBvcGVyYXRpb25OYW1lLCBlbmRwb2ludCwgcmVzb2x2ZXIpIHtcbiAgICBsZXQgcmVzb2x2ZWRPcGVyYXRpb25OYW1lID0gb3BlcmF0aW9uTmFtZTtcbiAgICBpZiAoaXNEb2N1bWVudE5vZGUob3BlcmF0aW9uTmFtZSkpIHtcbiAgICAgIGNvbnN0IHBhcnNlZE5vZGUgPSBwYXJzZURvY3VtZW50Tm9kZShvcGVyYXRpb25OYW1lKTtcbiAgICAgIGlmIChwYXJzZWROb2RlLm9wZXJhdGlvblR5cGUgIT09IG9wZXJhdGlvblR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gY3JlYXRlIGEgR3JhcGhRTCBoYW5kbGVyOiBwcm92aWRlZCBhIERvY3VtZW50Tm9kZSB3aXRoIGEgbWlzbWF0Y2hlZCBvcGVyYXRpb24gdHlwZSAoZXhwZWN0ZWQgXCIke29wZXJhdGlvblR5cGV9XCIsIGJ1dCBnb3QgXCIke3BhcnNlZE5vZGUub3BlcmF0aW9uVHlwZX1cIikuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCFwYXJzZWROb2RlLm9wZXJhdGlvbk5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gY3JlYXRlIGEgR3JhcGhRTCBoYW5kbGVyOiBwcm92aWRlZCBhIERvY3VtZW50Tm9kZSB3aXRoIG5vIG9wZXJhdGlvbiBuYW1lLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmVkT3BlcmF0aW9uTmFtZSA9IHBhcnNlZE5vZGUub3BlcmF0aW9uTmFtZTtcbiAgICB9XG4gICAgY29uc3QgaGVhZGVyID0gb3BlcmF0aW9uVHlwZSA9PT0gXCJhbGxcIiA/IGAke29wZXJhdGlvblR5cGV9IChvcmlnaW46ICR7ZW5kcG9pbnQudG9TdHJpbmcoKX0pYCA6IGAke29wZXJhdGlvblR5cGV9ICR7cmVzb2x2ZWRPcGVyYXRpb25OYW1lfSAob3JpZ2luOiAke2VuZHBvaW50LnRvU3RyaW5nKCl9KWA7XG4gICAgc3VwZXIoe1xuICAgICAgaW5mbzoge1xuICAgICAgICBoZWFkZXIsXG4gICAgICAgIG9wZXJhdGlvblR5cGUsXG4gICAgICAgIG9wZXJhdGlvbk5hbWU6IHJlc29sdmVkT3BlcmF0aW9uTmFtZVxuICAgICAgfSxcbiAgICAgIGN0eDogZ3JhcGhxbENvbnRleHQsXG4gICAgICByZXNvbHZlclxuICAgIH0pO1xuICAgIHRoaXMuZW5kcG9pbnQgPSBlbmRwb2ludDtcbiAgfVxuICBwYXJzZShyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRyeUNhdGNoKFxuICAgICAgKCkgPT4gcGFyc2VHcmFwaFFMUmVxdWVzdChyZXF1ZXN0KSxcbiAgICAgIChlcnJvcjIpID0+IGNvbnNvbGUuZXJyb3IoZXJyb3IyLm1lc3NhZ2UpXG4gICAgKTtcbiAgfVxuICBnZXRQdWJsaWNSZXF1ZXN0KHJlcXVlc3QsIHBhcnNlZFJlc3VsdCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIG5ldyBHcmFwaFFMUmVxdWVzdChcbiAgICAgIHJlcXVlc3QsXG4gICAgICAoX2EgPSBwYXJzZWRSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcnNlZFJlc3VsdC52YXJpYWJsZXMpICE9IG51bGwgPyBfYSA6IHt9LFxuICAgICAgKF9iID0gcGFyc2VkUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRSZXN1bHQub3BlcmF0aW9uTmFtZSkgIT0gbnVsbCA/IF9iIDogXCJcIlxuICAgICk7XG4gIH1cbiAgcHJlZGljYXRlKHJlcXVlc3QsIHBhcnNlZFJlc3VsdCkge1xuICAgIGlmICghcGFyc2VkUmVzdWx0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghcGFyc2VkUmVzdWx0Lm9wZXJhdGlvbk5hbWUgJiYgdGhpcy5pbmZvLm9wZXJhdGlvblR5cGUgIT09IFwiYWxsXCIpIHtcbiAgICAgIGNvbnN0IHB1YmxpY1VybCA9IGdldFB1YmxpY1VybEZyb21SZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgZGV2VXRpbHMud2FybihgRmFpbGVkIHRvIGludGVyY2VwdCBhIEdyYXBoUUwgcmVxdWVzdCBhdCBcIiR7cmVxdWVzdC5tZXRob2R9ICR7cHVibGljVXJsfVwiOiBhbm9ueW1vdXMgR3JhcGhRTCBvcGVyYXRpb25zIGFyZSBub3Qgc3VwcG9ydGVkLlxuXG5Db25zaWRlciBuYW1pbmcgdGhpcyBvcGVyYXRpb24gb3IgdXNpbmcgXCJncmFwaHFsLm9wZXJhdGlvbigpXCIgcmVxdWVzdCBoYW5kbGVyIHRvIGludGVyY2VwdCBHcmFwaFFMIHJlcXVlc3RzIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgb3BlcmF0aW9uIG5hbWUvdHlwZS4gUmVhZCBtb3JlOiBodHRwczovL21zd2pzLmlvL2RvY3MvYXBpL2dyYXBocWwvb3BlcmF0aW9uICAgICAgYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGhhc01hdGNoaW5nVXJsID0gbWF0Y2hSZXF1ZXN0VXJsKHJlcXVlc3QudXJsLCB0aGlzLmVuZHBvaW50KTtcbiAgICBjb25zdCBoYXNNYXRjaGluZ09wZXJhdGlvblR5cGUgPSB0aGlzLmluZm8ub3BlcmF0aW9uVHlwZSA9PT0gXCJhbGxcIiB8fCBwYXJzZWRSZXN1bHQub3BlcmF0aW9uVHlwZSA9PT0gdGhpcy5pbmZvLm9wZXJhdGlvblR5cGU7XG4gICAgY29uc3QgaGFzTWF0Y2hpbmdPcGVyYXRpb25OYW1lID0gdGhpcy5pbmZvLm9wZXJhdGlvbk5hbWUgaW5zdGFuY2VvZiBSZWdFeHAgPyB0aGlzLmluZm8ub3BlcmF0aW9uTmFtZS50ZXN0KHBhcnNlZFJlc3VsdC5vcGVyYXRpb25OYW1lIHx8IFwiXCIpIDogcGFyc2VkUmVzdWx0Lm9wZXJhdGlvbk5hbWUgPT09IHRoaXMuaW5mby5vcGVyYXRpb25OYW1lO1xuICAgIHJldHVybiBoYXNNYXRjaGluZ1VybC5tYXRjaGVzICYmIGhhc01hdGNoaW5nT3BlcmF0aW9uVHlwZSAmJiBoYXNNYXRjaGluZ09wZXJhdGlvbk5hbWU7XG4gIH1cbiAgbG9nKHJlcXVlc3QsIHJlc3BvbnNlMiwgcGFyc2VkUmVxdWVzdCkge1xuICAgIGNvbnN0IGxvZ2dlZFJlcXVlc3QgPSBwcmVwYXJlUmVxdWVzdChyZXF1ZXN0KTtcbiAgICBjb25zdCBsb2dnZWRSZXNwb25zZSA9IHByZXBhcmVSZXNwb25zZShyZXNwb25zZTIpO1xuICAgIGNvbnN0IHN0YXR1c0NvbG9yID0gZ2V0U3RhdHVzQ29kZUNvbG9yKHJlc3BvbnNlMi5zdGF0dXMpO1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gKHBhcnNlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcnNlZFJlcXVlc3Qub3BlcmF0aW9uTmFtZSkgPyBgJHtwYXJzZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRSZXF1ZXN0Lm9wZXJhdGlvblR5cGV9ICR7cGFyc2VkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkUmVxdWVzdC5vcGVyYXRpb25OYW1lfWAgOiBgYW5vbnltb3VzICR7cGFyc2VkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkUmVxdWVzdC5vcGVyYXRpb25UeXBlfWA7XG4gICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcbiAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXCIlcyAlcyAoJWMlcyVjKVwiKSxcbiAgICAgIGdldFRpbWVzdGFtcCgpLFxuICAgICAgYCR7cmVxdWVzdEluZm99YCxcbiAgICAgIGBjb2xvcjoke3N0YXR1c0NvbG9yfWAsXG4gICAgICBgJHtyZXNwb25zZTIuc3RhdHVzfSAke3Jlc3BvbnNlMi5zdGF0dXNUZXh0fWAsXG4gICAgICBcImNvbG9yOmluaGVyaXRcIlxuICAgICk7XG4gICAgY29uc29sZS5sb2coXCJSZXF1ZXN0OlwiLCBsb2dnZWRSZXF1ZXN0KTtcbiAgICBjb25zb2xlLmxvZyhcIkhhbmRsZXI6XCIsIHRoaXMpO1xuICAgIGNvbnNvbGUubG9nKFwiUmVzcG9uc2U6XCIsIGxvZ2dlZFJlc3BvbnNlKTtcbiAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L29uVW5oYW5kbGVkUmVxdWVzdC50c1xudmFyIE1BWF9NQVRDSF9TQ09SRSA9IDM7XG52YXIgTUFYX1NVR0dFU1RJT05fQ09VTlQgPSA0O1xudmFyIFRZUEVfTUFUQ0hfREVMVEEgPSAwLjU7XG5mdW5jdGlvbiBncm91cEhhbmRsZXJzQnlUeXBlKGhhbmRsZXJzKSB7XG4gIHJldHVybiBoYW5kbGVycy5yZWR1Y2UoXG4gICAgKGdyb3VwcywgaGFuZGxlcikgPT4ge1xuICAgICAgaWYgKGhhbmRsZXIgaW5zdGFuY2VvZiBSZXN0SGFuZGxlcikge1xuICAgICAgICBncm91cHMucmVzdC5wdXNoKGhhbmRsZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGhhbmRsZXIgaW5zdGFuY2VvZiBHcmFwaFFMSGFuZGxlcikge1xuICAgICAgICBncm91cHMuZ3JhcGhxbC5wdXNoKGhhbmRsZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9LFxuICAgIHtcbiAgICAgIHJlc3Q6IFtdLFxuICAgICAgZ3JhcGhxbDogW11cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBnZXRSZXN0SGFuZGxlclNjb3JlKCkge1xuICByZXR1cm4gKHJlcXVlc3QsIGhhbmRsZXIpID0+IHtcbiAgICBjb25zdCB7IHBhdGgsIG1ldGhvZCB9ID0gaGFuZGxlci5pbmZvO1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwIHx8IG1ldGhvZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICBjb25zdCBoYXNTYW1lTWV0aG9kID0gaXNTdHJpbmdFcXVhbChyZXF1ZXN0Lm1ldGhvZCwgbWV0aG9kKTtcbiAgICBjb25zdCBtZXRob2RTY29yZURlbHRhID0gaGFzU2FtZU1ldGhvZCA/IFRZUEVfTUFUQ0hfREVMVEEgOiAwO1xuICAgIGNvbnN0IHJlcXVlc3RQdWJsaWNVcmwgPSBnZXRQdWJsaWNVcmxGcm9tUmVxdWVzdChyZXF1ZXN0KTtcbiAgICBjb25zdCBzY29yZSA9ICgwLCBpbXBvcnRfanNfbGV2ZW5zaHRlaW4uZGVmYXVsdCkocmVxdWVzdFB1YmxpY1VybCwgcGF0aCk7XG4gICAgcmV0dXJuIHNjb3JlIC0gbWV0aG9kU2NvcmVEZWx0YTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEdyYXBoUUxIYW5kbGVyU2NvcmUocGFyc2VkUXVlcnkpIHtcbiAgcmV0dXJuIChfLCBoYW5kbGVyKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwYXJzZWRRdWVyeS5vcGVyYXRpb25OYW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIGNvbnN0IHsgb3BlcmF0aW9uVHlwZSwgb3BlcmF0aW9uTmFtZSB9ID0gaGFuZGxlci5pbmZvO1xuICAgIGlmICh0eXBlb2Ygb3BlcmF0aW9uTmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICBjb25zdCBoYXNTYW1lT3BlcmF0aW9uVHlwZSA9IHBhcnNlZFF1ZXJ5Lm9wZXJhdGlvblR5cGUgPT09IG9wZXJhdGlvblR5cGU7XG4gICAgY29uc3Qgb3BlcmF0aW9uVHlwZVNjb3JlRGVsdGEgPSBoYXNTYW1lT3BlcmF0aW9uVHlwZSA/IFRZUEVfTUFUQ0hfREVMVEEgOiAwO1xuICAgIGNvbnN0IHNjb3JlID0gKDAsIGltcG9ydF9qc19sZXZlbnNodGVpbi5kZWZhdWx0KShwYXJzZWRRdWVyeS5vcGVyYXRpb25OYW1lLCBvcGVyYXRpb25OYW1lKTtcbiAgICByZXR1cm4gc2NvcmUgLSBvcGVyYXRpb25UeXBlU2NvcmVEZWx0YTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFN1Z2dlc3RlZEhhbmRsZXIocmVxdWVzdCwgaGFuZGxlcnMsIGdldFNjb3JlKSB7XG4gIGNvbnN0IHN1Z2dlc3RlZEhhbmRsZXJzID0gaGFuZGxlcnMucmVkdWNlKChzdWdnZXN0aW9ucywgaGFuZGxlcikgPT4ge1xuICAgIGNvbnN0IHNjb3JlID0gZ2V0U2NvcmUocmVxdWVzdCwgaGFuZGxlcik7XG4gICAgcmV0dXJuIHN1Z2dlc3Rpb25zLmNvbmNhdChbW3Njb3JlLCBoYW5kbGVyXV0pO1xuICB9LCBbXSkuc29ydCgoW2xlZnRTY29yZV0sIFtyaWdodFNjb3JlXSkgPT4gbGVmdFNjb3JlIC0gcmlnaHRTY29yZSkuZmlsdGVyKChbc2NvcmVdKSA9PiBzY29yZSA8PSBNQVhfTUFUQ0hfU0NPUkUpLnNsaWNlKDAsIE1BWF9TVUdHRVNUSU9OX0NPVU5UKS5tYXAoKFssIGhhbmRsZXJdKSA9PiBoYW5kbGVyKTtcbiAgcmV0dXJuIHN1Z2dlc3RlZEhhbmRsZXJzO1xufVxuZnVuY3Rpb24gZ2V0U3VnZ2VzdGVkSGFuZGxlcnNNZXNzYWdlKGhhbmRsZXJzKSB7XG4gIGlmIChoYW5kbGVycy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGBEaWQgeW91IG1lYW4gdG8gcmVxdWVzdCBvbmUgb2YgdGhlIGZvbGxvd2luZyByZXNvdXJjZXMgaW5zdGVhZD9cblxuJHtoYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGAgIFxcdTIwMjIgJHtoYW5kbGVyLmluZm8uaGVhZGVyfWApLmpvaW4oXCJcXG5cIil9YDtcbiAgfVxuICByZXR1cm4gYERpZCB5b3UgbWVhbiB0byByZXF1ZXN0IFwiJHtoYW5kbGVyc1swXS5pbmZvLmhlYWRlcn1cIiBpbnN0ZWFkP2A7XG59XG5mdW5jdGlvbiBvblVuaGFuZGxlZFJlcXVlc3QocmVxdWVzdCwgaGFuZGxlcnMsIHN0cmF0ZWd5ID0gXCJ3YXJuXCIpIHtcbiAgY29uc3QgcGFyc2VkR3JhcGhRTFF1ZXJ5ID0gdHJ5Q2F0Y2goKCkgPT4gcGFyc2VHcmFwaFFMUmVxdWVzdChyZXF1ZXN0KSk7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlSGFuZGxlclN1Z2dlc3Rpb24oKSB7XG4gICAgY29uc3QgaGFuZGxlckdyb3VwcyA9IGdyb3VwSGFuZGxlcnNCeVR5cGUoaGFuZGxlcnMpO1xuICAgIGNvbnN0IHJlbGV2YW50SGFuZGxlcnMgPSBwYXJzZWRHcmFwaFFMUXVlcnkgPyBoYW5kbGVyR3JvdXBzLmdyYXBocWwgOiBoYW5kbGVyR3JvdXBzLnJlc3Q7XG4gICAgY29uc3Qgc3VnZ2VzdGVkSGFuZGxlcnMgPSBnZXRTdWdnZXN0ZWRIYW5kbGVyKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHJlbGV2YW50SGFuZGxlcnMsXG4gICAgICBwYXJzZWRHcmFwaFFMUXVlcnkgPyBnZXRHcmFwaFFMSGFuZGxlclNjb3JlKHBhcnNlZEdyYXBoUUxRdWVyeSkgOiBnZXRSZXN0SGFuZGxlclNjb3JlKClcbiAgICApO1xuICAgIHJldHVybiBzdWdnZXN0ZWRIYW5kbGVycy5sZW5ndGggPiAwID8gZ2V0U3VnZ2VzdGVkSGFuZGxlcnNNZXNzYWdlKHN1Z2dlc3RlZEhhbmRsZXJzKSA6IFwiXCI7XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVVbmhhbmRsZWRSZXF1ZXN0TWVzc2FnZSgpIHtcbiAgICBjb25zdCBwdWJsaWNVcmwgPSBnZXRQdWJsaWNVcmxGcm9tUmVxdWVzdChyZXF1ZXN0KTtcbiAgICBjb25zdCByZXF1ZXN0SGVhZGVyID0gcGFyc2VkR3JhcGhRTFF1ZXJ5ID8gYCR7cGFyc2VkR3JhcGhRTFF1ZXJ5Lm9wZXJhdGlvblR5cGV9ICR7cGFyc2VkR3JhcGhRTFF1ZXJ5Lm9wZXJhdGlvbk5hbWV9ICgke3JlcXVlc3QubWV0aG9kfSAke3B1YmxpY1VybH0pYCA6IGAke3JlcXVlc3QubWV0aG9kfSAke3B1YmxpY1VybH1gO1xuICAgIGNvbnN0IGhhbmRsZXJTdWdnZXN0aW9uID0gZ2VuZXJhdGVIYW5kbGVyU3VnZ2VzdGlvbigpO1xuICAgIGNvbnN0IG1lc3NhZ2VUZW1wbGF0ZSA9IFtcbiAgICAgIGBjYXB0dXJlZCBhIHJlcXVlc3Qgd2l0aG91dCBhIG1hdGNoaW5nIHJlcXVlc3QgaGFuZGxlcjpgLFxuICAgICAgYCAgXFx1MjAyMiAke3JlcXVlc3RIZWFkZXJ9YCxcbiAgICAgIGhhbmRsZXJTdWdnZXN0aW9uLFxuICAgICAgYElmIHlvdSBzdGlsbCB3aXNoIHRvIGludGVyY2VwdCB0aGlzIHVuaGFuZGxlZCByZXF1ZXN0LCBwbGVhc2UgY3JlYXRlIGEgcmVxdWVzdCBoYW5kbGVyIGZvciBpdC5cblJlYWQgbW9yZTogaHR0cHM6Ly9tc3dqcy5pby9kb2NzL2dldHRpbmctc3RhcnRlZC9tb2Nrc2BcbiAgICBdLmZpbHRlcihCb29sZWFuKTtcbiAgICByZXR1cm4gbWVzc2FnZVRlbXBsYXRlLmpvaW4oXCJcXG5cXG5cIik7XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlTdHJhdGVneShzdHJhdGVneTIpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2VuZXJhdGVVbmhhbmRsZWRSZXF1ZXN0TWVzc2FnZSgpO1xuICAgIHN3aXRjaCAoc3RyYXRlZ3kyKSB7XG4gICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICBkZXZVdGlscy5lcnJvcihcIkVycm9yOiAlc1wiLCBtZXNzYWdlKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgICAnQ2Fubm90IGJ5cGFzcyBhIHJlcXVlc3Qgd2hlbiB1c2luZyB0aGUgXCJlcnJvclwiIHN0cmF0ZWd5IGZvciB0aGUgXCJvblVuaGFuZGxlZFJlcXVlc3RcIiBvcHRpb24uJ1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ3YXJuXCI6IHtcbiAgICAgICAgZGV2VXRpbHMud2FybihcIldhcm5pbmc6ICVzXCIsIG1lc3NhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJieXBhc3NcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICAgICdGYWlsZWQgdG8gcmVhY3QgdG8gYW4gdW5oYW5kbGVkIHJlcXVlc3Q6IHVua25vd24gc3RyYXRlZ3kgXCIlc1wiLiBQbGVhc2UgcHJvdmlkZSBvbmUgb2YgdGhlIHN1cHBvcnRlZCBzdHJhdGVnaWVzIChcImJ5cGFzc1wiLCBcIndhcm5cIiwgXCJlcnJvclwiKSBvciBhIGN1c3RvbSBjYWxsYmFjayBmdW5jdGlvbiBhcyB0aGUgdmFsdWUgb2YgdGhlIFwib25VbmhhbmRsZWRSZXF1ZXN0XCIgb3B0aW9uLicsXG4gICAgICAgICAgICBzdHJhdGVneTJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygc3RyYXRlZ3kgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHN0cmF0ZWd5KHJlcXVlc3QsIHtcbiAgICAgIHdhcm5pbmc6IGFwcGx5U3RyYXRlZ3kuYmluZChudWxsLCBcIndhcm5cIiksXG4gICAgICBlcnJvcjogYXBwbHlTdHJhdGVneS5iaW5kKG51bGwsIFwiZXJyb3JcIilcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgYXBwbHlTdHJhdGVneShzdHJhdGVneSk7XG59XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L3JlYWRSZXNwb25zZUNvb2tpZXMudHNcbnZhciBpbXBvcnRfY29va2llczIgPSByZXF1aXJlKFwiQG1zd2pzL2Nvb2tpZXNcIik7XG5mdW5jdGlvbiByZWFkUmVzcG9uc2VDb29raWVzKHJlcXVlc3QsIHJlc3BvbnNlMikge1xuICBpbXBvcnRfY29va2llczIuc3RvcmUuYWRkKHsgLi4ucmVxdWVzdCwgdXJsOiByZXF1ZXN0LnVybC50b1N0cmluZygpIH0sIHJlc3BvbnNlMik7XG4gIGltcG9ydF9jb29raWVzMi5zdG9yZS5wZXJzaXN0KCk7XG59XG5cbi8vIHNyYy91dGlscy9oYW5kbGVSZXF1ZXN0LnRzXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0KHJlcXVlc3QsIGhhbmRsZXJzLCBvcHRpb25zLCBlbWl0dGVyLCBoYW5kbGVSZXF1ZXN0T3B0aW9ucykge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDpzdGFydFwiLCByZXF1ZXN0KTtcbiAgaWYgKHJlcXVlc3QuaGVhZGVycy5nZXQoXCJ4LW1zdy1ieXBhc3NcIikgPT09IFwidHJ1ZVwiKSB7XG4gICAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDplbmRcIiwgcmVxdWVzdCk7XG4gICAgKF9hID0gaGFuZGxlUmVxdWVzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVJlcXVlc3RPcHRpb25zLm9uUGFzc3Rocm91Z2hSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoaGFuZGxlUmVxdWVzdE9wdGlvbnMsIHJlcXVlc3QpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBbbG9va3VwRXJyb3IsIGxvb2t1cFJlc3VsdF0gPSBhd2FpdCAoMCwgaW1wb3J0X3VudGlsMi51bnRpbCkoKCkgPT4ge1xuICAgIHJldHVybiBnZXRSZXNwb25zZShcbiAgICAgIHJlcXVlc3QsXG4gICAgICBoYW5kbGVycyxcbiAgICAgIGhhbmRsZVJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVSZXF1ZXN0T3B0aW9ucy5yZXNvbHV0aW9uQ29udGV4dFxuICAgICk7XG4gIH0pO1xuICBpZiAobG9va3VwRXJyb3IpIHtcbiAgICBlbWl0dGVyLmVtaXQoXCJ1bmhhbmRsZWRFeGNlcHRpb25cIiwgbG9va3VwRXJyb3IsIHJlcXVlc3QpO1xuICAgIHRocm93IGxvb2t1cEVycm9yO1xuICB9XG4gIGNvbnN0IHsgaGFuZGxlciwgcmVzcG9uc2U6IHJlc3BvbnNlMiB9ID0gbG9va3VwUmVzdWx0O1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICBvblVuaGFuZGxlZFJlcXVlc3QocmVxdWVzdCwgaGFuZGxlcnMsIG9wdGlvbnMub25VbmhhbmRsZWRSZXF1ZXN0KTtcbiAgICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0OnVuaGFuZGxlZFwiLCByZXF1ZXN0KTtcbiAgICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0OmVuZFwiLCByZXF1ZXN0KTtcbiAgICAoX2IgPSBoYW5kbGVSZXF1ZXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUmVxdWVzdE9wdGlvbnMub25QYXNzdGhyb3VnaFJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChoYW5kbGVSZXF1ZXN0T3B0aW9ucywgcmVxdWVzdCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghcmVzcG9uc2UyKSB7XG4gICAgZGV2VXRpbHMud2FybihcbiAgICAgIGBFeHBlY3RlZCByZXNwb25zZSByZXNvbHZlciB0byByZXR1cm4gYSBtb2NrZWQgcmVzcG9uc2UgT2JqZWN0LCBidXQgZ290ICVzLiBUaGUgb3JpZ2luYWwgcmVzcG9uc2UgaXMgZ29pbmcgdG8gYmUgdXNlZCBpbnN0ZWFkLlxuXG4gIFxcdTIwMjIgJXNcbiAgICAlc2AsXG4gICAgICByZXNwb25zZTIsXG4gICAgICBoYW5kbGVyLmluZm8uaGVhZGVyLFxuICAgICAgaGFuZGxlci5pbmZvLmNhbGxGcmFtZVxuICAgICk7XG4gICAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDplbmRcIiwgcmVxdWVzdCk7XG4gICAgKF9jID0gaGFuZGxlUmVxdWVzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVJlcXVlc3RPcHRpb25zLm9uUGFzc3Rocm91Z2hSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwoaGFuZGxlUmVxdWVzdE9wdGlvbnMsIHJlcXVlc3QpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmVzcG9uc2UyLnBhc3N0aHJvdWdoKSB7XG4gICAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDplbmRcIiwgcmVxdWVzdCk7XG4gICAgKF9kID0gaGFuZGxlUmVxdWVzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVJlcXVlc3RPcHRpb25zLm9uUGFzc3Rocm91Z2hSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmNhbGwoaGFuZGxlUmVxdWVzdE9wdGlvbnMsIHJlcXVlc3QpO1xuICAgIHJldHVybjtcbiAgfVxuICByZWFkUmVzcG9uc2VDb29raWVzKHJlcXVlc3QsIHJlc3BvbnNlMik7XG4gIGVtaXR0ZXIuZW1pdChcInJlcXVlc3Q6bWF0Y2hcIiwgcmVxdWVzdCk7XG4gIGNvbnN0IHJlcXVpcmVkTG9va3VwUmVzdWx0ID0gbG9va3VwUmVzdWx0O1xuICBjb25zdCB0cmFuc2Zvcm1lZFJlc3BvbnNlID0gKChfZSA9IGhhbmRsZVJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVSZXF1ZXN0T3B0aW9ucy50cmFuc2Zvcm1SZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmNhbGwoaGFuZGxlUmVxdWVzdE9wdGlvbnMsIHJlc3BvbnNlMikpIHx8IHJlc3BvbnNlMjtcbiAgKF9mID0gaGFuZGxlUmVxdWVzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVJlcXVlc3RPcHRpb25zLm9uTW9ja2VkUmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZi5jYWxsKFxuICAgIGhhbmRsZVJlcXVlc3RPcHRpb25zLFxuICAgIHRyYW5zZm9ybWVkUmVzcG9uc2UsXG4gICAgcmVxdWlyZWRMb29rdXBSZXN1bHRcbiAgKTtcbiAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDplbmRcIiwgcmVxdWVzdCk7XG4gIHJldHVybiB0cmFuc2Zvcm1lZFJlc3BvbnNlO1xufVxuXG4vLyBzcmMvdXRpbHMvbG9nZ2luZy9zZXJpYWxpemVSZXNwb25zZS50c1xudmFyIGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsOSA9IHJlcXVpcmUoXCJoZWFkZXJzLXBvbHlmaWxsXCIpO1xuYXN5bmMgZnVuY3Rpb24gc2VyaWFsaXplUmVzcG9uc2UocmVzcG9uc2UyKSB7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzOiByZXNwb25zZTIuc3RhdHVzLFxuICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlMi5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6ICgwLCBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDkuZmxhdHRlbkhlYWRlcnNPYmplY3QpKCgwLCBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDkuaGVhZGVyc1RvT2JqZWN0KShyZXNwb25zZTIuaGVhZGVycykpLFxuICAgIGJvZHk6IGF3YWl0IHJlc3BvbnNlMi5jbG9uZSgpLnRleHQoKVxuICB9O1xufVxuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvY3JlYXRlUmVxdWVzdExpc3RlbmVyLnRzXG52YXIgY3JlYXRlUmVxdWVzdExpc3RlbmVyID0gKGNvbnRleHQsIG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIGFzeW5jIChldmVudCwgbWVzc2FnZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBtZXNzYWdlQ2hhbm5lbCA9IG5ldyBXb3JrZXJDaGFubmVsKGV2ZW50LnBvcnRzWzBdKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gcGFyc2VXb3JrZXJSZXF1ZXN0KG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGhhbmRsZVJlcXVlc3QoXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGNvbnRleHQucmVxdWVzdEhhbmRsZXJzLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBjb250ZXh0LmVtaXR0ZXIsXG4gICAgICAgIHtcbiAgICAgICAgICB0cmFuc2Zvcm1SZXNwb25zZSxcbiAgICAgICAgICBvblBhc3N0aHJvdWdoUmVzcG9uc2UoKSB7XG4gICAgICAgICAgICBtZXNzYWdlQ2hhbm5lbC5wb3N0TWVzc2FnZShcIk5PVF9GT1VORFwiKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFzeW5jIG9uTW9ja2VkUmVzcG9uc2UocmVzcG9uc2UyLCB7IGhhbmRsZXIsIHB1YmxpY1JlcXVlc3QsIHBhcnNlZFJlcXVlc3QgfSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlMi5ib2R5IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIGNvbnN0cnVjdCBhIG1vY2tlZCByZXNwb25zZSB3aXRoIGEgXCJSZWFkYWJsZVN0cmVhbVwiIGJvZHk6IG1vY2tlZCBzdHJlYW1zIGFyZSBub3Qgc3VwcG9ydGVkLiBGb2xsb3cgaHR0cHM6Ly9naXRodWIuY29tL21zd2pzL21zdy9pc3N1ZXMvMTMzNiBmb3IgbW9yZSBkZXRhaWxzLidcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUluc3RhbmNlID0gbmV3IFJlc3BvbnNlKHJlc3BvbnNlMi5ib2R5LCByZXNwb25zZTIpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VGb3JMb2dzID0gcmVzcG9uc2VJbnN0YW5jZS5jbG9uZSgpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5QnVmZmVyID0gYXdhaXQgcmVzcG9uc2VJbnN0YW5jZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gcmVzcG9uc2UyLmJvZHkgPT0gbnVsbCA/IG51bGwgOiByZXNwb25zZUJvZHlCdWZmZXI7XG4gICAgICAgICAgICBtZXNzYWdlQ2hhbm5lbC5wb3N0TWVzc2FnZShcbiAgICAgICAgICAgICAgXCJNT0NLX1JFU1BPTlNFXCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAuLi5yZXNwb25zZTIsXG4gICAgICAgICAgICAgICAgYm9keTogcmVzcG9uc2VCb2R5XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFtyZXNwb25zZUJvZHlCdWZmZXJdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnF1aWV0KSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci5vbmNlKFwicmVzcG9uc2U6bW9ja2VkXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmxvZyhcbiAgICAgICAgICAgICAgICAgIHB1YmxpY1JlcXVlc3QsXG4gICAgICAgICAgICAgICAgICBhd2FpdCBzZXJpYWxpemVSZXNwb25zZShyZXNwb25zZUZvckxvZ3MpLFxuICAgICAgICAgICAgICAgICAgcGFyc2VkUmVxdWVzdFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgIGlmIChlcnJvcjIgaW5zdGFuY2VvZiBOZXR3b3JrRXJyb3IpIHtcbiAgICAgICAgbWVzc2FnZUNoYW5uZWwucG9zdE1lc3NhZ2UoXCJORVRXT1JLX0VSUk9SXCIsIHtcbiAgICAgICAgICBuYW1lOiBlcnJvcjIubmFtZSxcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvcjIubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yMiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGRldlV0aWxzLmVycm9yKFxuICAgICAgICAgIGBVbmNhdWdodCBleGNlcHRpb24gaW4gdGhlIHJlcXVlc3QgaGFuZGxlciBmb3IgXCIlcyAlc1wiOlxuXG4lc1xuXG5UaGlzIGV4Y2VwdGlvbiBoYXMgYmVlbiBncmFjZWZ1bGx5IGhhbmRsZWQgYXMgYSA1MDAgcmVzcG9uc2UsIGhvd2V2ZXIsIGl0J3Mgc3Ryb25nbHkgcmVjb21tZW5kZWQgdG8gcmVzb2x2ZSB0aGlzIGVycm9yLCBhcyBpdCBpbmRpY2F0ZXMgYSBtaXN0YWtlIGluIHlvdXIgY29kZS4gSWYgeW91IHdpc2ggdG8gbW9jayBhbiBlcnJvciByZXNwb25zZSwgcGxlYXNlIHNlZSB0aGlzIGd1aWRlOiBodHRwczovL21zd2pzLmlvL2RvY3MvcmVjaXBlcy9tb2NraW5nLWVycm9yLXJlc3BvbnNlc2AsXG4gICAgICAgICAgcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgcmVxdWVzdC51cmwsXG4gICAgICAgICAgKF9hID0gZXJyb3IyLnN0YWNrKSAhPSBudWxsID8gX2EgOiBlcnJvcjJcbiAgICAgICAgKTtcbiAgICAgICAgbWVzc2FnZUNoYW5uZWwucG9zdE1lc3NhZ2UoXCJNT0NLX1JFU1BPTlNFXCIsIHtcbiAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgICBzdGF0dXNUZXh0OiBcIlJlcXVlc3QgSGFuZGxlciBFcnJvclwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBuYW1lOiBlcnJvcjIubmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yMi5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhY2s6IGVycm9yMi5zdGFja1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShyZXNwb25zZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6IHJlc3BvbnNlMi5zdGF0dXMsXG4gICAgc3RhdHVzVGV4dDogcmVzcG9uc2UyLnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogcmVzcG9uc2UyLmhlYWRlcnMuYWxsKCksXG4gICAgYm9keTogcmVzcG9uc2UyLmJvZHksXG4gICAgZGVsYXk6IHJlc3BvbnNlMi5kZWxheVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvcmVxdWVzdEludGVncml0eUNoZWNrLnRzXG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0SW50ZWdyaXR5Q2hlY2soY29udGV4dCwgc2VydmljZVdvcmtlcikge1xuICBjb250ZXh0LndvcmtlckNoYW5uZWwuc2VuZChcIklOVEVHUklUWV9DSEVDS19SRVFVRVNUXCIpO1xuICBjb25zdCB7IHBheWxvYWQ6IGFjdHVhbENoZWNrc3VtIH0gPSBhd2FpdCBjb250ZXh0LmV2ZW50cy5vbmNlKFxuICAgIFwiSU5URUdSSVRZX0NIRUNLX1JFU1BPTlNFXCJcbiAgKTtcbiAgaWYgKGFjdHVhbENoZWNrc3VtICE9PSBcIjNkNmI5ZjA2NDEwZDE3OWE3Zjc0MDRkNGJmNGMzYzcwXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ3VycmVudGx5IGFjdGl2ZSBTZXJ2aWNlIFdvcmtlciAoJHthY3R1YWxDaGVja3N1bX0pIGlzIGJlaGluZCB0aGUgbGF0ZXN0IHB1Ymxpc2hlZCBvbmUgKCR7XCIzZDZiOWYwNjQxMGQxNzlhN2Y3NDA0ZDRiZjRjM2M3MFwifSkuYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHNlcnZpY2VXb3JrZXI7XG59XG5cbi8vIHNyYy91dGlscy9kZWZlck5ldHdvcmtSZXF1ZXN0c1VudGlsLnRzXG52YXIgaW1wb3J0X3VudGlsMyA9IHJlcXVpcmUoXCJAb3Blbi1kcmFmdC91bnRpbFwiKTtcbmZ1bmN0aW9uIGRlZmVyTmV0d29ya1JlcXVlc3RzVW50aWwocHJlZGljYXRlUHJvbWlzZSkge1xuICBjb25zdCBvcmlnaW5hbFhoclNlbmQgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnNlbmQ7XG4gIHdpbmRvdy5YTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAoMCwgaW1wb3J0X3VudGlsMy51bnRpbCkoKCkgPT4gcHJlZGljYXRlUHJvbWlzZSkudGhlbigoKSA9PiB7XG4gICAgICB3aW5kb3cuWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnNlbmQgPSBvcmlnaW5hbFhoclNlbmQ7XG4gICAgICB0aGlzLnNlbmQoLi4uYXJncyk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IG9yaWdpbmFsRmV0Y2ggPSB3aW5kb3cuZmV0Y2g7XG4gIHdpbmRvdy5mZXRjaCA9IGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgYXdhaXQgKDAsIGltcG9ydF91bnRpbDMudW50aWwpKCgpID0+IHByZWRpY2F0ZVByb21pc2UpO1xuICAgIHdpbmRvdy5mZXRjaCA9IG9yaWdpbmFsRmV0Y2g7XG4gICAgcmV0dXJuIHdpbmRvdy5mZXRjaCguLi5hcmdzKTtcbiAgfTtcbn1cblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L2NyZWF0ZVJlc3BvbnNlTGlzdGVuZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlTGlzdGVuZXIoY29udGV4dCkge1xuICByZXR1cm4gKF8sIG1lc3NhZ2UpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBwYXlsb2FkOiByZXNwb25zZUpzb24gfSA9IG1lc3NhZ2U7XG4gICAgaWYgKChfYSA9IHJlc3BvbnNlSnNvbi50eXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoXCJvcGFxdWVcIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UyID0gbmV3IFJlc3BvbnNlKHJlc3BvbnNlSnNvbi5ib2R5IHx8IG51bGwsIHJlc3BvbnNlSnNvbik7XG4gICAgY29uc3QgaXNNb2NrZWRSZXNwb25zZSA9IHJlc3BvbnNlMi5oZWFkZXJzLmdldChcIngtcG93ZXJlZC1ieVwiKSA9PT0gXCJtc3dcIjtcbiAgICBpZiAoaXNNb2NrZWRSZXNwb25zZSkge1xuICAgICAgY29udGV4dC5lbWl0dGVyLmVtaXQoXCJyZXNwb25zZTptb2NrZWRcIiwgcmVzcG9uc2UyLCByZXNwb25zZUpzb24ucmVxdWVzdElkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5lbWl0dGVyLmVtaXQoXCJyZXNwb25zZTpieXBhc3NcIiwgcmVzcG9uc2UyLCByZXNwb25zZUpzb24ucmVxdWVzdElkKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC91dGlscy92YWxpZGF0ZVdvcmtlclNjb3BlLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZVdvcmtlclNjb3BlKHJlZ2lzdHJhdGlvbiwgb3B0aW9ucykge1xuICBpZiAoIShvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnF1aWV0KSAmJiAhbG9jYXRpb24uaHJlZi5zdGFydHNXaXRoKHJlZ2lzdHJhdGlvbi5zY29wZSkpIHtcbiAgICBkZXZVdGlscy53YXJuKFxuICAgICAgYENhbm5vdCBpbnRlcmNlcHQgcmVxdWVzdHMgb24gdGhpcyBwYWdlIGJlY2F1c2UgaXQncyBvdXRzaWRlIG9mIHRoZSB3b3JrZXIncyBzY29wZSAoXCIke3JlZ2lzdHJhdGlvbi5zY29wZX1cIikuIElmIHlvdSB3aXNoIHRvIG1vY2sgQVBJIHJlcXVlc3RzIG9uIHRoaXMgcGFnZSwgeW91IG11c3QgcmVzb2x2ZSB0aGlzIHNjb3BlIGlzc3VlLlxuXG4tIChSZWNvbW1lbmRlZCkgUmVnaXN0ZXIgdGhlIHdvcmtlciBhdCB0aGUgcm9vdCBsZXZlbCAoXCIvXCIpIG9mIHlvdXIgYXBwbGljYXRpb24uXG4tIFNldCB0aGUgXCJTZXJ2aWNlLVdvcmtlci1BbGxvd2VkXCIgcmVzcG9uc2UgaGVhZGVyIHRvIGFsbG93IG91dC1vZi1zY29wZSB3b3JrZXJzLmBcbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC9jcmVhdGVTdGFydEhhbmRsZXIudHNcbnZhciBjcmVhdGVTdGFydEhhbmRsZXIgPSAoY29udGV4dCkgPT4ge1xuICByZXR1cm4gZnVuY3Rpb24gc3RhcnQob3B0aW9ucywgY3VzdG9tT3B0aW9ucykge1xuICAgIGNvbnN0IHN0YXJ0V29ya2VySW5zdGFuY2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb250ZXh0LmV2ZW50cy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIGNvbnRleHQud29ya2VyQ2hhbm5lbC5vbihcbiAgICAgICAgXCJSRVFVRVNUXCIsXG4gICAgICAgIGNyZWF0ZVJlcXVlc3RMaXN0ZW5lcihjb250ZXh0LCBvcHRpb25zKVxuICAgICAgKTtcbiAgICAgIGNvbnRleHQud29ya2VyQ2hhbm5lbC5vbihcIlJFU1BPTlNFXCIsIGNyZWF0ZVJlc3BvbnNlTGlzdGVuZXIoY29udGV4dCkpO1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBhd2FpdCBnZXRXb3JrZXJJbnN0YW5jZShcbiAgICAgICAgb3B0aW9ucy5zZXJ2aWNlV29ya2VyLnVybCxcbiAgICAgICAgb3B0aW9ucy5zZXJ2aWNlV29ya2VyLm9wdGlvbnMsXG4gICAgICAgIG9wdGlvbnMuZmluZFdvcmtlclxuICAgICAgKTtcbiAgICAgIGNvbnN0IFt3b3JrZXIsIHJlZ2lzdHJhdGlvbl0gPSBpbnN0YW5jZTtcbiAgICAgIGlmICghd29ya2VyKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdXb3JrZXJNZXNzYWdlID0gKGN1c3RvbU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGN1c3RvbU9wdGlvbnMuZmluZFdvcmtlcikgPyBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAgIGBGYWlsZWQgdG8gbG9jYXRlIHRoZSBTZXJ2aWNlIFdvcmtlciByZWdpc3RyYXRpb24gdXNpbmcgYSBjdXN0b20gXCJmaW5kV29ya2VyXCIgcHJlZGljYXRlLlxuXG5QbGVhc2UgZW5zdXJlIHRoYXQgdGhlIGN1c3RvbSBwcmVkaWNhdGUgcHJvcGVybHkgbG9jYXRlcyB0aGUgU2VydmljZSBXb3JrZXIgcmVnaXN0cmF0aW9uIGF0IFwiJXNcIi5cbk1vcmUgZGV0YWlsczogaHR0cHM6Ly9tc3dqcy5pby9kb2NzL2FwaS9zZXR1cC13b3JrZXIvc3RhcnQjZmluZHdvcmtlclxuYCxcbiAgICAgICAgICBvcHRpb25zLnNlcnZpY2VXb3JrZXIudXJsXG4gICAgICAgICkgOiBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAgIGBGYWlsZWQgdG8gbG9jYXRlIHRoZSBTZXJ2aWNlIFdvcmtlciByZWdpc3RyYXRpb24uXG5cblRoaXMgbW9zdCBsaWtlbHkgbWVhbnMgdGhhdCB0aGUgd29ya2VyIHNjcmlwdCBVUkwgXCIlc1wiIGNhbm5vdCByZXNvbHZlIGFnYWluc3QgdGhlIGFjdHVhbCBwdWJsaWMgaG9zdG5hbWUgKCVzKS4gVGhpcyBtYXkgaGFwcGVuIGlmIHlvdXIgYXBwbGljYXRpb24gcnVucyBiZWhpbmQgYSBwcm94eSwgb3IgaGFzIGEgZHluYW1pYyBob3N0bmFtZS5cblxuUGxlYXNlIGNvbnNpZGVyIHVzaW5nIGEgY3VzdG9tIFwic2VydmljZVdvcmtlci51cmxcIiBvcHRpb24gdG8gcG9pbnQgdG8gdGhlIGFjdHVhbCB3b3JrZXIgc2NyaXB0IGxvY2F0aW9uLCBvciBhIGN1c3RvbSBcImZpbmRXb3JrZXJcIiBvcHRpb24gdG8gcmVzb2x2ZSB0aGUgU2VydmljZSBXb3JrZXIgcmVnaXN0cmF0aW9uIG1hbnVhbGx5LiBNb3JlIGRldGFpbHM6IGh0dHBzOi8vbXN3anMuaW8vZG9jcy9hcGkvc2V0dXAtd29ya2VyL3N0YXJ0YCxcbiAgICAgICAgICBvcHRpb25zLnNlcnZpY2VXb3JrZXIudXJsLFxuICAgICAgICAgIGxvY2F0aW9uLmhvc3RcbiAgICAgICAgKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1pc3NpbmdXb3JrZXJNZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQud29ya2VyID0gd29ya2VyO1xuICAgICAgY29udGV4dC5yZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb247XG4gICAgICBjb250ZXh0LmV2ZW50cy5hZGRMaXN0ZW5lcih3aW5kb3csIFwiYmVmb3JldW5sb2FkXCIsICgpID0+IHtcbiAgICAgICAgaWYgKHdvcmtlci5zdGF0ZSAhPT0gXCJyZWR1bmRhbnRcIikge1xuICAgICAgICAgIGNvbnRleHQud29ya2VyQ2hhbm5lbC5zZW5kKFwiQ0xJRU5UX0NMT1NFRFwiKTtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChjb250ZXh0LmtlZXBBbGl2ZUludGVydmFsKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgW2ludGVncml0eUVycm9yXSA9IGF3YWl0ICgwLCBpbXBvcnRfdW50aWw0LnVudGlsKShcbiAgICAgICAgKCkgPT4gcmVxdWVzdEludGVncml0eUNoZWNrKGNvbnRleHQsIHdvcmtlcilcbiAgICAgICk7XG4gICAgICBpZiAoaW50ZWdyaXR5RXJyb3IpIHtcbiAgICAgICAgZGV2VXRpbHMuZXJyb3IoYERldGVjdGVkIG91dGRhdGVkIFNlcnZpY2UgV29ya2VyOiAke2ludGVncml0eUVycm9yLm1lc3NhZ2V9XG5cblRoZSBtb2NraW5nIGlzIHN0aWxsIGVuYWJsZWQsIGJ1dCBpdCdzIGhpZ2hseSByZWNvbW1lbmRlZCB0aGF0IHlvdSB1cGRhdGUgeW91ciBTZXJ2aWNlIFdvcmtlciBieSBydW5uaW5nOlxuXG4kIG5weCBtc3cgaW5pdCA8UFVCTElDX0RJUj5cblxuVGhpcyBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIHRoYXQgdGhlIFNlcnZpY2UgV29ya2VyIGlzIGluIHN5bmMgd2l0aCB0aGUgbGlicmFyeSB0byBndWFyYW50ZWUgaXRzIHN0YWJpbGl0eS5cbklmIHRoaXMgbWVzc2FnZSBzdGlsbCBwZXJzaXN0cyBhZnRlciB1cGRhdGluZywgcGxlYXNlIHJlcG9ydCBhbiBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL29wZW4tZHJhZnQvbXN3L2lzc3VlcyAgICAgIGApO1xuICAgICAgfVxuICAgICAgY29udGV4dC5rZWVwQWxpdmVJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbChcbiAgICAgICAgKCkgPT4gY29udGV4dC53b3JrZXJDaGFubmVsLnNlbmQoXCJLRUVQQUxJVkVfUkVRVUVTVFwiKSxcbiAgICAgICAgNWUzXG4gICAgICApO1xuICAgICAgdmFsaWRhdGVXb3JrZXJTY29wZShyZWdpc3RyYXRpb24sIGNvbnRleHQuc3RhcnRPcHRpb25zKTtcbiAgICAgIHJldHVybiByZWdpc3RyYXRpb247XG4gICAgfTtcbiAgICBjb25zdCB3b3JrZXJSZWdpc3RyYXRpb24gPSBzdGFydFdvcmtlckluc3RhbmNlKCkudGhlbihcbiAgICAgIGFzeW5jIChyZWdpc3RyYXRpb24pID0+IHtcbiAgICAgICAgY29uc3QgcGVuZGluZ0luc3RhbmNlID0gcmVnaXN0cmF0aW9uLmluc3RhbGxpbmcgfHwgcmVnaXN0cmF0aW9uLndhaXRpbmc7XG4gICAgICAgIGlmIChwZW5kaW5nSW5zdGFuY2UpIHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgcGVuZGluZ0luc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJzdGF0ZWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChwZW5kaW5nSW5zdGFuY2Uuc3RhdGUgPT09IFwiYWN0aXZhdGVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmFibGVNb2NraW5nKGNvbnRleHQsIG9wdGlvbnMpLmNhdGNoKChlcnJvcjIpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBlbmFibGUgbW9ja2luZzogJHtlcnJvcjIgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yMi5tZXNzYWdlfWApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdHJhdGlvbjtcbiAgICAgIH1cbiAgICApO1xuICAgIGlmIChvcHRpb25zLndhaXRVbnRpbFJlYWR5KSB7XG4gICAgICBkZWZlck5ldHdvcmtSZXF1ZXN0c1VudGlsKHdvcmtlclJlZ2lzdHJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB3b3JrZXJSZWdpc3RyYXRpb247XG4gIH07XG59O1xuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RvcC91dGlscy9wcmludFN0b3BNZXNzYWdlLnRzXG5mdW5jdGlvbiBwcmludFN0b3BNZXNzYWdlKGFyZ3MgPSB7fSkge1xuICBpZiAoYXJncy5xdWlldCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLmxvZyhcbiAgICBgJWMke2RldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXCJNb2NraW5nIGRpc2FibGVkLlwiKX1gLFxuICAgIFwiY29sb3I6b3JhbmdlcmVkO2ZvbnQtd2VpZ2h0OmJvbGQ7XCJcbiAgKTtcbn1cblxuLy8gc3JjL3NldHVwV29ya2VyL3N0b3AvY3JlYXRlU3RvcC50c1xudmFyIGNyZWF0ZVN0b3AgPSAoY29udGV4dCkgPT4ge1xuICByZXR1cm4gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFjb250ZXh0LmlzTW9ja2luZ0VuYWJsZWQpIHtcbiAgICAgIGRldlV0aWxzLndhcm4oXG4gICAgICAgICdGb3VuZCBhIHJlZHVuZGFudCBcIndvcmtlci5zdG9wKClcIiBjYWxsLiBOb3RlIHRoYXQgc3RvcHBpbmcgdGhlIHdvcmtlciB3aGlsZSBtb2NraW5nIGFscmVhZHkgc3RvcHBlZCBoYXMgbm8gZWZmZWN0LiBDb25zaWRlciByZW1vdmluZyB0aGlzIFwid29ya2VyLnN0b3AoKVwiIGNhbGwuJ1xuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC53b3JrZXJDaGFubmVsLnNlbmQoXCJNT0NLX0RFQUNUSVZBVEVcIik7XG4gICAgY29udGV4dC5pc01vY2tpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgd2luZG93LmNsZWFySW50ZXJ2YWwoY29udGV4dC5rZWVwQWxpdmVJbnRlcnZhbCk7XG4gICAgcHJpbnRTdG9wTWVzc2FnZSh7IHF1aWV0OiAoX2EgPSBjb250ZXh0LnN0YXJ0T3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnF1aWV0IH0pO1xuICB9O1xufTtcblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L3V0aWxzL3ByZXBhcmVTdGFydEhhbmRsZXIudHNcbnZhciBERUZBVUxUX1NUQVJUX09QVElPTlMgPSB7XG4gIHNlcnZpY2VXb3JrZXI6IHtcbiAgICB1cmw6IFwiL21vY2tTZXJ2aWNlV29ya2VyLmpzXCIsXG4gICAgb3B0aW9uczogbnVsbFxuICB9LFxuICBxdWlldDogZmFsc2UsXG4gIHdhaXRVbnRpbFJlYWR5OiB0cnVlLFxuICBvblVuaGFuZGxlZFJlcXVlc3Q6IFwid2FyblwiLFxuICBmaW5kV29ya2VyKHNjcmlwdFVSTCwgbW9ja1NlcnZpY2VXb3JrZXJVcmwpIHtcbiAgICByZXR1cm4gc2NyaXB0VVJMID09PSBtb2NrU2VydmljZVdvcmtlclVybDtcbiAgfVxufTtcblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L2NyZWF0ZUZhbGxiYWNrUmVxdWVzdExpc3RlbmVyLnRzXG52YXIgaW1wb3J0X2ludGVyY2VwdG9yczMgPSByZXF1aXJlKFwiQG1zd2pzL2ludGVyY2VwdG9yc1wiKTtcbnZhciBpbXBvcnRfZmV0Y2gzID0gcmVxdWlyZShcIkBtc3dqcy9pbnRlcmNlcHRvcnMvbGliL2ludGVyY2VwdG9ycy9mZXRjaFwiKTtcbnZhciBpbXBvcnRfWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKFwiQG1zd2pzL2ludGVyY2VwdG9ycy9saWIvaW50ZXJjZXB0b3JzL1hNTEh0dHBSZXF1ZXN0XCIpO1xuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9jcmVhdGVSZXNwb25zZUZyb21Jc29tb3JwaGljUmVzcG9uc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlRnJvbUlzb21vcnBoaWNSZXNwb25zZShyZXNwb25zZTIpIHtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShyZXNwb25zZTIuYm9keSwge1xuICAgIHN0YXR1czogcmVzcG9uc2UyLnN0YXR1cyxcbiAgICBzdGF0dXNUZXh0OiByZXNwb25zZTIuc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiByZXNwb25zZTIuaGVhZGVyc1xuICB9KTtcbn1cblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L2NyZWF0ZUZhbGxiYWNrUmVxdWVzdExpc3RlbmVyLnRzXG5mdW5jdGlvbiBjcmVhdGVGYWxsYmFja1JlcXVlc3RMaXN0ZW5lcihjb250ZXh0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGludGVyY2VwdG9yID0gbmV3IGltcG9ydF9pbnRlcmNlcHRvcnMzLkJhdGNoSW50ZXJjZXB0b3Ioe1xuICAgIG5hbWU6IFwiZmFsbGJhY2tcIixcbiAgICBpbnRlcmNlcHRvcnM6IFtuZXcgaW1wb3J0X2ZldGNoMy5GZXRjaEludGVyY2VwdG9yKCksIG5ldyBpbXBvcnRfWE1MSHR0cFJlcXVlc3QuWE1MSHR0cFJlcXVlc3RJbnRlcmNlcHRvcigpXVxuICB9KTtcbiAgaW50ZXJjZXB0b3Iub24oXCJyZXF1ZXN0XCIsIGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgY29uc3QgbW9ja2VkUmVxdWVzdCA9IG5ldyBNb2NrZWRSZXF1ZXN0KHJlcXVlc3QudXJsLCB7XG4gICAgICAuLi5yZXF1ZXN0LFxuICAgICAgYm9keTogYXdhaXQgcmVxdWVzdC5hcnJheUJ1ZmZlcigpXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UyID0gYXdhaXQgaGFuZGxlUmVxdWVzdChcbiAgICAgIG1vY2tlZFJlcXVlc3QsXG4gICAgICBjb250ZXh0LnJlcXVlc3RIYW5kbGVycyxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBjb250ZXh0LmVtaXR0ZXIsXG4gICAgICB7XG4gICAgICAgIHRyYW5zZm9ybVJlc3BvbnNlKHJlc3BvbnNlMykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlMy5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZTMuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlMy5oZWFkZXJzLmFsbCgpLFxuICAgICAgICAgICAgYm9keTogcmVzcG9uc2UzLmJvZHksXG4gICAgICAgICAgICBkZWxheTogcmVzcG9uc2UzLmRlbGF5XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb2NrZWRSZXNwb25zZShfLCB7IGhhbmRsZXIsIHB1YmxpY1JlcXVlc3QsIHBhcnNlZFJlcXVlc3QgfSkge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5xdWlldCkge1xuICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLm9uY2UoXCJyZXNwb25zZTptb2NrZWRcIiwgYXN5bmMgKHJlc3BvbnNlMykgPT4ge1xuICAgICAgICAgICAgICBoYW5kbGVyLmxvZyhcbiAgICAgICAgICAgICAgICBwdWJsaWNSZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGF3YWl0IHNlcmlhbGl6ZVJlc3BvbnNlKHJlc3BvbnNlMyksXG4gICAgICAgICAgICAgICAgcGFyc2VkUmVxdWVzdFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAocmVzcG9uc2UyKSB7XG4gICAgICByZXF1ZXN0LnJlc3BvbmRXaXRoKHJlc3BvbnNlMik7XG4gICAgfVxuICB9KTtcbiAgaW50ZXJjZXB0b3Iub24oXCJyZXNwb25zZVwiLCAocmVxdWVzdCwgcmVzcG9uc2UyKSA9PiB7XG4gICAgaWYgKCFyZXF1ZXN0LmlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJyb3dzZXJSZXNwb25zZSA9IGNyZWF0ZVJlc3BvbnNlRnJvbUlzb21vcnBoaWNSZXNwb25zZShyZXNwb25zZTIpO1xuICAgIGlmIChyZXNwb25zZTIuaGVhZGVycy5nZXQoXCJ4LXBvd2VyZWQtYnlcIikgPT09IFwibXN3XCIpIHtcbiAgICAgIGNvbnRleHQuZW1pdHRlci5lbWl0KFwicmVzcG9uc2U6bW9ja2VkXCIsIGJyb3dzZXJSZXNwb25zZSwgcmVxdWVzdC5pZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuZW1pdHRlci5lbWl0KFwicmVzcG9uc2U6YnlwYXNzXCIsIGJyb3dzZXJSZXNwb25zZSwgcmVxdWVzdC5pZCk7XG4gICAgfVxuICB9KTtcbiAgaW50ZXJjZXB0b3IuYXBwbHkoKTtcbiAgcmV0dXJuIGludGVyY2VwdG9yO1xufVxuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvY3JlYXRlRmFsbGJhY2tTdGFydC50c1xuZnVuY3Rpb24gY3JlYXRlRmFsbGJhY2tTdGFydChjb250ZXh0KSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBzdGFydChvcHRpb25zKSB7XG4gICAgY29udGV4dC5mYWxsYmFja0ludGVyY2VwdG9yID0gY3JlYXRlRmFsbGJhY2tSZXF1ZXN0TGlzdGVuZXIoXG4gICAgICBjb250ZXh0LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgcHJpbnRTdGFydE1lc3NhZ2Uoe1xuICAgICAgbWVzc2FnZTogXCJNb2NraW5nIGVuYWJsZWQgKGZhbGxiYWNrIG1vZGUpLlwiLFxuICAgICAgcXVpZXQ6IG9wdGlvbnMucXVpZXRcbiAgICB9KTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9O1xufVxuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RvcC9jcmVhdGVGYWxsYmFja1N0b3AudHNcbmZ1bmN0aW9uIGNyZWF0ZUZhbGxiYWNrU3RvcChjb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgKF9hID0gY29udGV4dC5mYWxsYmFja0ludGVyY2VwdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xuICAgIHByaW50U3RvcE1lc3NhZ2UoeyBxdWlldDogKF9iID0gY29udGV4dC5zdGFydE9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5xdWlldCB9KTtcbiAgfTtcbn1cblxuLy8gc3JjL1NldHVwQXBpLnRzXG52YXIgaW1wb3J0X291dHZhcmlhbnQ0ID0gcmVxdWlyZShcIm91dHZhcmlhbnRcIik7XG52YXIgaW1wb3J0X3N0cmljdF9ldmVudF9lbWl0dGVyID0gcmVxdWlyZShcInN0cmljdC1ldmVudC1lbWl0dGVyXCIpO1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvcGlwZUV2ZW50cy50c1xuZnVuY3Rpb24gcGlwZUV2ZW50cyhzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIGNvbnN0IHJhd0VtaXQgPSBzb3VyY2UuZW1pdDtcbiAgaWYgKHJhd0VtaXQuX2lzUGlwZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc291cmNlLmVtaXQgPSBmdW5jdGlvbihldmVudCwgLi4uZGF0YTIpIHtcbiAgICBkZXN0aW5hdGlvbi5lbWl0KGV2ZW50LCAuLi5kYXRhMik7XG4gICAgcmV0dXJuIHJhd0VtaXQuY2FsbCh0aGlzLCBldmVudCwgLi4uZGF0YTIpO1xuICB9O1xuICBzb3VyY2UuZW1pdC5faXNQaXBlZCA9IHRydWU7XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC90b1JlYWRvbmx5QXJyYXkudHNcbmZ1bmN0aW9uIHRvUmVhZG9ubHlBcnJheShzb3VyY2UpIHtcbiAgY29uc3QgY2xvbmUgPSBbLi4uc291cmNlXTtcbiAgT2JqZWN0LmZyZWV6ZShjbG9uZSk7XG4gIHJldHVybiBjbG9uZTtcbn1cblxuLy8gc3JjL1NldHVwQXBpLnRzXG52YXIgU2V0dXBBcGkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKC4uLmluaXRpYWxIYW5kbGVycykge1xuICAgIHRoaXMudmFsaWRhdGVIYW5kbGVycyguLi5pbml0aWFsSGFuZGxlcnMpO1xuICAgIHRoaXMuaW5pdGlhbEhhbmRsZXJzID0gdG9SZWFkb25seUFycmF5KGluaXRpYWxIYW5kbGVycyk7XG4gICAgdGhpcy5jdXJyZW50SGFuZGxlcnMgPSBbLi4uaW5pdGlhbEhhbmRsZXJzXTtcbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgaW1wb3J0X3N0cmljdF9ldmVudF9lbWl0dGVyLkVtaXR0ZXIoKTtcbiAgICB0aGlzLnB1YmxpY0VtaXR0ZXIgPSBuZXcgaW1wb3J0X3N0cmljdF9ldmVudF9lbWl0dGVyLkVtaXR0ZXIoKTtcbiAgICBwaXBlRXZlbnRzKHRoaXMuZW1pdHRlciwgdGhpcy5wdWJsaWNFbWl0dGVyKTtcbiAgICB0aGlzLmV2ZW50cyA9IHRoaXMuY3JlYXRlTGlmZUN5Y2xlRXZlbnRzKCk7XG4gIH1cbiAgdmFsaWRhdGVIYW5kbGVycyguLi5oYW5kbGVycykge1xuICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgKDAsIGltcG9ydF9vdXR2YXJpYW50NC5pbnZhcmlhbnQpKFxuICAgICAgICAhQXJyYXkuaXNBcnJheShoYW5kbGVyKSxcbiAgICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICAnRmFpbGVkIHRvIGNvbnN0cnVjdCBcIiVzXCIgZ2l2ZW4gYW4gQXJyYXkgb2YgcmVxdWVzdCBoYW5kbGVycy4gTWFrZSBzdXJlIHlvdSBzcHJlYWQgdGhlIHJlcXVlc3QgaGFuZGxlcnMgd2hlbiBjYWxsaW5nIHRoZSByZXNwZWN0aXZlIHNldHVwIGZ1bmN0aW9uLidcbiAgICAgICAgKSxcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnB1YmxpY0VtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbiAgdXNlKC4uLnJ1bnRpbWVIYW5kbGVycykge1xuICAgIHRoaXMuY3VycmVudEhhbmRsZXJzLnVuc2hpZnQoLi4ucnVudGltZUhhbmRsZXJzKTtcbiAgfVxuICByZXN0b3JlSGFuZGxlcnMoKSB7XG4gICAgdGhpcy5jdXJyZW50SGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgaGFuZGxlci5tYXJrQXNTa2lwcGVkKGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuICByZXNldEhhbmRsZXJzKC4uLm5leHRIYW5kbGVycykge1xuICAgIHRoaXMuY3VycmVudEhhbmRsZXJzID0gbmV4dEhhbmRsZXJzLmxlbmd0aCA+IDAgPyBbLi4ubmV4dEhhbmRsZXJzXSA6IFsuLi50aGlzLmluaXRpYWxIYW5kbGVyc107XG4gIH1cbiAgbGlzdEhhbmRsZXJzKCkge1xuICAgIHJldHVybiB0b1JlYWRvbmx5QXJyYXkodGhpcy5jdXJyZW50SGFuZGxlcnMpO1xuICB9XG4gIGNyZWF0ZUxpZmVDeWNsZUV2ZW50cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb246ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY0VtaXR0ZXIub24oLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlTGlzdGVuZXI6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY0VtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiAoLi4uYXJncykgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyguLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc2V0dXBXb3JrZXIudHNcbnZhciBTZXR1cFdvcmtlckFwaSA9IGNsYXNzIGV4dGVuZHMgU2V0dXBBcGkge1xuICBjb25zdHJ1Y3RvciguLi5oYW5kbGVycykge1xuICAgIHN1cGVyKC4uLmhhbmRsZXJzKTtcbiAgICB0aGlzLnN0YXJ0SGFuZGxlciA9IG51bGw7XG4gICAgdGhpcy5zdG9wSGFuZGxlciA9IG51bGw7XG4gICAgKDAsIGltcG9ydF9vdXR2YXJpYW50NS5pbnZhcmlhbnQpKFxuICAgICAgISgwLCBpbXBvcnRfaXNfbm9kZV9wcm9jZXNzMy5pc05vZGVQcm9jZXNzKSgpLFxuICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgXCJGYWlsZWQgdG8gZXhlY3V0ZSBgc2V0dXBXb3JrZXJgIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQuIENvbnNpZGVyIHVzaW5nIGBzZXR1cFNlcnZlcmAgZm9yIE5vZGUuanMgZW52aXJvbm1lbnQgaW5zdGVhZC5cIlxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNyZWF0ZVdvcmtlckNvbnRleHQoKTtcbiAgfVxuICBjcmVhdGVXb3JrZXJDb250ZXh0KCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBpc01vY2tpbmdFbmFibGVkOiBmYWxzZSxcbiAgICAgIHN0YXJ0T3B0aW9uczogbnVsbCxcbiAgICAgIHdvcmtlcjogbnVsbCxcbiAgICAgIHJlZ2lzdHJhdGlvbjogbnVsbCxcbiAgICAgIHJlcXVlc3RIYW5kbGVyczogdGhpcy5jdXJyZW50SGFuZGxlcnMsXG4gICAgICBlbWl0dGVyOiB0aGlzLmVtaXR0ZXIsXG4gICAgICB3b3JrZXJDaGFubmVsOiB7XG4gICAgICAgIG9uOiAoZXZlbnRUeXBlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgIHRoaXMuY29udGV4dC5ldmVudHMuYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlcixcbiAgICAgICAgICAgIFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgIT09IHRoaXMuY29udGV4dC53b3JrZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSBldmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhldmVudCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBzZW5kOiAodHlwZSkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAoX2EgPSB0aGlzLmNvbnRleHQud29ya2VyKSA9PSBudWxsID8gdm9pZCAwIDogX2EucG9zdE1lc3NhZ2UodHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgYWRkTGlzdGVuZXI6ICh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKHsgZXZlbnRUeXBlLCB0YXJnZXQsIGNhbGxiYWNrIH0pO1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVBbGxMaXN0ZW5lcnM6ICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHsgdGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrIH0gb2YgdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB9LFxuICAgICAgICBvbmNlOiAoZXZlbnRUeXBlKSA9PiB7XG4gICAgICAgICAgY29uc3QgYmluZGluZ3MgPSBbXTtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlSW5jb21pbmdNZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBiaW5kaW5ncy5wdXNoKFxuICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZXZlbnRzLmFkZExpc3RlbmVyKFxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLFxuICAgICAgICAgICAgICAgIFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgIGhhbmRsZUluY29taW5nTWVzc2FnZVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZXZlbnRzLmFkZExpc3RlbmVyKFxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLFxuICAgICAgICAgICAgICAgIFwibWVzc2FnZWVycm9yXCIsXG4gICAgICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICBiaW5kaW5ncy5mb3JFYWNoKCh1bmJpbmQpID0+IHVuYmluZCgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZUZhbGxiYWNrTW9kZTogIShcInNlcnZpY2VXb3JrZXJcIiBpbiBuYXZpZ2F0b3IpIHx8IGxvY2F0aW9uLnByb3RvY29sID09PSBcImZpbGU6XCJcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnRleHQsIHtcbiAgICAgIHJlcXVlc3RIYW5kbGVyczoge1xuICAgICAgICBnZXQ6ICgpID0+IHRoaXMuY3VycmVudEhhbmRsZXJzXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zdGFydEhhbmRsZXIgPSBjb250ZXh0LnVzZUZhbGxiYWNrTW9kZSA/IGNyZWF0ZUZhbGxiYWNrU3RhcnQoY29udGV4dCkgOiBjcmVhdGVTdGFydEhhbmRsZXIoY29udGV4dCk7XG4gICAgdGhpcy5zdG9wSGFuZGxlciA9IGNvbnRleHQudXNlRmFsbGJhY2tNb2RlID8gY3JlYXRlRmFsbGJhY2tTdG9wKGNvbnRleHQpIDogY3JlYXRlU3RvcChjb250ZXh0KTtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuICBhc3luYyBzdGFydChvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmNvbnRleHQuc3RhcnRPcHRpb25zID0gbWVyZ2VSaWdodChcbiAgICAgIERFRkFVTFRfU1RBUlRfT1BUSU9OUyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnN0YXJ0SGFuZGxlcih0aGlzLmNvbnRleHQuc3RhcnRPcHRpb25zLCBvcHRpb25zKTtcbiAgfVxuICBwcmludEhhbmRsZXJzKCkge1xuICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5saXN0SGFuZGxlcnMoKTtcbiAgICBoYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICBjb25zdCB7IGhlYWRlciwgY2FsbEZyYW1lIH0gPSBoYW5kbGVyLmluZm87XG4gICAgICBjb25zdCBwcmFnbWEgPSBoYW5kbGVyLmluZm8uaGFzT3duUHJvcGVydHkoXCJvcGVyYXRpb25UeXBlXCIpID8gXCJbZ3JhcGhxbF1cIiA6IFwiW3Jlc3RdXCI7XG4gICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKGAke3ByYWdtYX0gJHtoZWFkZXJ9YCk7XG4gICAgICBpZiAoY2FsbEZyYW1lKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBEZWNsYXJhdGlvbjogJHtjYWxsRnJhbWV9YCk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhcIkhhbmRsZXI6XCIsIGhhbmRsZXIpO1xuICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH0pO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuY29udGV4dC5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5jb250ZXh0LmVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5zdG9wSGFuZGxlcigpO1xuICB9XG59O1xuZnVuY3Rpb24gc2V0dXBXb3JrZXIoLi4uaGFuZGxlcnMpIHtcbiAgcmV0dXJuIG5ldyBTZXR1cFdvcmtlckFwaSguLi5oYW5kbGVycyk7XG59XG5cbi8vIHNyYy9yZXN0LnRzXG5mdW5jdGlvbiBjcmVhdGVSZXN0SGFuZGxlcihtZXRob2QpIHtcbiAgcmV0dXJuIChwYXRoLCByZXNvbHZlcikgPT4ge1xuICAgIHJldHVybiBuZXcgUmVzdEhhbmRsZXIobWV0aG9kLCBwYXRoLCByZXNvbHZlcik7XG4gIH07XG59XG52YXIgcmVzdCA9IHtcbiAgYWxsOiBjcmVhdGVSZXN0SGFuZGxlcigvLisvKSxcbiAgaGVhZDogY3JlYXRlUmVzdEhhbmRsZXIoXCJIRUFEXCIgLyogSEVBRCAqLyksXG4gIGdldDogY3JlYXRlUmVzdEhhbmRsZXIoXCJHRVRcIiAvKiBHRVQgKi8pLFxuICBwb3N0OiBjcmVhdGVSZXN0SGFuZGxlcihcIlBPU1RcIiAvKiBQT1NUICovKSxcbiAgcHV0OiBjcmVhdGVSZXN0SGFuZGxlcihcIlBVVFwiIC8qIFBVVCAqLyksXG4gIGRlbGV0ZTogY3JlYXRlUmVzdEhhbmRsZXIoXCJERUxFVEVcIiAvKiBERUxFVEUgKi8pLFxuICBwYXRjaDogY3JlYXRlUmVzdEhhbmRsZXIoXCJQQVRDSFwiIC8qIFBBVENIICovKSxcbiAgb3B0aW9uczogY3JlYXRlUmVzdEhhbmRsZXIoXCJPUFRJT05TXCIgLyogT1BUSU9OUyAqLylcbn07XG5cbi8vIHNyYy9ncmFwaHFsLnRzXG5mdW5jdGlvbiBjcmVhdGVTY29wZWRHcmFwaFFMSGFuZGxlcihvcGVyYXRpb25UeXBlLCB1cmwpIHtcbiAgcmV0dXJuIChvcGVyYXRpb25OYW1lLCByZXNvbHZlcikgPT4ge1xuICAgIHJldHVybiBuZXcgR3JhcGhRTEhhbmRsZXIoXG4gICAgICBvcGVyYXRpb25UeXBlLFxuICAgICAgb3BlcmF0aW9uTmFtZSxcbiAgICAgIHVybCxcbiAgICAgIHJlc29sdmVyXG4gICAgKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdyYXBoUUxPcGVyYXRpb25IYW5kbGVyKHVybCkge1xuICByZXR1cm4gKHJlc29sdmVyKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBHcmFwaFFMSGFuZGxlcihcbiAgICAgIFwiYWxsXCIsXG4gICAgICBuZXcgUmVnRXhwKFwiLipcIiksXG4gICAgICB1cmwsXG4gICAgICByZXNvbHZlclxuICAgICk7XG4gIH07XG59XG52YXIgc3RhbmRhcmRHcmFwaFFMSGFuZGxlcnMgPSB7XG4gIG9wZXJhdGlvbjogY3JlYXRlR3JhcGhRTE9wZXJhdGlvbkhhbmRsZXIoXCIqXCIpLFxuICBxdWVyeTogY3JlYXRlU2NvcGVkR3JhcGhRTEhhbmRsZXIoXCJxdWVyeVwiLCBcIipcIiksXG4gIG11dGF0aW9uOiBjcmVhdGVTY29wZWRHcmFwaFFMSGFuZGxlcihcIm11dGF0aW9uXCIsIFwiKlwiKVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUdyYXBoUUxMaW5rKHVybCkge1xuICByZXR1cm4ge1xuICAgIG9wZXJhdGlvbjogY3JlYXRlR3JhcGhRTE9wZXJhdGlvbkhhbmRsZXIodXJsKSxcbiAgICBxdWVyeTogY3JlYXRlU2NvcGVkR3JhcGhRTEhhbmRsZXIoXCJxdWVyeVwiLCB1cmwpLFxuICAgIG11dGF0aW9uOiBjcmVhdGVTY29wZWRHcmFwaFFMSGFuZGxlcihcIm11dGF0aW9uXCIsIHVybClcbiAgfTtcbn1cbnZhciBncmFwaHFsID0ge1xuICAuLi5zdGFuZGFyZEdyYXBoUUxIYW5kbGVycyxcbiAgbGluazogY3JlYXRlR3JhcGhRTExpbmtcbn07XG5cbi8vIHNyYy9pbmRleC50c1xuY2hlY2tHbG9iYWxzKCk7XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgR3JhcGhRTEhhbmRsZXIsXG4gIE1vY2tlZFJlcXVlc3QsXG4gIFJFU1RNZXRob2RzLFxuICBSZXF1ZXN0SGFuZGxlcixcbiAgUmVzdEhhbmRsZXIsXG4gIFNldHVwQXBpLFxuICBTZXR1cFdvcmtlckFwaSxcbiAgY2xlYW5VcmwsXG4gIGNvbXBvc2UsXG4gIGNvbnRleHQsXG4gIGNyZWF0ZVJlc3BvbnNlQ29tcG9zaXRpb24sXG4gIGRlZmF1bHRDb250ZXh0LFxuICBkZWZhdWx0UmVzcG9uc2UsXG4gIGdyYXBocWwsXG4gIGdyYXBocWxDb250ZXh0LFxuICBoYW5kbGVSZXF1ZXN0LFxuICBtYXRjaFJlcXVlc3RVcmwsXG4gIHJlc3BvbnNlLFxuICByZXN0LFxuICByZXN0Q29udGV4dCxcbiAgc2V0dXBXb3JrZXJcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/msw/lib/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/msw/node_modules/path-to-regexp/dist.es2015/index.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/msw/node_modules/path-to-regexp/dist.es2015/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compile: () => (/* binding */ compile),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   pathToRegexp: () => (/* binding */ pathToRegexp),\n/* harmony export */   regexpToFunction: () => (/* binding */ regexpToFunction),\n/* harmony export */   tokensToFunction: () => (/* binding */ tokensToFunction),\n/* harmony export */   tokensToRegexp: () => (/* binding */ tokensToRegexp)\n/* harmony export */ });\n/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \".concat(i));\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \".concat(j));\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \".concat(j));\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \".concat(i));\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \".concat(i));\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\".concat(escapeString(options.delimiter || \"/#?\"), \"]+?\");\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \".concat(nextType, \" at \").concat(index, \", expected \").concat(type));\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\".concat(token.pattern, \")$\"), reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not repeat, but got an array\"));\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not be empty\"));\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to be \").concat(typeOfMessage));\n        }\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nfunction regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    var groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n    var index = 0;\n    var execResult = groupsRegex.exec(path.source);\n    while (execResult) {\n        keys.push({\n            // Use parenthesized substring match if available, index otherwise\n            name: execResult[1] || index++,\n            prefix: \"\",\n            suffix: \"\",\n            modifier: \"\",\n            pattern: \"\",\n        });\n        execResult = groupsRegex.exec(path.source);\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\".concat(parts.join(\"|\"), \")\"), flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d, _e = options.delimiter, delimiter = _e === void 0 ? \"/#?\" : _e, _f = options.endsWith, endsWith = _f === void 0 ? \"\" : _f;\n    var endsWithRe = \"[\".concat(escapeString(endsWith), \"]|$\");\n    var delimiterRe = \"[\".concat(escapeString(delimiter), \"]\");\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\".concat(prefix, \"((?:\").concat(token.pattern, \")(?:\").concat(suffix).concat(prefix, \"(?:\").concat(token.pattern, \"))*)\").concat(suffix, \")\").concat(mod);\n                    }\n                    else {\n                        route += \"(?:\".concat(prefix, \"(\").concat(token.pattern, \")\").concat(suffix, \")\").concat(token.modifier);\n                    }\n                }\n                else {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        route += \"((?:\".concat(token.pattern, \")\").concat(token.modifier, \")\");\n                    }\n                    else {\n                        route += \"(\".concat(token.pattern, \")\").concat(token.modifier);\n                    }\n                }\n            }\n            else {\n                route += \"(?:\".concat(prefix).concat(suffix, \")\").concat(token.modifier);\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += \"\".concat(delimiterRe, \"?\");\n        route += !options.endsWith ? \"$\" : \"(?=\".concat(endsWithRe, \")\");\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n            : endToken === undefined;\n        if (!strict) {\n            route += \"(?:\".concat(delimiterRe, \"(?=\").concat(endsWithRe, \"))?\");\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\".concat(delimiterRe, \"|\").concat(endsWithRe, \")\");\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nfunction pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL21zdy9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvZGlzdC5lczIwMTUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBNkM7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1EQUFtRDtBQUM3RTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDBCQUEwQix5Q0FBeUM7QUFDbkU7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiwwQkFBMEIsMENBQTBDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUNBQXFDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJDQUEyQztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUNBQXlDO0FBQy9EO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsOEJBQThCO0FBQzlCO0FBQ0EscUVBQXFFLFlBQVk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw4QkFBOEI7QUFDOUIscUVBQXFFLFlBQVk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGtEQUFrRDtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw4QkFBOEI7QUFDOUIseU9BQXlPLFlBQVk7QUFDclA7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNERBQTREO0FBQzNFO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvbXN3L25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9kaXN0LmVzMjAxNS9pbmRleC5qcz9mMzZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVG9rZW5pemUgaW5wdXQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBsZXhlcihzdHIpIHtcbiAgICB2YXIgdG9rZW5zID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICB2YXIgY2hhciA9IHN0cltpXTtcbiAgICAgICAgaWYgKGNoYXIgPT09IFwiKlwiIHx8IGNoYXIgPT09IFwiK1wiIHx8IGNoYXIgPT09IFwiP1wiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiTU9ESUZJRVJcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkVTQ0FQRURfQ0hBUlwiLCBpbmRleDogaSsrLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJPUEVOXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJDTE9TRVwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwiOlwiKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgaiA9IGkgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChqKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gYDAtOWBcbiAgICAgICAgICAgICAgICAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBgQS1aYFxuICAgICAgICAgICAgICAgICAgICAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBgYS16YFxuICAgICAgICAgICAgICAgICAgICAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEyMikgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYF9gXG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPT09IDk1KSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgKz0gc3RyW2orK107XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyBwYXJhbWV0ZXIgbmFtZSBhdCBcIi5jb25jYXQoaSkpO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk5BTUVcIiwgaW5kZXg6IGksIHZhbHVlOiBuYW1lIH0pO1xuICAgICAgICAgICAgaSA9IGo7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDE7XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgaiA9IGkgKyAxO1xuICAgICAgICAgICAgaWYgKHN0cltqXSA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0dGVybiBjYW5ub3Qgc3RhcnQgd2l0aCBcXFwiP1xcXCIgYXQgXCIuY29uY2F0KGopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChqIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJbal0gPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gc3RyW2orK10gKyBzdHJbaisrXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHJbal0gPT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyW2pdID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyW2ogKyAxXSAhPT0gXCI/XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYXB0dXJpbmcgZ3JvdXBzIGFyZSBub3QgYWxsb3dlZCBhdCBcIi5jb25jYXQoaikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gc3RyW2orK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuYmFsYW5jZWQgcGF0dGVybiBhdCBcIi5jb25jYXQoaSkpO1xuICAgICAgICAgICAgaWYgKCFwYXR0ZXJuKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNaXNzaW5nIHBhdHRlcm4gYXQgXCIuY29uY2F0KGkpKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJQQVRURVJOXCIsIGluZGV4OiBpLCB2YWx1ZTogcGF0dGVybiB9KTtcbiAgICAgICAgICAgIGkgPSBqO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkNIQVJcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICB9XG4gICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkVORFwiLCBpbmRleDogaSwgdmFsdWU6IFwiXCIgfSk7XG4gICAgcmV0dXJuIHRva2Vucztcbn1cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2Uoc3RyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgdG9rZW5zID0gbGV4ZXIoc3RyKTtcbiAgICB2YXIgX2EgPSBvcHRpb25zLnByZWZpeGVzLCBwcmVmaXhlcyA9IF9hID09PSB2b2lkIDAgPyBcIi4vXCIgOiBfYTtcbiAgICB2YXIgZGVmYXVsdFBhdHRlcm4gPSBcIlteXCIuY29uY2F0KGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCBcIi8jP1wiKSwgXCJdKz9cIik7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBrZXkgPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcGF0aCA9IFwiXCI7XG4gICAgdmFyIHRyeUNvbnN1bWUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAoaSA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2ldLnR5cGUgPT09IHR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zW2krK10udmFsdWU7XG4gICAgfTtcbiAgICB2YXIgbXVzdENvbnN1bWUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0cnlDb25zdW1lKHR5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFyIF9hID0gdG9rZW5zW2ldLCBuZXh0VHlwZSA9IF9hLnR5cGUsIGluZGV4ID0gX2EuaW5kZXg7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIFwiLmNvbmNhdChuZXh0VHlwZSwgXCIgYXQgXCIpLmNvbmNhdChpbmRleCwgXCIsIGV4cGVjdGVkIFwiKS5jb25jYXQodHlwZSkpO1xuICAgIH07XG4gICAgdmFyIGNvbnN1bWVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICB3aGlsZSAoKHZhbHVlID0gdHJ5Q29uc3VtZShcIkNIQVJcIikgfHwgdHJ5Q29uc3VtZShcIkVTQ0FQRURfQ0hBUlwiKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgd2hpbGUgKGkgPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGFyID0gdHJ5Q29uc3VtZShcIkNIQVJcIik7XG4gICAgICAgIHZhciBuYW1lID0gdHJ5Q29uc3VtZShcIk5BTUVcIik7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gdHJ5Q29uc3VtZShcIlBBVFRFUk5cIik7XG4gICAgICAgIGlmIChuYW1lIHx8IHBhdHRlcm4pIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBjaGFyIHx8IFwiXCI7XG4gICAgICAgICAgICBpZiAocHJlZml4ZXMuaW5kZXhPZihwcmVmaXgpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHBhdGggKz0gcHJlZml4O1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgICAgIHBhdGggPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4gfHwgZGVmYXVsdFBhdHRlcm4sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IHRyeUNvbnN1bWUoXCJNT0RJRklFUlwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBjaGFyIHx8IHRyeUNvbnN1bWUoXCJFU0NBUEVEX0NIQVJcIik7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcGF0aCArPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXRoKTtcbiAgICAgICAgICAgIHBhdGggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVuID0gdHJ5Q29uc3VtZShcIk9QRU5cIik7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0cnlDb25zdW1lKFwiTkFNRVwiKSB8fCBcIlwiO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm5fMSA9IHRyeUNvbnN1bWUoXCJQQVRURVJOXCIpIHx8IFwiXCI7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgIG11c3RDb25zdW1lKFwiQ0xPU0VcIik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZV8xIHx8IChwYXR0ZXJuXzEgPyBrZXkrKyA6IFwiXCIpLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IG5hbWVfMSAmJiAhcGF0dGVybl8xID8gZGVmYXVsdFBhdHRlcm4gOiBwYXR0ZXJuXzEsXG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBzdWZmaXgsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IHRyeUNvbnN1bWUoXCJNT0RJRklFUlwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtdXN0Q29uc3VtZShcIkVORFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGUoc3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbih0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciByZUZsYWdzID0gZmxhZ3Mob3B0aW9ucyk7XG4gICAgdmFyIF9hID0gb3B0aW9ucy5lbmNvZGUsIGVuY29kZSA9IF9hID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9hLCBfYiA9IG9wdGlvbnMudmFsaWRhdGUsIHZhbGlkYXRlID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYjtcbiAgICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgICB2YXIgbWF0Y2hlcyA9IHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiLmNvbmNhdCh0b2tlbi5wYXR0ZXJuLCBcIikkXCIpLCByZUZsYWdzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcGF0aCA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGEgPyBkYXRhW3Rva2VuLm5hbWVdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIG9wdGlvbmFsID0gdG9rZW4ubW9kaWZpZXIgPT09IFwiP1wiIHx8IHRva2VuLm1vZGlmaWVyID09PSBcIipcIjtcbiAgICAgICAgICAgIHZhciByZXBlYXQgPSB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCIgfHwgdG9rZW4ubW9kaWZpZXIgPT09IFwiK1wiO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXBlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFxcXCJcIi5jb25jYXQodG9rZW4ubmFtZSwgXCJcXFwiIHRvIG5vdCByZXBlYXQsIGJ1dCBnb3QgYW4gYXJyYXlcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiLmNvbmNhdCh0b2tlbi5uYW1lLCBcIlxcXCIgdG8gbm90IGJlIGVtcHR5XCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGUgJiYgIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGFsbCBcXFwiXCIuY29uY2F0KHRva2VuLm5hbWUsIFwiXFxcIiB0byBtYXRjaCBcXFwiXCIpLmNvbmNhdCh0b2tlbi5wYXR0ZXJuLCBcIlxcXCIsIGJ1dCBnb3QgXFxcIlwiKS5jb25jYXQoc2VnbWVudCwgXCJcXFwiXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnQgKyB0b2tlbi5zdWZmaXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IGVuY29kZShTdHJpbmcodmFsdWUpLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlICYmICFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFxcXCJcIi5jb25jYXQodG9rZW4ubmFtZSwgXCJcXFwiIHRvIG1hdGNoIFxcXCJcIikuY29uY2F0KHRva2VuLnBhdHRlcm4sIFwiXFxcIiwgYnV0IGdvdCBcXFwiXCIpLmNvbmNhdChzZWdtZW50LCBcIlxcXCJcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnQgKyB0b2tlbi5zdWZmaXg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdHlwZU9mTWVzc2FnZSA9IHJlcGVhdCA/IFwiYW4gYXJyYXlcIiA6IFwiYSBzdHJpbmdcIjtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIuY29uY2F0KHRva2VuLm5hbWUsIFwiXFxcIiB0byBiZSBcIikuY29uY2F0KHR5cGVPZk1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgcGF0aCBtYXRjaCBmdW5jdGlvbiBmcm9tIGBwYXRoLXRvLXJlZ2V4cGAgc3BlYy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoKHN0ciwgb3B0aW9ucykge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgdmFyIHJlID0gcGF0aFRvUmVnZXhwKHN0ciwga2V5cywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlZ2V4cFRvRnVuY3Rpb24ocmUsIGtleXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIG1hdGNoIGZ1bmN0aW9uIGZyb20gYHBhdGgtdG8tcmVnZXhwYCBvdXRwdXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdleHBUb0Z1bmN0aW9uKHJlLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgX2EgPSBvcHRpb25zLmRlY29kZSwgZGVjb2RlID0gX2EgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9IDogX2E7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgICAgICB2YXIgbSA9IHJlLmV4ZWMocGF0aG5hbWUpO1xuICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBwYXRoID0gbVswXSwgaW5kZXggPSBtLmluZGV4O1xuICAgICAgICB2YXIgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgaWYgKG1baV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaSAtIDFdO1xuICAgICAgICAgICAgaWYgKGtleS5tb2RpZmllciA9PT0gXCIqXCIgfHwga2V5Lm1vZGlmaWVyID09PSBcIitcIikge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trZXkubmFtZV0gPSBtW2ldLnNwbGl0KGtleS5wcmVmaXggKyBrZXkuc3VmZml4KS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGUodmFsdWUsIGtleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gZGVjb2RlKG1baV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwYXRoOiBwYXRoLCBpbmRleDogaW5kZXgsIHBhcmFtczogcGFyYW1zIH07XG4gICAgfTtcbn1cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXwvXFxcXF0pL2csIFwiXFxcXCQxXCIpO1xufVxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBmbGFncyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5zZW5zaXRpdmUgPyBcIlwiIDogXCJpXCI7XG59XG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAocGF0aCwga2V5cykge1xuICAgIGlmICgha2V5cylcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgdmFyIGdyb3Vwc1JlZ2V4ID0gL1xcKCg/OlxcPzwoLio/KT4pPyg/IVxcPykvZztcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBleGVjUmVzdWx0ID0gZ3JvdXBzUmVnZXguZXhlYyhwYXRoLnNvdXJjZSk7XG4gICAgd2hpbGUgKGV4ZWNSZXN1bHQpIHtcbiAgICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgICAgIC8vIFVzZSBwYXJlbnRoZXNpemVkIHN1YnN0cmluZyBtYXRjaCBpZiBhdmFpbGFibGUsIGluZGV4IG90aGVyd2lzZVxuICAgICAgICAgICAgbmFtZTogZXhlY1Jlc3VsdFsxXSB8fCBpbmRleCsrLFxuICAgICAgICAgICAgcHJlZml4OiBcIlwiLFxuICAgICAgICAgICAgc3VmZml4OiBcIlwiLFxuICAgICAgICAgICAgbW9kaWZpZXI6IFwiXCIsXG4gICAgICAgICAgICBwYXR0ZXJuOiBcIlwiLFxuICAgICAgICB9KTtcbiAgICAgICAgZXhlY1Jlc3VsdCA9IGdyb3Vwc1JlZ2V4LmV4ZWMocGF0aC5zb3VyY2UpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAocGF0aHMsIGtleXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFydHMgPSBwYXRocy5tYXAoZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIHBhdGhUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKS5zb3VyY2U7IH0pO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86XCIuY29uY2F0KHBhcnRzLmpvaW4oXCJ8XCIpLCBcIilcIiksIGZsYWdzKG9wdGlvbnMpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9rZW5zVG9SZWdleHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9rZW5zVG9SZWdleHAodG9rZW5zLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgX2EgPSBvcHRpb25zLnN0cmljdCwgc3RyaWN0ID0gX2EgPT09IHZvaWQgMCA/IGZhbHNlIDogX2EsIF9iID0gb3B0aW9ucy5zdGFydCwgc3RhcnQgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBfYyA9IG9wdGlvbnMuZW5kLCBlbmQgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBfZCA9IG9wdGlvbnMuZW5jb2RlLCBlbmNvZGUgPSBfZCA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0gOiBfZCwgX2UgPSBvcHRpb25zLmRlbGltaXRlciwgZGVsaW1pdGVyID0gX2UgPT09IHZvaWQgMCA/IFwiLyM/XCIgOiBfZSwgX2YgPSBvcHRpb25zLmVuZHNXaXRoLCBlbmRzV2l0aCA9IF9mID09PSB2b2lkIDAgPyBcIlwiIDogX2Y7XG4gICAgdmFyIGVuZHNXaXRoUmUgPSBcIltcIi5jb25jYXQoZXNjYXBlU3RyaW5nKGVuZHNXaXRoKSwgXCJdfCRcIik7XG4gICAgdmFyIGRlbGltaXRlclJlID0gXCJbXCIuY29uY2F0KGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpLCBcIl1cIik7XG4gICAgdmFyIHJvdXRlID0gc3RhcnQgPyBcIl5cIiA6IFwiXCI7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgICBmb3IgKHZhciBfaSA9IDAsIHRva2Vuc18xID0gdG9rZW5zOyBfaSA8IHRva2Vuc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNfMVtfaV07XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyhlbmNvZGUodG9rZW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuLnByZWZpeCkpO1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IGVzY2FwZVN0cmluZyhlbmNvZGUodG9rZW4uc3VmZml4KSk7XG4gICAgICAgICAgICBpZiAodG9rZW4ucGF0dGVybikge1xuICAgICAgICAgICAgICAgIGlmIChrZXlzKVxuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmaXggfHwgc3VmZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi5tb2RpZmllciA9PT0gXCIrXCIgfHwgdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kID0gdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiID8gXCI/XCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIi5jb25jYXQocHJlZml4LCBcIigoPzpcIikuY29uY2F0KHRva2VuLnBhdHRlcm4sIFwiKSg/OlwiKS5jb25jYXQoc3VmZml4KS5jb25jYXQocHJlZml4LCBcIig/OlwiKS5jb25jYXQodG9rZW4ucGF0dGVybiwgXCIpKSopXCIpLmNvbmNhdChzdWZmaXgsIFwiKVwiKS5jb25jYXQobW9kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIuY29uY2F0KHByZWZpeCwgXCIoXCIpLmNvbmNhdCh0b2tlbi5wYXR0ZXJuLCBcIilcIikuY29uY2F0KHN1ZmZpeCwgXCIpXCIpLmNvbmNhdCh0b2tlbi5tb2RpZmllcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi5tb2RpZmllciA9PT0gXCIrXCIgfHwgdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZSArPSBcIigoPzpcIi5jb25jYXQodG9rZW4ucGF0dGVybiwgXCIpXCIpLmNvbmNhdCh0b2tlbi5tb2RpZmllciwgXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoXCIuY29uY2F0KHRva2VuLnBhdHRlcm4sIFwiKVwiKS5jb25jYXQodG9rZW4ubW9kaWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIi5jb25jYXQocHJlZml4KS5jb25jYXQoc3VmZml4LCBcIilcIikuY29uY2F0KHRva2VuLm1vZGlmaWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kKSB7XG4gICAgICAgIGlmICghc3RyaWN0KVxuICAgICAgICAgICAgcm91dGUgKz0gXCJcIi5jb25jYXQoZGVsaW1pdGVyUmUsIFwiP1wiKTtcbiAgICAgICAgcm91dGUgKz0gIW9wdGlvbnMuZW5kc1dpdGggPyBcIiRcIiA6IFwiKD89XCIuY29uY2F0KGVuZHNXaXRoUmUsIFwiKVwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBlbmRUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBpc0VuZERlbGltaXRlZCA9IHR5cGVvZiBlbmRUb2tlbiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBkZWxpbWl0ZXJSZS5pbmRleE9mKGVuZFRva2VuW2VuZFRva2VuLmxlbmd0aCAtIDFdKSA+IC0xXG4gICAgICAgICAgICA6IGVuZFRva2VuID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghc3RyaWN0KSB7XG4gICAgICAgICAgICByb3V0ZSArPSBcIig/OlwiLmNvbmNhdChkZWxpbWl0ZXJSZSwgXCIoPz1cIikuY29uY2F0KGVuZHNXaXRoUmUsIFwiKSk/XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNFbmREZWxpbWl0ZWQpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IFwiKD89XCIuY29uY2F0KGRlbGltaXRlclJlLCBcInxcIikuY29uY2F0KGVuZHNXaXRoUmUsIFwiKVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZ0V4cChyb3V0ZSwgZmxhZ3Mob3B0aW9ucykpO1xufVxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIGtleXMpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKVxuICAgICAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gc3RyaW5nVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/msw/node_modules/path-to-regexp/dist.es2015/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/msw/lib/node/index.mjs":
/*!*************************************************!*\
  !*** ../../node_modules/msw/lib/node/index.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SetupServerApi: () => (/* binding */ SetupServerApi),\n/* harmony export */   setupServer: () => (/* binding */ setupServer)\n/* harmony export */ });\n/* harmony import */ var timers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! timers */ \"timers\");\n/* harmony import */ var chalk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chalk */ \"(ssr)/../../node_modules/chalk/source/index.js\");\n/* harmony import */ var outvariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! outvariant */ \"(ssr)/../../node_modules/outvariant/lib/index.mjs\");\n/* harmony import */ var _mswjs_interceptors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @mswjs/interceptors */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/index.js\");\n/* harmony import */ var strict_event_emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! strict-event-emitter */ \"(ssr)/../../node_modules/strict-event-emitter/lib/index.js\");\n/* harmony import */ var cookie__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cookie */ \"(ssr)/../../node_modules/cookie/index.js\");\n/* harmony import */ var _mswjs_cookies__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @mswjs/cookies */ \"(ssr)/../../node_modules/@mswjs/cookies/lib/index.js\");\n/* harmony import */ var _mswjs_interceptors_lib_utils_bufferUtils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @mswjs/interceptors/lib/utils/bufferUtils.js */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/utils/bufferUtils.js\");\n/* harmony import */ var headers_polyfill__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.mjs\");\n/* harmony import */ var _open_draft_until__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @open-draft/until */ \"(ssr)/../../node_modules/@open-draft/until/lib/index.js\");\n/* harmony import */ var js_levenshtein__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! js-levenshtein */ \"(ssr)/../../node_modules/js-levenshtein/index.js\");\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! graphql */ \"(ssr)/../../node_modules/graphql/language/parser.mjs\");\n/* harmony import */ var is_node_process__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! is-node-process */ \"(ssr)/../../node_modules/is-node-process/lib/index.mjs\");\n/* harmony import */ var path_to_regexp__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! path-to-regexp */ \"(ssr)/../../node_modules/msw/node_modules/path-to-regexp/dist.es2015/index.js\");\n/* harmony import */ var _mswjs_interceptors_lib_utils_getCleanUrl_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @mswjs/interceptors/lib/utils/getCleanUrl.js */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/utils/getCleanUrl.js\");\n/* harmony import */ var _mswjs_interceptors_lib_interceptors_ClientRequest_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @mswjs/interceptors/lib/interceptors/ClientRequest/index.js */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/interceptors/ClientRequest/index.js\");\n/* harmony import */ var _mswjs_interceptors_lib_interceptors_XMLHttpRequest_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @mswjs/interceptors/lib/interceptors/XMLHttpRequest/index.js */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/interceptors/XMLHttpRequest/index.js\");\n/* harmony import */ var _mswjs_interceptors_lib_interceptors_fetch_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @mswjs/interceptors/lib/interceptors/fetch/index.js */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/interceptors/fetch/index.js\");\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\")\n    return require.apply(this, arguments);\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n});\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// config/polyfills-node.ts\n\nvar setTimeout = timers__WEBPACK_IMPORTED_MODULE_0__.setTimeout;\n\n// src/node/SetupServerApi.ts\n\n\n\n\n// src/SetupApi.ts\n\n\n\n// src/utils/internal/devUtils.ts\n\nvar LIBRARY_PREFIX = \"[MSW]\";\nfunction formatMessage(message, ...positionals) {\n  const interpolatedMessage = (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.format)(message, ...positionals);\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`;\n}\nfunction warn(message, ...positionals) {\n  console.warn(formatMessage(message, ...positionals));\n}\nfunction error(message, ...positionals) {\n  console.error(formatMessage(message, ...positionals));\n}\nvar devUtils = {\n  formatMessage,\n  warn,\n  error\n};\n\n// src/utils/internal/pipeEvents.ts\nfunction pipeEvents(source, destination) {\n  const rawEmit = source.emit;\n  if (rawEmit._isPiped) {\n    return;\n  }\n  source.emit = function(event, ...data2) {\n    destination.emit(event, ...data2);\n    return rawEmit.call(this, event, ...data2);\n  };\n  source.emit._isPiped = true;\n}\n\n// src/utils/internal/toReadonlyArray.ts\nfunction toReadonlyArray(source) {\n  const clone = [...source];\n  Object.freeze(clone);\n  return clone;\n}\n\n// src/SetupApi.ts\nvar SetupApi = class {\n  constructor(...initialHandlers) {\n    this.validateHandlers(...initialHandlers);\n    this.initialHandlers = toReadonlyArray(initialHandlers);\n    this.currentHandlers = [...initialHandlers];\n    this.emitter = new strict_event_emitter__WEBPACK_IMPORTED_MODULE_4__.Emitter();\n    this.publicEmitter = new strict_event_emitter__WEBPACK_IMPORTED_MODULE_4__.Emitter();\n    pipeEvents(this.emitter, this.publicEmitter);\n    this.events = this.createLifeCycleEvents();\n  }\n  validateHandlers(...handlers) {\n    for (const handler of handlers) {\n      (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(\n        !Array.isArray(handler),\n        devUtils.formatMessage(\n          'Failed to construct \"%s\" given an Array of request handlers. Make sure you spread the request handlers when calling the respective setup function.'\n        ),\n        this.constructor.name\n      );\n    }\n  }\n  dispose() {\n    this.emitter.removeAllListeners();\n    this.publicEmitter.removeAllListeners();\n  }\n  use(...runtimeHandlers) {\n    this.currentHandlers.unshift(...runtimeHandlers);\n  }\n  restoreHandlers() {\n    this.currentHandlers.forEach((handler) => {\n      handler.markAsSkipped(false);\n    });\n  }\n  resetHandlers(...nextHandlers) {\n    this.currentHandlers = nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers];\n  }\n  listHandlers() {\n    return toReadonlyArray(this.currentHandlers);\n  }\n  createLifeCycleEvents() {\n    return {\n      on: (...args) => {\n        return this.publicEmitter.on(...args);\n      },\n      removeListener: (...args) => {\n        return this.publicEmitter.removeListener(...args);\n      },\n      removeAllListeners: (...args) => {\n        return this.publicEmitter.removeAllListeners(...args);\n      }\n    };\n  }\n};\n\n// src/utils/internal/isObject.ts\nfunction isObject(value) {\n  return value != null && typeof value === \"object\" && !Array.isArray(value);\n}\n\n// src/utils/internal/mergeRight.ts\nfunction mergeRight(left, right) {\n  return Object.entries(right).reduce((result, [key, rightValue]) => {\n    const leftValue = result[key];\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue);\n      return result;\n    }\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue);\n      return result;\n    }\n    result[key] = rightValue;\n    return result;\n  }, Object.assign({}, left));\n}\n\n// src/utils/request/MockedRequest.ts\n\n\n\n\n\n\n// src/utils/request/getRequestCookies.ts\n\nfunction getAllCookies() {\n  return cookie__WEBPACK_IMPORTED_MODULE_5__.parse(document.cookie);\n}\nfunction getRequestCookies(request) {\n  if (typeof document === \"undefined\" || typeof location === \"undefined\") {\n    return {};\n  }\n  switch (request.credentials) {\n    case \"same-origin\": {\n      return location.origin === request.url.origin ? getAllCookies() : {};\n    }\n    case \"include\": {\n      return getAllCookies();\n    }\n    default: {\n      return {};\n    }\n  }\n}\n\n// src/utils/internal/jsonParse.ts\nfunction jsonParse(value) {\n  try {\n    return JSON.parse(value);\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/internal/parseMultipartData.ts\n\nfunction parseContentHeaders(headersString) {\n  var _a, _b;\n  const headers = (0,headers_polyfill__WEBPACK_IMPORTED_MODULE_8__.stringToHeaders)(headersString);\n  const contentType = headers.get(\"content-type\") || \"text/plain\";\n  const disposition = headers.get(\"content-disposition\");\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.');\n  }\n  const directives = disposition.split(\";\").reduce((acc, chunk) => {\n    const [name2, ...rest] = chunk.trim().split(\"=\");\n    acc[name2] = rest.join(\"=\");\n    return acc;\n  }, {});\n  const name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);\n  const filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);\n  return {\n    name,\n    filename,\n    contentType\n  };\n}\nfunction parseMultipartData(data2, headers) {\n  const contentType = headers == null ? void 0 : headers.get(\"content-type\");\n  if (!contentType) {\n    return void 0;\n  }\n  const [, ...directives] = contentType.split(/; */);\n  const boundary = directives.filter((d) => d.startsWith(\"boundary=\")).map((s) => s.replace(/^boundary=/, \"\"))[0];\n  if (!boundary) {\n    return void 0;\n  }\n  const boundaryRegExp = new RegExp(`--+${boundary}`);\n  const fields = data2.split(boundaryRegExp).filter((chunk) => chunk.startsWith(\"\\r\\n\") && chunk.endsWith(\"\\r\\n\")).map((chunk) => chunk.trimStart().replace(/\\r\\n$/, \"\"));\n  if (!fields.length) {\n    return void 0;\n  }\n  const parsedBody = {};\n  try {\n    for (const field2 of fields) {\n      const [contentHeaders, ...rest] = field2.split(\"\\r\\n\\r\\n\");\n      const contentBody = rest.join(\"\\r\\n\\r\\n\");\n      const { contentType: contentType2, filename, name } = parseContentHeaders(contentHeaders);\n      const value = filename === void 0 ? contentBody : new File([contentBody], filename, { type: contentType2 });\n      const parsedValue = parsedBody[name];\n      if (parsedValue === void 0) {\n        parsedBody[name] = value;\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value];\n      } else {\n        parsedBody[name] = [parsedValue, value];\n      }\n    }\n    return parsedBody;\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/request/parseBody.ts\nfunction parseBody(body2, headers) {\n  var _a;\n  if (!body2) {\n    return body2;\n  }\n  const contentType = ((_a = headers == null ? void 0 : headers.get(\"content-type\")) == null ? void 0 : _a.toLowerCase()) || \"\";\n  const hasMultipartContent = contentType.startsWith(\"multipart/form-data\");\n  if (hasMultipartContent && typeof body2 !== \"object\") {\n    return parseMultipartData(body2.toString(), headers) || body2;\n  }\n  const hasJsonContent = contentType.includes(\"json\");\n  if (hasJsonContent && typeof body2 !== \"object\") {\n    return jsonParse(body2.toString()) || body2;\n  }\n  return body2;\n}\n\n// src/utils/internal/isStringEqual.ts\nfunction isStringEqual(actual, expected) {\n  return actual.toLowerCase() === expected.toLowerCase();\n}\n\n// src/utils/request/MockedRequest.ts\nvar MockedRequest = class extends _mswjs_interceptors__WEBPACK_IMPORTED_MODULE_3__.IsomorphicRequest {\n  constructor(url, init = {}) {\n    super(url, init);\n    if (init.id) {\n      this.id = init.id;\n    }\n    this.cache = init.cache || \"default\";\n    this.destination = init.destination || \"\";\n    this.integrity = init.integrity || \"\";\n    this.keepalive = init.keepalive || false;\n    this.mode = init.mode || \"cors\";\n    this.priority = init.priority || \"auto\";\n    this.redirect = init.redirect || \"follow\";\n    this.referrer = init.referrer || \"\";\n    this.referrerPolicy = init.referrerPolicy || \"no-referrer\";\n    this.cookies = init.cookies || this.getCookies();\n  }\n  get body() {\n    const text2 = (0,_mswjs_interceptors_lib_utils_bufferUtils_js__WEBPACK_IMPORTED_MODULE_7__.decodeBuffer)(this[\"_body\"]);\n    const body2 = parseBody(text2, this.headers);\n    if (isStringEqual(this.method, \"GET\") && body2 === \"\") {\n      return void 0;\n    }\n    return body2;\n  }\n  passthrough() {\n    return {\n      status: 101,\n      statusText: \"Continue\",\n      headers: new headers_polyfill__WEBPACK_IMPORTED_MODULE_8__.Headers(),\n      body: null,\n      passthrough: true,\n      once: false\n    };\n  }\n  getCookies() {\n    var _a;\n    const requestCookiesString = this.headers.get(\"cookie\");\n    const ownCookies = requestCookiesString ? cookie__WEBPACK_IMPORTED_MODULE_5__.parse(requestCookiesString) : {};\n    _mswjs_cookies__WEBPACK_IMPORTED_MODULE_6__.store.hydrate();\n    const cookiesFromStore = Array.from(\n      (_a = _mswjs_cookies__WEBPACK_IMPORTED_MODULE_6__.store.get({ ...this, url: this.url.href })) == null ? void 0 : _a.entries()\n    ).reduce((cookies, [name, { value }]) => {\n      return Object.assign(cookies, { [name.trim()]: value });\n    }, {});\n    const cookiesFromDocument = getRequestCookies(this);\n    const forwardedCookies = {\n      ...cookiesFromDocument,\n      ...cookiesFromStore\n    };\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append(\"cookie\", `${name}=${value}`);\n    }\n    return {\n      ...forwardedCookies,\n      ...ownCookies\n    };\n  }\n};\n\n// src/utils/handleRequest.ts\n\n\n// src/utils/getResponse.ts\nvar getResponse = async (request, handlers, resolutionContext) => {\n  const relevantHandlers = handlers.filter((handler) => {\n    return handler.test(request, resolutionContext);\n  });\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  const result = await relevantHandlers.reduce(async (executionResult, handler) => {\n    const previousResults = await executionResult;\n    if (!!(previousResults == null ? void 0 : previousResults.response)) {\n      return executionResult;\n    }\n    const result2 = await handler.run(request, resolutionContext);\n    if (result2 === null || result2.handler.shouldSkip) {\n      return null;\n    }\n    if (!result2.response) {\n      return {\n        request: result2.request,\n        handler: result2.handler,\n        response: void 0,\n        parsedResult: result2.parsedResult\n      };\n    }\n    if (result2.response.once) {\n      handler.markAsSkipped(true);\n    }\n    return result2;\n  }, Promise.resolve(null));\n  if (!result) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response\n  };\n};\n\n// src/utils/request/onUnhandledRequest.ts\n\n\n// src/utils/internal/parseGraphQLRequest.ts\n\n\n// src/utils/request/getPublicUrlFromRequest.ts\nvar getPublicUrlFromRequest = (request) => {\n  return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(\n    request.url.pathname,\n    `${request.url.protocol}//${request.url.host}`\n  ).href;\n};\n\n// src/utils/internal/parseGraphQLRequest.ts\nfunction parseDocumentNode(node) {\n  var _a;\n  const operationDef = node.definitions.find((def) => {\n    return def.kind === \"OperationDefinition\";\n  });\n  return {\n    operationType: operationDef == null ? void 0 : operationDef.operation,\n    operationName: (_a = operationDef == null ? void 0 : operationDef.name) == null ? void 0 : _a.value\n  };\n}\nfunction parseQuery(query) {\n  try {\n    const ast = (0,graphql__WEBPACK_IMPORTED_MODULE_11__.parse)(query);\n    return parseDocumentNode(ast);\n  } catch (error2) {\n    return error2;\n  }\n}\nfunction extractMultipartVariables(variables, map, files) {\n  const operations = { variables };\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`);\n    }\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split(\".\").reverse();\n      const paths = reversedPaths.reverse();\n      let target = operations;\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`);\n        }\n        target = target[path];\n      }\n      target[lastPath] = files[key];\n    }\n  }\n  return operations.variables;\n}\nfunction getGraphQLInput(request) {\n  var _a, _b;\n  switch (request.method) {\n    case \"GET\": {\n      const query = request.url.searchParams.get(\"query\");\n      const variables = request.url.searchParams.get(\"variables\") || \"\";\n      return {\n        query,\n        variables: jsonParse(variables)\n      };\n    }\n    case \"POST\": {\n      if ((_a = request.body) == null ? void 0 : _a.query) {\n        const { query, variables } = request.body;\n        return {\n          query,\n          variables\n        };\n      }\n      if ((_b = request.body) == null ? void 0 : _b.operations) {\n        const { operations, map, ...files } = request.body;\n        const parsedOperations = jsonParse(\n          operations\n        ) || {};\n        if (!parsedOperations.query) {\n          return null;\n        }\n        const parsedMap = jsonParse(map || \"\") || {};\n        const variables = parsedOperations.variables ? extractMultipartVariables(\n          parsedOperations.variables,\n          parsedMap,\n          files\n        ) : {};\n        return {\n          query: parsedOperations.query,\n          variables\n        };\n      }\n    }\n    default:\n      return null;\n  }\n}\nfunction parseGraphQLRequest(request) {\n  const input = getGraphQLInput(request);\n  if (!input || !input.query) {\n    return void 0;\n  }\n  const { query, variables } = input;\n  const parsedResult = parseQuery(query);\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s',\n        request.method,\n        requestPublicUrl,\n        parsedResult.message\n      )\n    );\n  }\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables\n  };\n}\n\n// node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json\nvar codes_default = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"103\": \"Early Hints\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a Teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Too Early\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n};\n\n// src/context/status.ts\nvar status = (statusCode, statusText) => {\n  return (res) => {\n    res.status = statusCode;\n    res.statusText = statusText || codes_default[String(statusCode)];\n    return res;\n  };\n};\n\n// src/context/set.ts\n\nfunction set(...args) {\n  return (res) => {\n    const [name, value] = args;\n    if (typeof name === \"string\") {\n      res.headers.append(name, value);\n    } else {\n      const headers = (0,headers_polyfill__WEBPACK_IMPORTED_MODULE_8__.objectToHeaders)(name);\n      headers.forEach((value2, name2) => {\n        res.headers.append(name2, value2);\n      });\n    }\n    return res;\n  };\n}\n\n// src/context/cookie.ts\n\nvar cookie = (name, value, options) => {\n  return (res) => {\n    const serializedCookie = cookie__WEBPACK_IMPORTED_MODULE_5__.serialize(name, value, options);\n    res.headers.append(\"Set-Cookie\", serializedCookie);\n    if (typeof document !== \"undefined\") {\n      document.cookie = serializedCookie;\n    }\n    return res;\n  };\n};\n\n// src/context/body.ts\nvar body = (value) => {\n  return (res) => {\n    res.body = value;\n    return res;\n  };\n};\n\n// src/context/json.ts\nvar json = (body2) => {\n  return (res) => {\n    res.headers.set(\"Content-Type\", \"application/json\");\n    res.body = JSON.stringify(body2);\n    return res;\n  };\n};\n\n// src/context/data.ts\nvar data = (payload) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { data: payload });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/extensions.ts\nvar extensions = (payload) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { extensions: payload });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/delay.ts\n\nvar SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;\nvar MIN_SERVER_RESPONSE_TIME = 100;\nvar MAX_SERVER_RESPONSE_TIME = 400;\nvar NODE_SERVER_RESPONSE_TIME = 5;\nvar getRandomServerResponseTime = () => {\n  if ((0,is_node_process__WEBPACK_IMPORTED_MODULE_12__.isNodeProcess)()) {\n    return NODE_SERVER_RESPONSE_TIME;\n  }\n  return Math.floor(\n    Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME\n  );\n};\nvar delay = (durationOrMode) => {\n  return (res) => {\n    let delayTime;\n    if (typeof durationOrMode === \"string\") {\n      switch (durationOrMode) {\n        case \"infinite\": {\n          delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;\n          break;\n        }\n        case \"real\": {\n          delayTime = getRandomServerResponseTime();\n          break;\n        }\n        default: {\n          throw new Error(\n            `Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`\n          );\n        }\n      }\n    } else if (typeof durationOrMode === \"undefined\") {\n      delayTime = getRandomServerResponseTime();\n    } else {\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\n          `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`\n        );\n      }\n      delayTime = durationOrMode;\n    }\n    res.delay = delayTime;\n    return res;\n  };\n};\n\n// src/context/errors.ts\nvar errors = (errorsList) => {\n  return (res) => {\n    if (errorsList == null) {\n      return res;\n    }\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { errors: errorsList });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/fetch.ts\n\n\nvar useFetch = (0,is_node_process__WEBPACK_IMPORTED_MODULE_12__.isNodeProcess)() ? (input, init) => Promise.resolve().then(() => __toESM(__require(\"node-fetch\"))).then(\n  ({ default: nodeFetch }) => nodeFetch(input, init)\n) : globalThis.fetch;\nvar augmentRequestInit = (requestInit) => {\n  const headers = new headers_polyfill__WEBPACK_IMPORTED_MODULE_8__.Headers(requestInit.headers);\n  headers.set(\"x-msw-bypass\", \"true\");\n  return {\n    ...requestInit,\n    headers: headers.all()\n  };\n};\nvar createFetchRequestParameters = (input) => {\n  const { body: body2, method } = input;\n  const requestParameters = {\n    ...input,\n    body: void 0\n  };\n  if ([\"GET\", \"HEAD\"].includes(method)) {\n    return requestParameters;\n  }\n  if (typeof body2 === \"object\" || typeof body2 === \"number\" || typeof body2 === \"boolean\") {\n    requestParameters.body = JSON.stringify(body2);\n  } else {\n    requestParameters.body = body2;\n  }\n  return requestParameters;\n};\nvar fetch = (input, requestInit = {}) => {\n  if (typeof input === \"string\") {\n    return useFetch(input, augmentRequestInit(requestInit));\n  }\n  const requestParameters = createFetchRequestParameters(input);\n  const derivedRequestInit = augmentRequestInit(requestParameters);\n  return useFetch(input.url.href, derivedRequestInit);\n};\n\n// src/context/text.ts\nvar text = (body2) => {\n  return (res) => {\n    res.headers.set(\"Content-Type\", \"text/plain\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/context/xml.ts\nvar xml = (body2) => {\n  return (res) => {\n    res.headers.set(\"Content-Type\", \"text/xml\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/utils/logging/getStatusCodeColor.ts\nfunction getStatusCodeColor(status2) {\n  if (status2 < 300) {\n    return \"#69AB32\" /* Success */;\n  }\n  if (status2 < 400) {\n    return \"#F0BB4B\" /* Warning */;\n  }\n  return \"#E95F5D\" /* Danger */;\n}\n\n// src/utils/logging/getTimestamp.ts\nfunction getTimestamp() {\n  const now = new Date();\n  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map((chunk) => chunk.slice(0, 2)).map((chunk) => chunk.padStart(2, \"0\")).join(\":\");\n}\n\n// src/utils/logging/prepareRequest.ts\nfunction prepareRequest(request) {\n  return {\n    ...request,\n    body: request.body,\n    headers: request.headers.all()\n  };\n}\n\n// src/utils/logging/prepareResponse.ts\n\nfunction prepareResponse(res) {\n  const responseHeaders = (0,headers_polyfill__WEBPACK_IMPORTED_MODULE_8__.objectToHeaders)(res.headers);\n  const parsedBody = parseBody(res.body, responseHeaders);\n  return {\n    ...res,\n    body: parsedBody\n  };\n}\n\n// src/utils/matching/matchRequestUrl.ts\n\n\n\n// src/utils/url/cleanUrl.ts\nvar REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g;\nfunction getSearchParams(path) {\n  return new URL(`/${path}`, \"http://localhost\").searchParams;\n}\nfunction cleanUrl(path) {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, \"\");\n}\n\n// src/utils/url/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n}\n\n// src/utils/url/getAbsoluteUrl.ts\nfunction getAbsoluteUrl(path, baseUrl) {\n  if (isAbsoluteUrl(path)) {\n    return path;\n  }\n  if (path.startsWith(\"*\")) {\n    return path;\n  }\n  const origin = baseUrl || typeof document !== \"undefined\" && document.baseURI;\n  return origin ? decodeURI(new URL(encodeURI(path), origin).href) : path;\n}\n\n// src/utils/matching/normalizePath.ts\nfunction normalizePath(path, baseUrl) {\n  if (path instanceof RegExp) {\n    return path;\n  }\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);\n  return cleanUrl(maybeAbsoluteUrl);\n}\n\n// src/utils/matching/matchRequestUrl.ts\nfunction coercePath(path) {\n  return path.replace(\n    /([:a-zA-Z_-]*)(\\*{1,2})+/g,\n    (_, parameterName, wildcard) => {\n      const expression = \"(.*)\";\n      if (!parameterName) {\n        return expression;\n      }\n      return parameterName.startsWith(\":\") ? `${parameterName}${wildcard}` : `${parameterName}${expression}`;\n    }\n  ).replace(/([^\\/])(:)(?=\\d+)/, \"$1\\\\$2\").replace(/^([^\\/]+)(:)(?=\\/\\/)/, \"$1\\\\$2\");\n}\nfunction matchRequestUrl(url, path, baseUrl) {\n  const normalizedPath = normalizePath(path, baseUrl);\n  const cleanPath = typeof normalizedPath === \"string\" ? coercePath(normalizedPath) : normalizedPath;\n  const cleanUrl2 = (0,_mswjs_interceptors_lib_utils_getCleanUrl_js__WEBPACK_IMPORTED_MODULE_13__.getCleanUrl)(url);\n  const result = (0,path_to_regexp__WEBPACK_IMPORTED_MODULE_14__.match)(cleanPath, { decode: decodeURIComponent })(cleanUrl2);\n  const params = result && result.params || {};\n  return {\n    matches: result !== false,\n    params\n  };\n}\n\n// src/handlers/RequestHandler.ts\n\n\n// src/response.ts\n\n\n// src/utils/internal/compose.ts\nfunction compose(...fns) {\n  return (...args) => {\n    return fns.reduceRight((leftFn, rightFn) => {\n      return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);\n    }, args[0]);\n  };\n}\n\n// src/utils/NetworkError.ts\nvar NetworkError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"NetworkError\";\n  }\n};\n\n// src/response.ts\nvar defaultResponse = {\n  status: 200,\n  statusText: \"OK\",\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false\n};\nvar defaultResponseTransformers = [];\nfunction createResponseComposition(responseOverrides, defaultTransformers = defaultResponseTransformers) {\n  return async (...transformers) => {\n    const initialResponse = Object.assign(\n      {},\n      defaultResponse,\n      {\n        headers: new headers_polyfill__WEBPACK_IMPORTED_MODULE_8__.Headers({\n          \"x-powered-by\": \"msw\"\n        })\n      },\n      responseOverrides\n    );\n    const resolvedTransformers = [\n      ...defaultTransformers,\n      ...transformers\n    ].filter(Boolean);\n    const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;\n    return resolvedResponse;\n  };\n}\nvar response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({ once: true }),\n  networkError(message) {\n    throw new NetworkError(message);\n  }\n});\n\n// src/utils/internal/getCallFrame.ts\nvar SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/;\nvar BUILD_FRAME = /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/;\nfunction getCallFrame(error2) {\n  const stack = error2.stack;\n  if (!stack) {\n    return;\n  }\n  const frames = stack.split(\"\\n\").slice(1);\n  const declarationFrame = frames.find((frame) => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame));\n  });\n  if (!declarationFrame) {\n    return;\n  }\n  const declarationPath = declarationFrame.replace(/\\s*at [^()]*\\(([^)]+)\\)/, \"$1\").replace(/^@/, \"\");\n  return declarationPath;\n}\n\n// src/utils/internal/isIterable.ts\nfunction isIterable(fn) {\n  if (!fn) {\n    return false;\n  }\n  return typeof fn[Symbol.iterator] == \"function\";\n}\n\n// src/handlers/RequestHandler.ts\nvar defaultContext = {\n  status,\n  set,\n  delay,\n  fetch\n};\nvar RequestHandler = class {\n  constructor(options) {\n    this.shouldSkip = false;\n    this.ctx = options.ctx || defaultContext;\n    this.resolver = options.resolver;\n    const callFrame = getCallFrame(new Error());\n    this.info = {\n      ...options.info,\n      callFrame\n    };\n  }\n  parse(_request, _resolutionContext) {\n    return null;\n  }\n  test(request, resolutionContext) {\n    return this.predicate(\n      request,\n      this.parse(request, resolutionContext),\n      resolutionContext\n    );\n  }\n  getPublicRequest(request, _parsedResult) {\n    return request;\n  }\n  markAsSkipped(shouldSkip = true) {\n    this.shouldSkip = shouldSkip;\n  }\n  async run(request, resolutionContext) {\n    if (this.shouldSkip) {\n      return null;\n    }\n    const parsedResult = this.parse(request, resolutionContext);\n    const shouldIntercept = this.predicate(\n      request,\n      parsedResult,\n      resolutionContext\n    );\n    if (!shouldIntercept) {\n      return null;\n    }\n    const publicRequest = this.getPublicRequest(request, parsedResult);\n    const executeResolver = this.wrapResolver(this.resolver);\n    const mockedResponse = await executeResolver(\n      publicRequest,\n      response,\n      this.ctx\n    );\n    return this.createExecutionResult(\n      parsedResult,\n      publicRequest,\n      mockedResponse\n    );\n  }\n  wrapResolver(resolver) {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || await resolver(req, res, ctx);\n      if (isIterable(result)) {\n        const { value, done } = result[Symbol.iterator]().next();\n        const nextResponse = await value;\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult;\n        }\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result;\n        }\n        this.resolverGeneratorResult = nextResponse;\n        return nextResponse;\n      }\n      return result;\n    };\n  }\n  createExecutionResult(parsedResult, request, response2) {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response2 || null\n    };\n  }\n};\n\n// src/handlers/RestHandler.ts\nvar restContext = {\n  ...defaultContext,\n  cookie,\n  body,\n  text,\n  json,\n  xml\n};\nvar RestRequest = class extends MockedRequest {\n  constructor(request, params) {\n    super(request.url, {\n      ...request,\n      body: request[\"_body\"]\n    });\n    this.params = params;\n    this.id = request.id;\n  }\n};\nvar RestHandler = class extends RequestHandler {\n  constructor(method, path, resolver) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method\n      },\n      ctx: restContext,\n      resolver\n    });\n    this.checkRedundantQueryParameters();\n  }\n  checkRedundantQueryParameters() {\n    const { method, path } = this.info;\n    if (path instanceof RegExp) {\n      return;\n    }\n    const url = cleanUrl(path);\n    if (url === path) {\n      return;\n    }\n    const searchParams = getSearchParams(path);\n    const queryParams = [];\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName);\n    });\n    devUtils.warn(\n      `Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`\n    );\n  }\n  parse(request, resolutionContext) {\n    return matchRequestUrl(\n      request.url,\n      this.info.path,\n      resolutionContext == null ? void 0 : resolutionContext.baseUrl\n    );\n  }\n  getPublicRequest(request, parsedResult) {\n    return new RestRequest(request, parsedResult.params || {});\n  }\n  predicate(request, parsedResult) {\n    const matchesMethod = this.info.method instanceof RegExp ? this.info.method.test(request.method) : isStringEqual(this.info.method, request.method);\n    return matchesMethod && parsedResult.matches;\n  }\n  log(request, response2) {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    console.groupCollapsed(\n      devUtils.formatMessage(\"%s %s %s (%c%s%c)\"),\n      getTimestamp(),\n      request.method,\n      publicUrl,\n      `color:${statusColor}`,\n      `${response2.status} ${response2.statusText}`,\n      \"color:inherit\"\n    );\n    console.log(\"Request\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/context/field.ts\n\nvar field = (fieldName, fieldValue) => {\n  return (res) => {\n    validateFieldName(fieldName);\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { [fieldName]: fieldValue });\n    return json(nextBody)(res);\n  };\n};\nfunction validateFieldName(fieldName) {\n  (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(\n    fieldName.trim() !== \"\",\n    devUtils.formatMessage(\n      \"Failed to set a custom field on a GraphQL response: field name cannot be empty.\"\n    )\n  );\n  (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(\n    fieldName !== \"data\",\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?',\n      fieldName\n    )\n  );\n  (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(\n    fieldName !== \"errors\",\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?',\n      fieldName\n    )\n  );\n  (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(\n    fieldName !== \"extensions\",\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?',\n      fieldName\n    )\n  );\n}\n\n// src/utils/internal/tryCatch.ts\nfunction tryCatch(fn, onException) {\n  try {\n    const result = fn();\n    return result;\n  } catch (error2) {\n    onException == null ? void 0 : onException(error2);\n  }\n}\n\n// src/handlers/GraphQLHandler.ts\nvar graphqlContext = {\n  ...defaultContext,\n  data,\n  extensions,\n  errors,\n  cookie,\n  field\n};\nfunction isDocumentNode(value) {\n  if (value == null) {\n    return false;\n  }\n  return typeof value === \"object\" && \"kind\" in value && \"definitions\" in value;\n}\nvar GraphQLRequest = class extends MockedRequest {\n  constructor(request, variables, operationName) {\n    super(request.url, {\n      ...request,\n      body: request[\"_body\"]\n    });\n    this.variables = variables;\n    this.operationName = operationName;\n  }\n};\nvar GraphQLHandler = class extends RequestHandler {\n  constructor(operationType, operationName, endpoint, resolver) {\n    let resolvedOperationName = operationName;\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName);\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`\n        );\n      }\n      if (!parsedNode.operationName) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`\n        );\n      }\n      resolvedOperationName = parsedNode.operationName;\n    }\n    const header = operationType === \"all\" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`;\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName\n      },\n      ctx: graphqlContext,\n      resolver\n    });\n    this.endpoint = endpoint;\n  }\n  parse(request) {\n    return tryCatch(\n      () => parseGraphQLRequest(request),\n      (error2) => console.error(error2.message)\n    );\n  }\n  getPublicRequest(request, parsedResult) {\n    var _a, _b;\n    return new GraphQLRequest(\n      request,\n      (_a = parsedResult == null ? void 0 : parsedResult.variables) != null ? _a : {},\n      (_b = parsedResult == null ? void 0 : parsedResult.operationName) != null ? _b : \"\"\n    );\n  }\n  predicate(request, parsedResult) {\n    if (!parsedResult) {\n      return false;\n    }\n    if (!parsedResult.operationName && this.info.operationType !== \"all\") {\n      const publicUrl = getPublicUrlFromRequest(request);\n      devUtils.warn(`Failed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation()\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation      `);\n      return false;\n    }\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint);\n    const hasMatchingOperationType = this.info.operationType === \"all\" || parsedResult.operationType === this.info.operationType;\n    const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(parsedResult.operationName || \"\") : parsedResult.operationName === this.info.operationName;\n    return hasMatchingUrl.matches && hasMatchingOperationType && hasMatchingOperationName;\n  }\n  log(request, response2, parsedRequest) {\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    const requestInfo = (parsedRequest == null ? void 0 : parsedRequest.operationName) ? `${parsedRequest == null ? void 0 : parsedRequest.operationType} ${parsedRequest == null ? void 0 : parsedRequest.operationName}` : `anonymous ${parsedRequest == null ? void 0 : parsedRequest.operationType}`;\n    console.groupCollapsed(\n      devUtils.formatMessage(\"%s %s (%c%s%c)\"),\n      getTimestamp(),\n      `${requestInfo}`,\n      `color:${statusColor}`,\n      `${response2.status} ${response2.statusText}`,\n      \"color:inherit\"\n    );\n    console.log(\"Request:\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response:\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/utils/request/onUnhandledRequest.ts\nvar MAX_MATCH_SCORE = 3;\nvar MAX_SUGGESTION_COUNT = 4;\nvar TYPE_MATCH_DELTA = 0.5;\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce(\n    (groups, handler) => {\n      if (handler instanceof RestHandler) {\n        groups.rest.push(handler);\n      }\n      if (handler instanceof GraphQLHandler) {\n        groups.graphql.push(handler);\n      }\n      return groups;\n    },\n    {\n      rest: [],\n      graphql: []\n    }\n  );\n}\nfunction getRestHandlerScore() {\n  return (request, handler) => {\n    const { path, method } = handler.info;\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n    const hasSameMethod = isStringEqual(request.method, method);\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    const score = js_levenshtein__WEBPACK_IMPORTED_MODULE_10__(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === \"undefined\") {\n      return Infinity;\n    }\n    const { operationType, operationName } = handler.info;\n    if (typeof operationName !== \"string\") {\n      return Infinity;\n    }\n    const hasSameOperationType = parsedQuery.operationType === operationType;\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    const score = js_levenshtein__WEBPACK_IMPORTED_MODULE_10__(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\nfunction getSuggestedHandler(request, handlers, getScore) {\n  const suggestedHandlers = handlers.reduce((suggestions, handler) => {\n    const score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort(([leftScore], [rightScore]) => leftScore - rightScore).filter(([score]) => score <= MAX_MATCH_SCORE).slice(0, MAX_SUGGESTION_COUNT).map(([, handler]) => handler);\n  return suggestedHandlers;\n}\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return `Did you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `  \\u2022 ${handler.info.header}`).join(\"\\n\")}`;\n  }\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`;\n}\nfunction onUnhandledRequest(request, handlers, strategy = \"warn\") {\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));\n  function generateHandlerSuggestion() {\n    const handlerGroups = groupHandlersByType(handlers);\n    const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n    const suggestedHandlers = getSuggestedHandler(\n      request,\n      relevantHandlers,\n      parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore()\n    );\n    return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : \"\";\n  }\n  function generateUnhandledRequestMessage() {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;\n    const handlerSuggestion = generateHandlerSuggestion();\n    const messageTemplate = [\n      `captured a request without a matching request handler:`,\n      `  \\u2022 ${requestHeader}`,\n      handlerSuggestion,\n      `If you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks`\n    ].filter(Boolean);\n    return messageTemplate.join(\"\\n\\n\");\n  }\n  function applyStrategy(strategy2) {\n    const message = generateUnhandledRequestMessage();\n    switch (strategy2) {\n      case \"error\": {\n        devUtils.error(\"Error: %s\", message);\n        throw new Error(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'\n          )\n        );\n      }\n      case \"warn\": {\n        devUtils.warn(\"Warning: %s\", message);\n        break;\n      }\n      case \"bypass\":\n        break;\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy2\n          )\n        );\n    }\n  }\n  if (typeof strategy === \"function\") {\n    strategy(request, {\n      warning: applyStrategy.bind(null, \"warn\"),\n      error: applyStrategy.bind(null, \"error\")\n    });\n    return;\n  }\n  applyStrategy(strategy);\n}\n\n// src/utils/request/readResponseCookies.ts\n\nfunction readResponseCookies(request, response2) {\n  _mswjs_cookies__WEBPACK_IMPORTED_MODULE_6__.store.add({ ...request, url: request.url.toString() }, response2);\n  _mswjs_cookies__WEBPACK_IMPORTED_MODULE_6__.store.persist();\n}\n\n// src/utils/handleRequest.ts\nasync function handleRequest(request, handlers, options, emitter, handleRequestOptions) {\n  var _a, _b, _c, _d, _e, _f;\n  emitter.emit(\"request:start\", request);\n  if (request.headers.get(\"x-msw-bypass\") === \"true\") {\n    emitter.emit(\"request:end\", request);\n    (_a = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _a.call(handleRequestOptions, request);\n    return;\n  }\n  const [lookupError, lookupResult] = await (0,_open_draft_until__WEBPACK_IMPORTED_MODULE_9__.until)(() => {\n    return getResponse(\n      request,\n      handlers,\n      handleRequestOptions == null ? void 0 : handleRequestOptions.resolutionContext\n    );\n  });\n  if (lookupError) {\n    emitter.emit(\"unhandledException\", lookupError, request);\n    throw lookupError;\n  }\n  const { handler, response: response2 } = lookupResult;\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n    emitter.emit(\"request:unhandled\", request);\n    emitter.emit(\"request:end\", request);\n    (_b = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _b.call(handleRequestOptions, request);\n    return;\n  }\n  if (!response2) {\n    devUtils.warn(\n      `Expected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\n\n  \\u2022 %s\n    %s`,\n      response2,\n      handler.info.header,\n      handler.info.callFrame\n    );\n    emitter.emit(\"request:end\", request);\n    (_c = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _c.call(handleRequestOptions, request);\n    return;\n  }\n  if (response2.passthrough) {\n    emitter.emit(\"request:end\", request);\n    (_d = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _d.call(handleRequestOptions, request);\n    return;\n  }\n  readResponseCookies(request, response2);\n  emitter.emit(\"request:match\", request);\n  const requiredLookupResult = lookupResult;\n  const transformedResponse = ((_e = handleRequestOptions == null ? void 0 : handleRequestOptions.transformResponse) == null ? void 0 : _e.call(handleRequestOptions, response2)) || response2;\n  (_f = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponse) == null ? void 0 : _f.call(\n    handleRequestOptions,\n    transformedResponse,\n    requiredLookupResult\n  );\n  emitter.emit(\"request:end\", request);\n  return transformedResponse;\n}\n\n// src/node/SetupServerApi.ts\nvar { bold } = chalk__WEBPACK_IMPORTED_MODULE_1__;\nvar DEFAULT_LISTEN_OPTIONS = {\n  onUnhandledRequest: \"warn\"\n};\nvar SetupServerApi = class extends SetupApi {\n  constructor(interceptors, ...handlers) {\n    super(...handlers);\n    this.interceptor = new _mswjs_interceptors__WEBPACK_IMPORTED_MODULE_3__.BatchInterceptor({\n      name: \"setup-server\",\n      interceptors: interceptors.map((Interceptor2) => new Interceptor2())\n    });\n    this.resolvedOptions = {};\n    this.init();\n  }\n  init() {\n    this.interceptor.on(\"request\", async (request) => {\n      const mockedRequest = new MockedRequest(request.url, {\n        ...request,\n        body: await request.arrayBuffer()\n      });\n      const response2 = await handleRequest(\n        mockedRequest,\n        this.currentHandlers,\n        this.resolvedOptions,\n        this.emitter,\n        {\n          transformResponse(response3) {\n            return {\n              status: response3.status,\n              statusText: response3.statusText,\n              headers: response3.headers.all(),\n              body: response3.body,\n              delay: response3.delay\n            };\n          }\n        }\n      );\n      if (response2) {\n        if (response2.delay) {\n          await new Promise((resolve) => {\n            setTimeout(resolve, response2.delay);\n          });\n        }\n        request.respondWith(response2);\n      }\n      return;\n    });\n    this.interceptor.on(\"response\", (request, response2) => {\n      if (!request.id) {\n        return;\n      }\n      if (response2.headers.get(\"x-powered-by\") === \"msw\") {\n        this.emitter.emit(\"response:mocked\", response2, request.id);\n      } else {\n        this.emitter.emit(\"response:bypass\", response2, request.id);\n      }\n    });\n  }\n  listen(options = {}) {\n    this.resolvedOptions = mergeRight(\n      DEFAULT_LISTEN_OPTIONS,\n      options\n    );\n    this.interceptor.apply();\n    (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(\n      [_mswjs_interceptors__WEBPACK_IMPORTED_MODULE_3__.InterceptorReadyState.APPLYING, _mswjs_interceptors__WEBPACK_IMPORTED_MODULE_3__.InterceptorReadyState.APPLIED].includes(\n        this.interceptor.readyState\n      ),\n      devUtils.formatMessage(\n        'Failed to start \"setupServer\": the interceptor failed to apply. This is likely an issue with the library and you should report it at \"%s\".'\n      ),\n      \"https://github.com/mswjs/msw/issues/new/choose\"\n    );\n  }\n  printHandlers() {\n    const handlers = this.listHandlers();\n    handlers.forEach((handler) => {\n      const { header, callFrame } = handler.info;\n      const pragma = handler.info.hasOwnProperty(\"operationType\") ? \"[graphql]\" : \"[rest]\";\n      console.log(`${bold(`${pragma} ${header}`)}\n  Declaration: ${callFrame}\n`);\n    });\n  }\n  close() {\n    super.dispose();\n    this.interceptor.dispose();\n  }\n};\n\n// src/node/setupServer.ts\n\n\n\nvar setupServer = (...handlers) => {\n  return new SetupServerApi(\n    [_mswjs_interceptors_lib_interceptors_ClientRequest_index_js__WEBPACK_IMPORTED_MODULE_15__.ClientRequestInterceptor, _mswjs_interceptors_lib_interceptors_XMLHttpRequest_index_js__WEBPACK_IMPORTED_MODULE_16__.XMLHttpRequestInterceptor, _mswjs_interceptors_lib_interceptors_fetch_index_js__WEBPACK_IMPORTED_MODULE_17__.FetchInterceptor],\n    ...handlers\n  );\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL21zdy9saWIvbm9kZS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTs7QUFFQTtBQUNzRDtBQUN0RCxpQkFBaUIsOENBQWM7O0FBRS9CO0FBQzBCO0FBQzJCO0FBSXhCOztBQUU3QjtBQUN1QztBQUNROztBQUUvQztBQUNvQztBQUNwQztBQUNBO0FBQ0EsOEJBQThCLGtEQUFNO0FBQ3BDLFlBQVksZ0JBQWdCLEVBQUUsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBTztBQUM5Qiw2QkFBNkIseURBQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0scURBQVM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxNQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixzQkFBc0IsaUVBQWU7QUFDckM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUN1QztBQUN2QztBQUNBO0FBQ0EsNkJBQTZCLDZDQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGVBQWU7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHFCQUFxQjtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0RBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGVBQWU7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxrRUFBa0UsZUFBZSwyREFBMkQsNEJBQTRCO0FBQ3hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsb0JBQW9CO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNrRTtBQUNYO0FBQ3ZELGVBQWUsK0RBQWM7QUFDN0IsS0FBSyxvQkFBb0I7QUFDekI7QUFDQTtBQUNBLHNCQUFzQixxREFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3VFO0FBQ3ZFO0FBQ0EsMEJBQTBCLGlFQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDdUM7QUFDb0M7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsSUFBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWMsRUFBRSxTQUFTLE9BQU8sY0FBYyxFQUFFLFdBQVc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBGQUFXO0FBQy9CLGlCQUFpQixzREFBSyxjQUFjLDRCQUE0QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDdUQ7O0FBRXZEO0FBQ3VEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHFCQUFxQixxREFBUTtBQUM3QjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUSxFQUFFLEtBQUs7QUFDbEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUZBQXFGLFFBQVEsRUFBRSxLQUFLO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixTQUFTLGtCQUFrQixFQUFFLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3FEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlCQUF5QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUscURBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxxREFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUscURBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHFEQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUhBQXFILGNBQWMsY0FBYyx5QkFBeUI7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWUsV0FBVyxvQkFBb0IsUUFBUSxlQUFlLEVBQUUsdUJBQXVCLFdBQVcsb0JBQW9CO0FBQzdLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGdCQUFnQixFQUFFLFVBQVU7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0Riw4REFBOEQsRUFBRSw2REFBNkQsaUJBQWlCLDZEQUE2RDtBQUN2UztBQUNBO0FBQ0E7QUFDQSxTQUFTLFlBQVk7QUFDckIsZUFBZSxZQUFZO0FBQzNCLFNBQVMsa0JBQWtCLEVBQUUscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxzQ0FBc0Msb0JBQW9CLGNBQWM7QUFDMUU7QUFDQSxxQ0FBcUMsd0JBQXdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQ0FBa0MsRUFBRSxrQ0FBa0MsR0FBRyxnQkFBZ0IsRUFBRSxVQUFVLFFBQVEsZ0JBQWdCLEVBQUUsVUFBVTtBQUMzTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDaUQ7QUFDakQ7QUFDQSxFQUFFLGlEQUFNLE9BQU8seUNBQXlDO0FBQ3hELEVBQUUsaURBQU07QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0RBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0JBQStCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sT0FBTyxFQUFFLGtDQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpRUFBZ0I7QUFDM0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxREFBVTtBQUNkLE9BQU8sc0VBQXFCLFdBQVcsc0VBQXFCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBLHFCQUFxQixRQUFRLFFBQVEsRUFBRSxPQUFPO0FBQzlDLGlCQUFpQjtBQUNqQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDdUc7QUFDRTtBQUNsQjtBQUN2RjtBQUNBO0FBQ0EsS0FBSyxrSEFBd0IsRUFBRSxvSEFBeUIsRUFBRSxrR0FBZ0I7QUFDMUU7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvbXN3L2xpYi9ub2RlL2luZGV4Lm1qcz9hYmZlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19yZXF1aXJlID0gLyogQF9fUFVSRV9fICovICgoeCkgPT4gdHlwZW9mIHJlcXVpcmUgIT09IFwidW5kZWZpbmVkXCIgPyByZXF1aXJlIDogdHlwZW9mIFByb3h5ICE9PSBcInVuZGVmaW5lZFwiID8gbmV3IFByb3h5KHgsIHtcbiAgZ2V0OiAoYSwgYikgPT4gKHR5cGVvZiByZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiID8gcmVxdWlyZSA6IGEpW2JdXG59KSA6IHgpKGZ1bmN0aW9uKHgpIHtcbiAgaWYgKHR5cGVvZiByZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiKVxuICAgIHJldHVybiByZXF1aXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRocm93IG5ldyBFcnJvcignRHluYW1pYyByZXF1aXJlIG9mIFwiJyArIHggKyAnXCIgaXMgbm90IHN1cHBvcnRlZCcpO1xufSk7XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcblxuLy8gY29uZmlnL3BvbHlmaWxscy1ub2RlLnRzXG5pbXBvcnQgeyBzZXRUaW1lb3V0IGFzIG5vZGVTZXRUaW1lb3V0IH0gZnJvbSBcInRpbWVyc1wiO1xudmFyIHNldFRpbWVvdXQgPSBub2RlU2V0VGltZW91dDtcblxuLy8gc3JjL25vZGUvU2V0dXBTZXJ2ZXJBcGkudHNcbmltcG9ydCBjaGFsayBmcm9tIFwiY2hhbGtcIjtcbmltcG9ydCB7IGludmFyaWFudCBhcyBpbnZhcmlhbnQzIH0gZnJvbSBcIm91dHZhcmlhbnRcIjtcbmltcG9ydCB7XG4gIEJhdGNoSW50ZXJjZXB0b3IsXG4gIEludGVyY2VwdG9yUmVhZHlTdGF0ZVxufSBmcm9tIFwiQG1zd2pzL2ludGVyY2VwdG9yc1wiO1xuXG4vLyBzcmMvU2V0dXBBcGkudHNcbmltcG9ydCB7IGludmFyaWFudCB9IGZyb20gXCJvdXR2YXJpYW50XCI7XG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSBcInN0cmljdC1ldmVudC1lbWl0dGVyXCI7XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9kZXZVdGlscy50c1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSBcIm91dHZhcmlhbnRcIjtcbnZhciBMSUJSQVJZX1BSRUZJWCA9IFwiW01TV11cIjtcbmZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2UobWVzc2FnZSwgLi4ucG9zaXRpb25hbHMpIHtcbiAgY29uc3QgaW50ZXJwb2xhdGVkTWVzc2FnZSA9IGZvcm1hdChtZXNzYWdlLCAuLi5wb3NpdGlvbmFscyk7XG4gIHJldHVybiBgJHtMSUJSQVJZX1BSRUZJWH0gJHtpbnRlcnBvbGF0ZWRNZXNzYWdlfWA7XG59XG5mdW5jdGlvbiB3YXJuKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSB7XG4gIGNvbnNvbGUud2Fybihmb3JtYXRNZXNzYWdlKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSk7XG59XG5mdW5jdGlvbiBlcnJvcihtZXNzYWdlLCAuLi5wb3NpdGlvbmFscykge1xuICBjb25zb2xlLmVycm9yKGZvcm1hdE1lc3NhZ2UobWVzc2FnZSwgLi4ucG9zaXRpb25hbHMpKTtcbn1cbnZhciBkZXZVdGlscyA9IHtcbiAgZm9ybWF0TWVzc2FnZSxcbiAgd2FybixcbiAgZXJyb3Jcbn07XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9waXBlRXZlbnRzLnRzXG5mdW5jdGlvbiBwaXBlRXZlbnRzKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgY29uc3QgcmF3RW1pdCA9IHNvdXJjZS5lbWl0O1xuICBpZiAocmF3RW1pdC5faXNQaXBlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBzb3VyY2UuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50LCAuLi5kYXRhMikge1xuICAgIGRlc3RpbmF0aW9uLmVtaXQoZXZlbnQsIC4uLmRhdGEyKTtcbiAgICByZXR1cm4gcmF3RW1pdC5jYWxsKHRoaXMsIGV2ZW50LCAuLi5kYXRhMik7XG4gIH07XG4gIHNvdXJjZS5lbWl0Ll9pc1BpcGVkID0gdHJ1ZTtcbn1cblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL3RvUmVhZG9ubHlBcnJheS50c1xuZnVuY3Rpb24gdG9SZWFkb25seUFycmF5KHNvdXJjZSkge1xuICBjb25zdCBjbG9uZSA9IFsuLi5zb3VyY2VdO1xuICBPYmplY3QuZnJlZXplKGNsb25lKTtcbiAgcmV0dXJuIGNsb25lO1xufVxuXG4vLyBzcmMvU2V0dXBBcGkudHNcbnZhciBTZXR1cEFwaSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoLi4uaW5pdGlhbEhhbmRsZXJzKSB7XG4gICAgdGhpcy52YWxpZGF0ZUhhbmRsZXJzKC4uLmluaXRpYWxIYW5kbGVycyk7XG4gICAgdGhpcy5pbml0aWFsSGFuZGxlcnMgPSB0b1JlYWRvbmx5QXJyYXkoaW5pdGlhbEhhbmRsZXJzKTtcbiAgICB0aGlzLmN1cnJlbnRIYW5kbGVycyA9IFsuLi5pbml0aWFsSGFuZGxlcnNdO1xuICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgdGhpcy5wdWJsaWNFbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICBwaXBlRXZlbnRzKHRoaXMuZW1pdHRlciwgdGhpcy5wdWJsaWNFbWl0dGVyKTtcbiAgICB0aGlzLmV2ZW50cyA9IHRoaXMuY3JlYXRlTGlmZUN5Y2xlRXZlbnRzKCk7XG4gIH1cbiAgdmFsaWRhdGVIYW5kbGVycyguLi5oYW5kbGVycykge1xuICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICAhQXJyYXkuaXNBcnJheShoYW5kbGVyKSxcbiAgICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICAnRmFpbGVkIHRvIGNvbnN0cnVjdCBcIiVzXCIgZ2l2ZW4gYW4gQXJyYXkgb2YgcmVxdWVzdCBoYW5kbGVycy4gTWFrZSBzdXJlIHlvdSBzcHJlYWQgdGhlIHJlcXVlc3QgaGFuZGxlcnMgd2hlbiBjYWxsaW5nIHRoZSByZXNwZWN0aXZlIHNldHVwIGZ1bmN0aW9uLidcbiAgICAgICAgKSxcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnB1YmxpY0VtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbiAgdXNlKC4uLnJ1bnRpbWVIYW5kbGVycykge1xuICAgIHRoaXMuY3VycmVudEhhbmRsZXJzLnVuc2hpZnQoLi4ucnVudGltZUhhbmRsZXJzKTtcbiAgfVxuICByZXN0b3JlSGFuZGxlcnMoKSB7XG4gICAgdGhpcy5jdXJyZW50SGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgaGFuZGxlci5tYXJrQXNTa2lwcGVkKGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuICByZXNldEhhbmRsZXJzKC4uLm5leHRIYW5kbGVycykge1xuICAgIHRoaXMuY3VycmVudEhhbmRsZXJzID0gbmV4dEhhbmRsZXJzLmxlbmd0aCA+IDAgPyBbLi4ubmV4dEhhbmRsZXJzXSA6IFsuLi50aGlzLmluaXRpYWxIYW5kbGVyc107XG4gIH1cbiAgbGlzdEhhbmRsZXJzKCkge1xuICAgIHJldHVybiB0b1JlYWRvbmx5QXJyYXkodGhpcy5jdXJyZW50SGFuZGxlcnMpO1xuICB9XG4gIGNyZWF0ZUxpZmVDeWNsZUV2ZW50cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb246ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY0VtaXR0ZXIub24oLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlTGlzdGVuZXI6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY0VtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiAoLi4uYXJncykgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyguLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvaXNPYmplY3QudHNcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9tZXJnZVJpZ2h0LnRzXG5mdW5jdGlvbiBtZXJnZVJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyaWdodCkucmVkdWNlKChyZXN1bHQsIFtrZXksIHJpZ2h0VmFsdWVdKSA9PiB7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gcmVzdWx0W2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGVmdFZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHJpZ2h0VmFsdWUpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGxlZnRWYWx1ZS5jb25jYXQocmlnaHRWYWx1ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QobGVmdFZhbHVlKSAmJiBpc09iamVjdChyaWdodFZhbHVlKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZVJpZ2h0KGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXN1bHRba2V5XSA9IHJpZ2h0VmFsdWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgT2JqZWN0LmFzc2lnbih7fSwgbGVmdCkpO1xufVxuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9Nb2NrZWRSZXF1ZXN0LnRzXG5pbXBvcnQgKiBhcyBjb29raWVVdGlsczIgZnJvbSBcImNvb2tpZVwiO1xuaW1wb3J0IHsgc3RvcmUgfSBmcm9tIFwiQG1zd2pzL2Nvb2tpZXNcIjtcbmltcG9ydCB7IElzb21vcnBoaWNSZXF1ZXN0IH0gZnJvbSBcIkBtc3dqcy9pbnRlcmNlcHRvcnNcIjtcbmltcG9ydCB7IGRlY29kZUJ1ZmZlciB9IGZyb20gXCJAbXN3anMvaW50ZXJjZXB0b3JzL2xpYi91dGlscy9idWZmZXJVdGlscy5qc1wiO1xuaW1wb3J0IHsgSGVhZGVycyB9IGZyb20gXCJoZWFkZXJzLXBvbHlmaWxsXCI7XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L2dldFJlcXVlc3RDb29raWVzLnRzXG5pbXBvcnQgKiBhcyBjb29raWVVdGlscyBmcm9tIFwiY29va2llXCI7XG5mdW5jdGlvbiBnZXRBbGxDb29raWVzKCkge1xuICByZXR1cm4gY29va2llVXRpbHMucGFyc2UoZG9jdW1lbnQuY29va2llKTtcbn1cbmZ1bmN0aW9uIGdldFJlcXVlc3RDb29raWVzKHJlcXVlc3QpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgbG9jYXRpb24gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgc3dpdGNoIChyZXF1ZXN0LmNyZWRlbnRpYWxzKSB7XG4gICAgY2FzZSBcInNhbWUtb3JpZ2luXCI6IHtcbiAgICAgIHJldHVybiBsb2NhdGlvbi5vcmlnaW4gPT09IHJlcXVlc3QudXJsLm9yaWdpbiA/IGdldEFsbENvb2tpZXMoKSA6IHt9O1xuICAgIH1cbiAgICBjYXNlIFwiaW5jbHVkZVwiOiB7XG4gICAgICByZXR1cm4gZ2V0QWxsQ29va2llcygpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9qc29uUGFyc2UudHNcbmZ1bmN0aW9uIGpzb25QYXJzZSh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvcGFyc2VNdWx0aXBhcnREYXRhLnRzXG5pbXBvcnQgeyBzdHJpbmdUb0hlYWRlcnMgfSBmcm9tIFwiaGVhZGVycy1wb2x5ZmlsbFwiO1xuZnVuY3Rpb24gcGFyc2VDb250ZW50SGVhZGVycyhoZWFkZXJzU3RyaW5nKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IGhlYWRlcnMgPSBzdHJpbmdUb0hlYWRlcnMoaGVhZGVyc1N0cmluZyk7XG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJ0ZXh0L3BsYWluXCI7XG4gIGNvbnN0IGRpc3Bvc2l0aW9uID0gaGVhZGVycy5nZXQoXCJjb250ZW50LWRpc3Bvc2l0aW9uXCIpO1xuICBpZiAoIWRpc3Bvc2l0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIkNvbnRlbnQtRGlzcG9zaXRpb25cIiBoZWFkZXIgaXMgcmVxdWlyZWQuJyk7XG4gIH1cbiAgY29uc3QgZGlyZWN0aXZlcyA9IGRpc3Bvc2l0aW9uLnNwbGl0KFwiO1wiKS5yZWR1Y2UoKGFjYywgY2h1bmspID0+IHtcbiAgICBjb25zdCBbbmFtZTIsIC4uLnJlc3RdID0gY2h1bmsudHJpbSgpLnNwbGl0KFwiPVwiKTtcbiAgICBhY2NbbmFtZTJdID0gcmVzdC5qb2luKFwiPVwiKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIGNvbnN0IG5hbWUgPSAoX2EgPSBkaXJlY3RpdmVzLm5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zbGljZSgxLCAtMSk7XG4gIGNvbnN0IGZpbGVuYW1lID0gKF9iID0gZGlyZWN0aXZlcy5maWxlbmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnNsaWNlKDEsIC0xKTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIGZpbGVuYW1lLFxuICAgIGNvbnRlbnRUeXBlXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZU11bHRpcGFydERhdGEoZGF0YTIsIGhlYWRlcnMpIHtcbiAgY29uc3QgY29udGVudFR5cGUgPSBoZWFkZXJzID09IG51bGwgPyB2b2lkIDAgOiBoZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgaWYgKCFjb250ZW50VHlwZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgWywgLi4uZGlyZWN0aXZlc10gPSBjb250ZW50VHlwZS5zcGxpdCgvOyAqLyk7XG4gIGNvbnN0IGJvdW5kYXJ5ID0gZGlyZWN0aXZlcy5maWx0ZXIoKGQpID0+IGQuc3RhcnRzV2l0aChcImJvdW5kYXJ5PVwiKSkubWFwKChzKSA9PiBzLnJlcGxhY2UoL15ib3VuZGFyeT0vLCBcIlwiKSlbMF07XG4gIGlmICghYm91bmRhcnkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IGJvdW5kYXJ5UmVnRXhwID0gbmV3IFJlZ0V4cChgLS0rJHtib3VuZGFyeX1gKTtcbiAgY29uc3QgZmllbGRzID0gZGF0YTIuc3BsaXQoYm91bmRhcnlSZWdFeHApLmZpbHRlcigoY2h1bmspID0+IGNodW5rLnN0YXJ0c1dpdGgoXCJcXHJcXG5cIikgJiYgY2h1bmsuZW5kc1dpdGgoXCJcXHJcXG5cIikpLm1hcCgoY2h1bmspID0+IGNodW5rLnRyaW1TdGFydCgpLnJlcGxhY2UoL1xcclxcbiQvLCBcIlwiKSk7XG4gIGlmICghZmllbGRzLmxlbmd0aCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgcGFyc2VkQm9keSA9IHt9O1xuICB0cnkge1xuICAgIGZvciAoY29uc3QgZmllbGQyIG9mIGZpZWxkcykge1xuICAgICAgY29uc3QgW2NvbnRlbnRIZWFkZXJzLCAuLi5yZXN0XSA9IGZpZWxkMi5zcGxpdChcIlxcclxcblxcclxcblwiKTtcbiAgICAgIGNvbnN0IGNvbnRlbnRCb2R5ID0gcmVzdC5qb2luKFwiXFxyXFxuXFxyXFxuXCIpO1xuICAgICAgY29uc3QgeyBjb250ZW50VHlwZTogY29udGVudFR5cGUyLCBmaWxlbmFtZSwgbmFtZSB9ID0gcGFyc2VDb250ZW50SGVhZGVycyhjb250ZW50SGVhZGVycyk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGZpbGVuYW1lID09PSB2b2lkIDAgPyBjb250ZW50Qm9keSA6IG5ldyBGaWxlKFtjb250ZW50Qm9keV0sIGZpbGVuYW1lLCB7IHR5cGU6IGNvbnRlbnRUeXBlMiB9KTtcbiAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VkQm9keVtuYW1lXTtcbiAgICAgIGlmIChwYXJzZWRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHBhcnNlZEJvZHlbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRWYWx1ZSkpIHtcbiAgICAgICAgcGFyc2VkQm9keVtuYW1lXSA9IFsuLi5wYXJzZWRWYWx1ZSwgdmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkQm9keVtuYW1lXSA9IFtwYXJzZWRWYWx1ZSwgdmFsdWVdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkQm9keTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9wYXJzZUJvZHkudHNcbmZ1bmN0aW9uIHBhcnNlQm9keShib2R5MiwgaGVhZGVycykge1xuICB2YXIgX2E7XG4gIGlmICghYm9keTIpIHtcbiAgICByZXR1cm4gYm9keTI7XG4gIH1cbiAgY29uc3QgY29udGVudFR5cGUgPSAoKF9hID0gaGVhZGVycyA9PSBudWxsID8gdm9pZCAwIDogaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikpID09IG51bGwgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKSB8fCBcIlwiO1xuICBjb25zdCBoYXNNdWx0aXBhcnRDb250ZW50ID0gY29udGVudFR5cGUuc3RhcnRzV2l0aChcIm11bHRpcGFydC9mb3JtLWRhdGFcIik7XG4gIGlmIChoYXNNdWx0aXBhcnRDb250ZW50ICYmIHR5cGVvZiBib2R5MiAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBwYXJzZU11bHRpcGFydERhdGEoYm9keTIudG9TdHJpbmcoKSwgaGVhZGVycykgfHwgYm9keTI7XG4gIH1cbiAgY29uc3QgaGFzSnNvbkNvbnRlbnQgPSBjb250ZW50VHlwZS5pbmNsdWRlcyhcImpzb25cIik7XG4gIGlmIChoYXNKc29uQ29udGVudCAmJiB0eXBlb2YgYm9keTIgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4ganNvblBhcnNlKGJvZHkyLnRvU3RyaW5nKCkpIHx8IGJvZHkyO1xuICB9XG4gIHJldHVybiBib2R5Mjtcbn1cblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL2lzU3RyaW5nRXF1YWwudHNcbmZ1bmN0aW9uIGlzU3RyaW5nRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkge1xuICByZXR1cm4gYWN0dWFsLnRvTG93ZXJDYXNlKCkgPT09IGV4cGVjdGVkLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L01vY2tlZFJlcXVlc3QudHNcbnZhciBNb2NrZWRSZXF1ZXN0ID0gY2xhc3MgZXh0ZW5kcyBJc29tb3JwaGljUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yKHVybCwgaW5pdCA9IHt9KSB7XG4gICAgc3VwZXIodXJsLCBpbml0KTtcbiAgICBpZiAoaW5pdC5pZCkge1xuICAgICAgdGhpcy5pZCA9IGluaXQuaWQ7XG4gICAgfVxuICAgIHRoaXMuY2FjaGUgPSBpbml0LmNhY2hlIHx8IFwiZGVmYXVsdFwiO1xuICAgIHRoaXMuZGVzdGluYXRpb24gPSBpbml0LmRlc3RpbmF0aW9uIHx8IFwiXCI7XG4gICAgdGhpcy5pbnRlZ3JpdHkgPSBpbml0LmludGVncml0eSB8fCBcIlwiO1xuICAgIHRoaXMua2VlcGFsaXZlID0gaW5pdC5rZWVwYWxpdmUgfHwgZmFsc2U7XG4gICAgdGhpcy5tb2RlID0gaW5pdC5tb2RlIHx8IFwiY29yc1wiO1xuICAgIHRoaXMucHJpb3JpdHkgPSBpbml0LnByaW9yaXR5IHx8IFwiYXV0b1wiO1xuICAgIHRoaXMucmVkaXJlY3QgPSBpbml0LnJlZGlyZWN0IHx8IFwiZm9sbG93XCI7XG4gICAgdGhpcy5yZWZlcnJlciA9IGluaXQucmVmZXJyZXIgfHwgXCJcIjtcbiAgICB0aGlzLnJlZmVycmVyUG9saWN5ID0gaW5pdC5yZWZlcnJlclBvbGljeSB8fCBcIm5vLXJlZmVycmVyXCI7XG4gICAgdGhpcy5jb29raWVzID0gaW5pdC5jb29raWVzIHx8IHRoaXMuZ2V0Q29va2llcygpO1xuICB9XG4gIGdldCBib2R5KCkge1xuICAgIGNvbnN0IHRleHQyID0gZGVjb2RlQnVmZmVyKHRoaXNbXCJfYm9keVwiXSk7XG4gICAgY29uc3QgYm9keTIgPSBwYXJzZUJvZHkodGV4dDIsIHRoaXMuaGVhZGVycyk7XG4gICAgaWYgKGlzU3RyaW5nRXF1YWwodGhpcy5tZXRob2QsIFwiR0VUXCIpICYmIGJvZHkyID09PSBcIlwiKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gYm9keTI7XG4gIH1cbiAgcGFzc3Rocm91Z2goKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogMTAxLFxuICAgICAgc3RhdHVzVGV4dDogXCJDb250aW51ZVwiLFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoKSxcbiAgICAgIGJvZHk6IG51bGwsXG4gICAgICBwYXNzdGhyb3VnaDogdHJ1ZSxcbiAgICAgIG9uY2U6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBnZXRDb29raWVzKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXF1ZXN0Q29va2llc1N0cmluZyA9IHRoaXMuaGVhZGVycy5nZXQoXCJjb29raWVcIik7XG4gICAgY29uc3Qgb3duQ29va2llcyA9IHJlcXVlc3RDb29raWVzU3RyaW5nID8gY29va2llVXRpbHMyLnBhcnNlKHJlcXVlc3RDb29raWVzU3RyaW5nKSA6IHt9O1xuICAgIHN0b3JlLmh5ZHJhdGUoKTtcbiAgICBjb25zdCBjb29raWVzRnJvbVN0b3JlID0gQXJyYXkuZnJvbShcbiAgICAgIChfYSA9IHN0b3JlLmdldCh7IC4uLnRoaXMsIHVybDogdGhpcy51cmwuaHJlZiB9KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmVudHJpZXMoKVxuICAgICkucmVkdWNlKChjb29raWVzLCBbbmFtZSwgeyB2YWx1ZSB9XSkgPT4ge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oY29va2llcywgeyBbbmFtZS50cmltKCldOiB2YWx1ZSB9KTtcbiAgICB9LCB7fSk7XG4gICAgY29uc3QgY29va2llc0Zyb21Eb2N1bWVudCA9IGdldFJlcXVlc3RDb29raWVzKHRoaXMpO1xuICAgIGNvbnN0IGZvcndhcmRlZENvb2tpZXMgPSB7XG4gICAgICAuLi5jb29raWVzRnJvbURvY3VtZW50LFxuICAgICAgLi4uY29va2llc0Zyb21TdG9yZVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZvcndhcmRlZENvb2tpZXMpKSB7XG4gICAgICB0aGlzLmhlYWRlcnMuYXBwZW5kKFwiY29va2llXCIsIGAke25hbWV9PSR7dmFsdWV9YCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5mb3J3YXJkZWRDb29raWVzLFxuICAgICAgLi4ub3duQ29va2llc1xuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9oYW5kbGVSZXF1ZXN0LnRzXG5pbXBvcnQgeyB1bnRpbCB9IGZyb20gXCJAb3Blbi1kcmFmdC91bnRpbFwiO1xuXG4vLyBzcmMvdXRpbHMvZ2V0UmVzcG9uc2UudHNcbnZhciBnZXRSZXNwb25zZSA9IGFzeW5jIChyZXF1ZXN0LCBoYW5kbGVycywgcmVzb2x1dGlvbkNvbnRleHQpID0+IHtcbiAgY29uc3QgcmVsZXZhbnRIYW5kbGVycyA9IGhhbmRsZXJzLmZpbHRlcigoaGFuZGxlcikgPT4ge1xuICAgIHJldHVybiBoYW5kbGVyLnRlc3QocmVxdWVzdCwgcmVzb2x1dGlvbkNvbnRleHQpO1xuICB9KTtcbiAgaWYgKHJlbGV2YW50SGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIHJlc3BvbnNlOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlbGV2YW50SGFuZGxlcnMucmVkdWNlKGFzeW5jIChleGVjdXRpb25SZXN1bHQsIGhhbmRsZXIpID0+IHtcbiAgICBjb25zdCBwcmV2aW91c1Jlc3VsdHMgPSBhd2FpdCBleGVjdXRpb25SZXN1bHQ7XG4gICAgaWYgKCEhKHByZXZpb3VzUmVzdWx0cyA9PSBudWxsID8gdm9pZCAwIDogcHJldmlvdXNSZXN1bHRzLnJlc3BvbnNlKSkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGlvblJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IGhhbmRsZXIucnVuKHJlcXVlc3QsIHJlc29sdXRpb25Db250ZXh0KTtcbiAgICBpZiAocmVzdWx0MiA9PT0gbnVsbCB8fCByZXN1bHQyLmhhbmRsZXIuc2hvdWxkU2tpcCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghcmVzdWx0Mi5yZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVxdWVzdDogcmVzdWx0Mi5yZXF1ZXN0LFxuICAgICAgICBoYW5kbGVyOiByZXN1bHQyLmhhbmRsZXIsXG4gICAgICAgIHJlc3BvbnNlOiB2b2lkIDAsXG4gICAgICAgIHBhcnNlZFJlc3VsdDogcmVzdWx0Mi5wYXJzZWRSZXN1bHRcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChyZXN1bHQyLnJlc3BvbnNlLm9uY2UpIHtcbiAgICAgIGhhbmRsZXIubWFya0FzU2tpcHBlZCh0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH0sIFByb21pc2UucmVzb2x2ZShudWxsKSk7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIHJlc3BvbnNlOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaGFuZGxlcjogcmVzdWx0LmhhbmRsZXIsXG4gICAgcHVibGljUmVxdWVzdDogcmVzdWx0LnJlcXVlc3QsXG4gICAgcGFyc2VkUmVxdWVzdDogcmVzdWx0LnBhcnNlZFJlc3VsdCxcbiAgICByZXNwb25zZTogcmVzdWx0LnJlc3BvbnNlXG4gIH07XG59O1xuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9vblVuaGFuZGxlZFJlcXVlc3QudHNcbmltcG9ydCBnZXRTdHJpbmdNYXRjaFNjb3JlIGZyb20gXCJqcy1sZXZlbnNodGVpblwiO1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvcGFyc2VHcmFwaFFMUmVxdWVzdC50c1xuaW1wb3J0IHsgcGFyc2UgYXMgcGFyc2UzIH0gZnJvbSBcImdyYXBocWxcIjtcblxuLy8gc3JjL3V0aWxzL3JlcXVlc3QvZ2V0UHVibGljVXJsRnJvbVJlcXVlc3QudHNcbnZhciBnZXRQdWJsaWNVcmxGcm9tUmVxdWVzdCA9IChyZXF1ZXN0KSA9PiB7XG4gIHJldHVybiByZXF1ZXN0LnJlZmVycmVyLnN0YXJ0c1dpdGgocmVxdWVzdC51cmwub3JpZ2luKSA/IHJlcXVlc3QudXJsLnBhdGhuYW1lIDogbmV3IFVSTChcbiAgICByZXF1ZXN0LnVybC5wYXRobmFtZSxcbiAgICBgJHtyZXF1ZXN0LnVybC5wcm90b2NvbH0vLyR7cmVxdWVzdC51cmwuaG9zdH1gXG4gICkuaHJlZjtcbn07XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9wYXJzZUdyYXBoUUxSZXF1ZXN0LnRzXG5mdW5jdGlvbiBwYXJzZURvY3VtZW50Tm9kZShub2RlKSB7XG4gIHZhciBfYTtcbiAgY29uc3Qgb3BlcmF0aW9uRGVmID0gbm9kZS5kZWZpbml0aW9ucy5maW5kKChkZWYpID0+IHtcbiAgICByZXR1cm4gZGVmLmtpbmQgPT09IFwiT3BlcmF0aW9uRGVmaW5pdGlvblwiO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBvcGVyYXRpb25UeXBlOiBvcGVyYXRpb25EZWYgPT0gbnVsbCA/IHZvaWQgMCA6IG9wZXJhdGlvbkRlZi5vcGVyYXRpb24sXG4gICAgb3BlcmF0aW9uTmFtZTogKF9hID0gb3BlcmF0aW9uRGVmID09IG51bGwgPyB2b2lkIDAgOiBvcGVyYXRpb25EZWYubmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVF1ZXJ5KHF1ZXJ5KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgYXN0ID0gcGFyc2UzKHF1ZXJ5KTtcbiAgICByZXR1cm4gcGFyc2VEb2N1bWVudE5vZGUoYXN0KTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgcmV0dXJuIGVycm9yMjtcbiAgfVxufVxuZnVuY3Rpb24gZXh0cmFjdE11bHRpcGFydFZhcmlhYmxlcyh2YXJpYWJsZXMsIG1hcCwgZmlsZXMpIHtcbiAgY29uc3Qgb3BlcmF0aW9ucyA9IHsgdmFyaWFibGVzIH07XG4gIGZvciAoY29uc3QgW2tleSwgcGF0aEFycmF5XSBvZiBPYmplY3QuZW50cmllcyhtYXApKSB7XG4gICAgaWYgKCEoa2V5IGluIGZpbGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBHaXZlbiBmaWxlcyBkbyBub3QgaGF2ZSBhIGtleSAnJHtrZXl9JyAuYCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZG90UGF0aCBvZiBwYXRoQXJyYXkpIHtcbiAgICAgIGNvbnN0IFtsYXN0UGF0aCwgLi4ucmV2ZXJzZWRQYXRoc10gPSBkb3RQYXRoLnNwbGl0KFwiLlwiKS5yZXZlcnNlKCk7XG4gICAgICBjb25zdCBwYXRocyA9IHJldmVyc2VkUGF0aHMucmV2ZXJzZSgpO1xuICAgICAgbGV0IHRhcmdldCA9IG9wZXJhdGlvbnM7XG4gICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgaWYgKCEocGF0aCBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9wZXJ0eSAnJHtwYXRoc30nIGlzIG5vdCBpbiBvcGVyYXRpb25zLmApO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IHRhcmdldFtwYXRoXTtcbiAgICAgIH1cbiAgICAgIHRhcmdldFtsYXN0UGF0aF0gPSBmaWxlc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3BlcmF0aW9ucy52YXJpYWJsZXM7XG59XG5mdW5jdGlvbiBnZXRHcmFwaFFMSW5wdXQocmVxdWVzdCkge1xuICB2YXIgX2EsIF9iO1xuICBzd2l0Y2ggKHJlcXVlc3QubWV0aG9kKSB7XG4gICAgY2FzZSBcIkdFVFwiOiB7XG4gICAgICBjb25zdCBxdWVyeSA9IHJlcXVlc3QudXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJxdWVyeVwiKTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHJlcXVlc3QudXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ2YXJpYWJsZXNcIikgfHwgXCJcIjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICB2YXJpYWJsZXM6IGpzb25QYXJzZSh2YXJpYWJsZXMpXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiUE9TVFwiOiB7XG4gICAgICBpZiAoKF9hID0gcmVxdWVzdC5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2EucXVlcnkpIHtcbiAgICAgICAgY29uc3QgeyBxdWVyeSwgdmFyaWFibGVzIH0gPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcXVlcnksXG4gICAgICAgICAgdmFyaWFibGVzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoKF9iID0gcmVxdWVzdC5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2Iub3BlcmF0aW9ucykge1xuICAgICAgICBjb25zdCB7IG9wZXJhdGlvbnMsIG1hcCwgLi4uZmlsZXMgfSA9IHJlcXVlc3QuYm9keTtcbiAgICAgICAgY29uc3QgcGFyc2VkT3BlcmF0aW9ucyA9IGpzb25QYXJzZShcbiAgICAgICAgICBvcGVyYXRpb25zXG4gICAgICAgICkgfHwge307XG4gICAgICAgIGlmICghcGFyc2VkT3BlcmF0aW9ucy5xdWVyeSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZE1hcCA9IGpzb25QYXJzZShtYXAgfHwgXCJcIikgfHwge307XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHBhcnNlZE9wZXJhdGlvbnMudmFyaWFibGVzID8gZXh0cmFjdE11bHRpcGFydFZhcmlhYmxlcyhcbiAgICAgICAgICBwYXJzZWRPcGVyYXRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgICBwYXJzZWRNYXAsXG4gICAgICAgICAgZmlsZXNcbiAgICAgICAgKSA6IHt9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHF1ZXJ5OiBwYXJzZWRPcGVyYXRpb25zLnF1ZXJ5LFxuICAgICAgICAgIHZhcmlhYmxlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlR3JhcGhRTFJlcXVlc3QocmVxdWVzdCkge1xuICBjb25zdCBpbnB1dCA9IGdldEdyYXBoUUxJbnB1dChyZXF1ZXN0KTtcbiAgaWYgKCFpbnB1dCB8fCAhaW5wdXQucXVlcnkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IHsgcXVlcnksIHZhcmlhYmxlcyB9ID0gaW5wdXQ7XG4gIGNvbnN0IHBhcnNlZFJlc3VsdCA9IHBhcnNlUXVlcnkocXVlcnkpO1xuICBpZiAocGFyc2VkUmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBjb25zdCByZXF1ZXN0UHVibGljVXJsID0gZ2V0UHVibGljVXJsRnJvbVJlcXVlc3QocmVxdWVzdCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgJ0ZhaWxlZCB0byBpbnRlcmNlcHQgYSBHcmFwaFFMIHJlcXVlc3QgdG8gXCIlcyAlc1wiOiBjYW5ub3QgcGFyc2UgcXVlcnkuIFNlZSB0aGUgZXJyb3IgbWVzc2FnZSBmcm9tIHRoZSBwYXJzZXIgYmVsb3cuXFxuXFxuJXMnLFxuICAgICAgICByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgcmVxdWVzdFB1YmxpY1VybCxcbiAgICAgICAgcGFyc2VkUmVzdWx0Lm1lc3NhZ2VcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgb3BlcmF0aW9uVHlwZTogcGFyc2VkUmVzdWx0Lm9wZXJhdGlvblR5cGUsXG4gICAgb3BlcmF0aW9uTmFtZTogcGFyc2VkUmVzdWx0Lm9wZXJhdGlvbk5hbWUsXG4gICAgdmFyaWFibGVzXG4gIH07XG59XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS9zdGF0dXNlc0AyLjAuMS9ub2RlX21vZHVsZXMvc3RhdHVzZXMvY29kZXMuanNvblxudmFyIGNvZGVzX2RlZmF1bHQgPSB7XG4gIFwiMTAwXCI6IFwiQ29udGludWVcIixcbiAgXCIxMDFcIjogXCJTd2l0Y2hpbmcgUHJvdG9jb2xzXCIsXG4gIFwiMTAyXCI6IFwiUHJvY2Vzc2luZ1wiLFxuICBcIjEwM1wiOiBcIkVhcmx5IEhpbnRzXCIsXG4gIFwiMjAwXCI6IFwiT0tcIixcbiAgXCIyMDFcIjogXCJDcmVhdGVkXCIsXG4gIFwiMjAyXCI6IFwiQWNjZXB0ZWRcIixcbiAgXCIyMDNcIjogXCJOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvblwiLFxuICBcIjIwNFwiOiBcIk5vIENvbnRlbnRcIixcbiAgXCIyMDVcIjogXCJSZXNldCBDb250ZW50XCIsXG4gIFwiMjA2XCI6IFwiUGFydGlhbCBDb250ZW50XCIsXG4gIFwiMjA3XCI6IFwiTXVsdGktU3RhdHVzXCIsXG4gIFwiMjA4XCI6IFwiQWxyZWFkeSBSZXBvcnRlZFwiLFxuICBcIjIyNlwiOiBcIklNIFVzZWRcIixcbiAgXCIzMDBcIjogXCJNdWx0aXBsZSBDaG9pY2VzXCIsXG4gIFwiMzAxXCI6IFwiTW92ZWQgUGVybWFuZW50bHlcIixcbiAgXCIzMDJcIjogXCJGb3VuZFwiLFxuICBcIjMwM1wiOiBcIlNlZSBPdGhlclwiLFxuICBcIjMwNFwiOiBcIk5vdCBNb2RpZmllZFwiLFxuICBcIjMwNVwiOiBcIlVzZSBQcm94eVwiLFxuICBcIjMwN1wiOiBcIlRlbXBvcmFyeSBSZWRpcmVjdFwiLFxuICBcIjMwOFwiOiBcIlBlcm1hbmVudCBSZWRpcmVjdFwiLFxuICBcIjQwMFwiOiBcIkJhZCBSZXF1ZXN0XCIsXG4gIFwiNDAxXCI6IFwiVW5hdXRob3JpemVkXCIsXG4gIFwiNDAyXCI6IFwiUGF5bWVudCBSZXF1aXJlZFwiLFxuICBcIjQwM1wiOiBcIkZvcmJpZGRlblwiLFxuICBcIjQwNFwiOiBcIk5vdCBGb3VuZFwiLFxuICBcIjQwNVwiOiBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiLFxuICBcIjQwNlwiOiBcIk5vdCBBY2NlcHRhYmxlXCIsXG4gIFwiNDA3XCI6IFwiUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIixcbiAgXCI0MDhcIjogXCJSZXF1ZXN0IFRpbWVvdXRcIixcbiAgXCI0MDlcIjogXCJDb25mbGljdFwiLFxuICBcIjQxMFwiOiBcIkdvbmVcIixcbiAgXCI0MTFcIjogXCJMZW5ndGggUmVxdWlyZWRcIixcbiAgXCI0MTJcIjogXCJQcmVjb25kaXRpb24gRmFpbGVkXCIsXG4gIFwiNDEzXCI6IFwiUGF5bG9hZCBUb28gTGFyZ2VcIixcbiAgXCI0MTRcIjogXCJVUkkgVG9vIExvbmdcIixcbiAgXCI0MTVcIjogXCJVbnN1cHBvcnRlZCBNZWRpYSBUeXBlXCIsXG4gIFwiNDE2XCI6IFwiUmFuZ2UgTm90IFNhdGlzZmlhYmxlXCIsXG4gIFwiNDE3XCI6IFwiRXhwZWN0YXRpb24gRmFpbGVkXCIsXG4gIFwiNDE4XCI6IFwiSSdtIGEgVGVhcG90XCIsXG4gIFwiNDIxXCI6IFwiTWlzZGlyZWN0ZWQgUmVxdWVzdFwiLFxuICBcIjQyMlwiOiBcIlVucHJvY2Vzc2FibGUgRW50aXR5XCIsXG4gIFwiNDIzXCI6IFwiTG9ja2VkXCIsXG4gIFwiNDI0XCI6IFwiRmFpbGVkIERlcGVuZGVuY3lcIixcbiAgXCI0MjVcIjogXCJUb28gRWFybHlcIixcbiAgXCI0MjZcIjogXCJVcGdyYWRlIFJlcXVpcmVkXCIsXG4gIFwiNDI4XCI6IFwiUHJlY29uZGl0aW9uIFJlcXVpcmVkXCIsXG4gIFwiNDI5XCI6IFwiVG9vIE1hbnkgUmVxdWVzdHNcIixcbiAgXCI0MzFcIjogXCJSZXF1ZXN0IEhlYWRlciBGaWVsZHMgVG9vIExhcmdlXCIsXG4gIFwiNDUxXCI6IFwiVW5hdmFpbGFibGUgRm9yIExlZ2FsIFJlYXNvbnNcIixcbiAgXCI1MDBcIjogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIixcbiAgXCI1MDFcIjogXCJOb3QgSW1wbGVtZW50ZWRcIixcbiAgXCI1MDJcIjogXCJCYWQgR2F0ZXdheVwiLFxuICBcIjUwM1wiOiBcIlNlcnZpY2UgVW5hdmFpbGFibGVcIixcbiAgXCI1MDRcIjogXCJHYXRld2F5IFRpbWVvdXRcIixcbiAgXCI1MDVcIjogXCJIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZFwiLFxuICBcIjUwNlwiOiBcIlZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzXCIsXG4gIFwiNTA3XCI6IFwiSW5zdWZmaWNpZW50IFN0b3JhZ2VcIixcbiAgXCI1MDhcIjogXCJMb29wIERldGVjdGVkXCIsXG4gIFwiNTA5XCI6IFwiQmFuZHdpZHRoIExpbWl0IEV4Y2VlZGVkXCIsXG4gIFwiNTEwXCI6IFwiTm90IEV4dGVuZGVkXCIsXG4gIFwiNTExXCI6IFwiTmV0d29yayBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiXG59O1xuXG4vLyBzcmMvY29udGV4dC9zdGF0dXMudHNcbnZhciBzdGF0dXMgPSAoc3RhdHVzQ29kZSwgc3RhdHVzVGV4dCkgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIHJlcy5zdGF0dXMgPSBzdGF0dXNDb2RlO1xuICAgIHJlcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCB8fCBjb2Rlc19kZWZhdWx0W1N0cmluZyhzdGF0dXNDb2RlKV07XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L3NldC50c1xuaW1wb3J0IHsgb2JqZWN0VG9IZWFkZXJzIH0gZnJvbSBcImhlYWRlcnMtcG9seWZpbGxcIjtcbmZ1bmN0aW9uIHNldCguLi5hcmdzKSB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgY29uc3QgW25hbWUsIHZhbHVlXSA9IGFyZ3M7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXMuaGVhZGVycy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gb2JqZWN0VG9IZWFkZXJzKG5hbWUpO1xuICAgICAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZTIsIG5hbWUyKSA9PiB7XG4gICAgICAgIHJlcy5oZWFkZXJzLmFwcGVuZChuYW1lMiwgdmFsdWUyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xufVxuXG4vLyBzcmMvY29udGV4dC9jb29raWUudHNcbmltcG9ydCAqIGFzIGNvb2tpZVV0aWxzMyBmcm9tIFwiY29va2llXCI7XG52YXIgY29va2llID0gKG5hbWUsIHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgY29uc3Qgc2VyaWFsaXplZENvb2tpZSA9IGNvb2tpZVV0aWxzMy5zZXJpYWxpemUobmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIHJlcy5oZWFkZXJzLmFwcGVuZChcIlNldC1Db29raWVcIiwgc2VyaWFsaXplZENvb2tpZSk7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZG9jdW1lbnQuY29va2llID0gc2VyaWFsaXplZENvb2tpZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L2JvZHkudHNcbnZhciBib2R5ID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgcmVzLmJvZHkgPSB2YWx1ZTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQvanNvbi50c1xudmFyIGpzb24gPSAoYm9keTIpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICByZXMuaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgIHJlcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keTIpO1xuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dC9kYXRhLnRzXG52YXIgZGF0YSA9IChwYXlsb2FkKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgY29uc3QgcHJldkJvZHkgPSBqc29uUGFyc2UocmVzLmJvZHkpIHx8IHt9O1xuICAgIGNvbnN0IG5leHRCb2R5ID0gbWVyZ2VSaWdodChwcmV2Qm9keSwgeyBkYXRhOiBwYXlsb2FkIH0pO1xuICAgIHJldHVybiBqc29uKG5leHRCb2R5KShyZXMpO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQvZXh0ZW5zaW9ucy50c1xudmFyIGV4dGVuc2lvbnMgPSAocGF5bG9hZCkgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIGNvbnN0IHByZXZCb2R5ID0ganNvblBhcnNlKHJlcy5ib2R5KSB8fCB7fTtcbiAgICBjb25zdCBuZXh0Qm9keSA9IG1lcmdlUmlnaHQocHJldkJvZHksIHsgZXh0ZW5zaW9uczogcGF5bG9hZCB9KTtcbiAgICByZXR1cm4ganNvbihuZXh0Qm9keSkocmVzKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L2RlbGF5LnRzXG5pbXBvcnQgeyBpc05vZGVQcm9jZXNzIH0gZnJvbSBcImlzLW5vZGUtcHJvY2Vzc1wiO1xudmFyIFNFVF9USU1FT1VUX01BWF9BTExPV0VEX0lOVCA9IDIxNDc0ODM2NDc7XG52YXIgTUlOX1NFUlZFUl9SRVNQT05TRV9USU1FID0gMTAwO1xudmFyIE1BWF9TRVJWRVJfUkVTUE9OU0VfVElNRSA9IDQwMDtcbnZhciBOT0RFX1NFUlZFUl9SRVNQT05TRV9USU1FID0gNTtcbnZhciBnZXRSYW5kb21TZXJ2ZXJSZXNwb25zZVRpbWUgPSAoKSA9PiB7XG4gIGlmIChpc05vZGVQcm9jZXNzKCkpIHtcbiAgICByZXR1cm4gTk9ERV9TRVJWRVJfUkVTUE9OU0VfVElNRTtcbiAgfVxuICByZXR1cm4gTWF0aC5mbG9vcihcbiAgICBNYXRoLnJhbmRvbSgpICogKE1BWF9TRVJWRVJfUkVTUE9OU0VfVElNRSAtIE1JTl9TRVJWRVJfUkVTUE9OU0VfVElNRSkgKyBNSU5fU0VSVkVSX1JFU1BPTlNFX1RJTUVcbiAgKTtcbn07XG52YXIgZGVsYXkgPSAoZHVyYXRpb25Pck1vZGUpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICBsZXQgZGVsYXlUaW1lO1xuICAgIGlmICh0eXBlb2YgZHVyYXRpb25Pck1vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHN3aXRjaCAoZHVyYXRpb25Pck1vZGUpIHtcbiAgICAgICAgY2FzZSBcImluZmluaXRlXCI6IHtcbiAgICAgICAgICBkZWxheVRpbWUgPSBTRVRfVElNRU9VVF9NQVhfQUxMT1dFRF9JTlQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJlYWxcIjoge1xuICAgICAgICAgIGRlbGF5VGltZSA9IGdldFJhbmRvbVNlcnZlclJlc3BvbnNlVGltZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGRlbGF5IGEgcmVzcG9uc2U6IHVua25vd24gZGVsYXkgbW9kZSBcIiR7ZHVyYXRpb25Pck1vZGV9XCIuIFBsZWFzZSBtYWtlIHN1cmUgeW91IHByb3ZpZGUgb25lIG9mIHRoZSBzdXBwb3J0ZWQgbW9kZXMgKFwicmVhbFwiLCBcImluZmluaXRlXCIpIG9yIGEgbnVtYmVyIHRvIFwiY3R4LmRlbGF5XCIuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbk9yTW9kZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZGVsYXlUaW1lID0gZ2V0UmFuZG9tU2VydmVyUmVzcG9uc2VUaW1lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkdXJhdGlvbk9yTW9kZSA+IFNFVF9USU1FT1VUX01BWF9BTExPV0VEX0lOVCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBkZWxheSBhIHJlc3BvbnNlOiBwcm92aWRlZCBkZWxheSBkdXJhdGlvbiAoJHtkdXJhdGlvbk9yTW9kZX0pIGV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCBkdXJhdGlvbiBmb3IgXCJzZXRUaW1lb3V0XCIgKCR7U0VUX1RJTUVPVVRfTUFYX0FMTE9XRURfSU5UfSkuIFRoaXMgd2lsbCBjYXVzZSB0aGUgcmVzcG9uc2UgdG8gYmUgcmV0dXJuZWQgaW1tZWRpYXRlbHkuIFBsZWFzZSB1c2UgYSBudW1iZXIgd2l0aGluIHRoZSBhbGxvd2VkIHJhbmdlIHRvIGRlbGF5IHRoZSByZXNwb25zZSBieSBleGFjdCBkdXJhdGlvbiwgb3IgY29uc2lkZXIgdGhlIFwiaW5maW5pdGVcIiBkZWxheSBtb2RlIHRvIGRlbGF5IHRoZSByZXNwb25zZSBpbmRlZmluaXRlbHkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVsYXlUaW1lID0gZHVyYXRpb25Pck1vZGU7XG4gICAgfVxuICAgIHJlcy5kZWxheSA9IGRlbGF5VGltZTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQvZXJyb3JzLnRzXG52YXIgZXJyb3JzID0gKGVycm9yc0xpc3QpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICBpZiAoZXJyb3JzTGlzdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBjb25zdCBwcmV2Qm9keSA9IGpzb25QYXJzZShyZXMuYm9keSkgfHwge307XG4gICAgY29uc3QgbmV4dEJvZHkgPSBtZXJnZVJpZ2h0KHByZXZCb2R5LCB7IGVycm9yczogZXJyb3JzTGlzdCB9KTtcbiAgICByZXR1cm4ganNvbihuZXh0Qm9keSkocmVzKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L2ZldGNoLnRzXG5pbXBvcnQgeyBpc05vZGVQcm9jZXNzIGFzIGlzTm9kZVByb2Nlc3MyIH0gZnJvbSBcImlzLW5vZGUtcHJvY2Vzc1wiO1xuaW1wb3J0IHsgSGVhZGVycyBhcyBIZWFkZXJzMiB9IGZyb20gXCJoZWFkZXJzLXBvbHlmaWxsXCI7XG52YXIgdXNlRmV0Y2ggPSBpc05vZGVQcm9jZXNzMigpID8gKGlucHV0LCBpbml0KSA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IF9fdG9FU00oX19yZXF1aXJlKFwibm9kZS1mZXRjaFwiKSkpLnRoZW4oXG4gICh7IGRlZmF1bHQ6IG5vZGVGZXRjaCB9KSA9PiBub2RlRmV0Y2goaW5wdXQsIGluaXQpXG4pIDogZ2xvYmFsVGhpcy5mZXRjaDtcbnZhciBhdWdtZW50UmVxdWVzdEluaXQgPSAocmVxdWVzdEluaXQpID0+IHtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzMihyZXF1ZXN0SW5pdC5oZWFkZXJzKTtcbiAgaGVhZGVycy5zZXQoXCJ4LW1zdy1ieXBhc3NcIiwgXCJ0cnVlXCIpO1xuICByZXR1cm4ge1xuICAgIC4uLnJlcXVlc3RJbml0LFxuICAgIGhlYWRlcnM6IGhlYWRlcnMuYWxsKClcbiAgfTtcbn07XG52YXIgY3JlYXRlRmV0Y2hSZXF1ZXN0UGFyYW1ldGVycyA9IChpbnB1dCkgPT4ge1xuICBjb25zdCB7IGJvZHk6IGJvZHkyLCBtZXRob2QgfSA9IGlucHV0O1xuICBjb25zdCByZXF1ZXN0UGFyYW1ldGVycyA9IHtcbiAgICAuLi5pbnB1dCxcbiAgICBib2R5OiB2b2lkIDBcbiAgfTtcbiAgaWYgKFtcIkdFVFwiLCBcIkhFQURcIl0uaW5jbHVkZXMobWV0aG9kKSkge1xuICAgIHJldHVybiByZXF1ZXN0UGFyYW1ldGVycztcbiAgfVxuICBpZiAodHlwZW9mIGJvZHkyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBib2R5MiA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgYm9keTIgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmVxdWVzdFBhcmFtZXRlcnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkyKTtcbiAgfSBlbHNlIHtcbiAgICByZXF1ZXN0UGFyYW1ldGVycy5ib2R5ID0gYm9keTI7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3RQYXJhbWV0ZXJzO1xufTtcbnZhciBmZXRjaCA9IChpbnB1dCwgcmVxdWVzdEluaXQgPSB7fSkgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHVzZUZldGNoKGlucHV0LCBhdWdtZW50UmVxdWVzdEluaXQocmVxdWVzdEluaXQpKTtcbiAgfVxuICBjb25zdCByZXF1ZXN0UGFyYW1ldGVycyA9IGNyZWF0ZUZldGNoUmVxdWVzdFBhcmFtZXRlcnMoaW5wdXQpO1xuICBjb25zdCBkZXJpdmVkUmVxdWVzdEluaXQgPSBhdWdtZW50UmVxdWVzdEluaXQocmVxdWVzdFBhcmFtZXRlcnMpO1xuICByZXR1cm4gdXNlRmV0Y2goaW5wdXQudXJsLmhyZWYsIGRlcml2ZWRSZXF1ZXN0SW5pdCk7XG59O1xuXG4vLyBzcmMvY29udGV4dC90ZXh0LnRzXG52YXIgdGV4dCA9IChib2R5MikgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIHJlcy5oZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQvcGxhaW5cIik7XG4gICAgcmVzLmJvZHkgPSBib2R5MjtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQveG1sLnRzXG52YXIgeG1sID0gKGJvZHkyKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgcmVzLmhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwidGV4dC94bWxcIik7XG4gICAgcmVzLmJvZHkgPSBib2R5MjtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLy8gc3JjL3V0aWxzL2xvZ2dpbmcvZ2V0U3RhdHVzQ29kZUNvbG9yLnRzXG5mdW5jdGlvbiBnZXRTdGF0dXNDb2RlQ29sb3Ioc3RhdHVzMikge1xuICBpZiAoc3RhdHVzMiA8IDMwMCkge1xuICAgIHJldHVybiBcIiM2OUFCMzJcIiAvKiBTdWNjZXNzICovO1xuICB9XG4gIGlmIChzdGF0dXMyIDwgNDAwKSB7XG4gICAgcmV0dXJuIFwiI0YwQkI0QlwiIC8qIFdhcm5pbmcgKi87XG4gIH1cbiAgcmV0dXJuIFwiI0U5NUY1RFwiIC8qIERhbmdlciAqLztcbn1cblxuLy8gc3JjL3V0aWxzL2xvZ2dpbmcvZ2V0VGltZXN0YW1wLnRzXG5mdW5jdGlvbiBnZXRUaW1lc3RhbXAoKSB7XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gIHJldHVybiBbbm93LmdldEhvdXJzKCksIG5vdy5nZXRNaW51dGVzKCksIG5vdy5nZXRTZWNvbmRzKCldLm1hcChTdHJpbmcpLm1hcCgoY2h1bmspID0+IGNodW5rLnNsaWNlKDAsIDIpKS5tYXAoKGNodW5rKSA9PiBjaHVuay5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCI6XCIpO1xufVxuXG4vLyBzcmMvdXRpbHMvbG9nZ2luZy9wcmVwYXJlUmVxdWVzdC50c1xuZnVuY3Rpb24gcHJlcGFyZVJlcXVlc3QocmVxdWVzdCkge1xuICByZXR1cm4ge1xuICAgIC4uLnJlcXVlc3QsXG4gICAgYm9keTogcmVxdWVzdC5ib2R5LFxuICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycy5hbGwoKVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMvbG9nZ2luZy9wcmVwYXJlUmVzcG9uc2UudHNcbmltcG9ydCB7IG9iamVjdFRvSGVhZGVycyBhcyBvYmplY3RUb0hlYWRlcnMyIH0gZnJvbSBcImhlYWRlcnMtcG9seWZpbGxcIjtcbmZ1bmN0aW9uIHByZXBhcmVSZXNwb25zZShyZXMpIHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gb2JqZWN0VG9IZWFkZXJzMihyZXMuaGVhZGVycyk7XG4gIGNvbnN0IHBhcnNlZEJvZHkgPSBwYXJzZUJvZHkocmVzLmJvZHksIHJlc3BvbnNlSGVhZGVycyk7XG4gIHJldHVybiB7XG4gICAgLi4ucmVzLFxuICAgIGJvZHk6IHBhcnNlZEJvZHlcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL21hdGNoaW5nL21hdGNoUmVxdWVzdFVybC50c1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwicGF0aC10by1yZWdleHBcIjtcbmltcG9ydCB7IGdldENsZWFuVXJsIH0gZnJvbSBcIkBtc3dqcy9pbnRlcmNlcHRvcnMvbGliL3V0aWxzL2dldENsZWFuVXJsLmpzXCI7XG5cbi8vIHNyYy91dGlscy91cmwvY2xlYW5VcmwudHNcbnZhciBSRURVTkRBTlRfQ0hBUkFDVEVSU19FWFAgPSAvW1xcP3wjXS4qJC9nO1xuZnVuY3Rpb24gZ2V0U2VhcmNoUGFyYW1zKHBhdGgpIHtcbiAgcmV0dXJuIG5ldyBVUkwoYC8ke3BhdGh9YCwgXCJodHRwOi8vbG9jYWxob3N0XCIpLnNlYXJjaFBhcmFtcztcbn1cbmZ1bmN0aW9uIGNsZWFuVXJsKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZShSRURVTkRBTlRfQ0hBUkFDVEVSU19FWFAsIFwiXCIpO1xufVxuXG4vLyBzcmMvdXRpbHMvdXJsL2lzQWJzb2x1dGVVcmwudHNcbmZ1bmN0aW9uIGlzQWJzb2x1dGVVcmwodXJsKSB7XG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn1cblxuLy8gc3JjL3V0aWxzL3VybC9nZXRBYnNvbHV0ZVVybC50c1xuZnVuY3Rpb24gZ2V0QWJzb2x1dGVVcmwocGF0aCwgYmFzZVVybCkge1xuICBpZiAoaXNBYnNvbHV0ZVVybChwYXRoKSkge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCIqXCIpKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgY29uc3Qgb3JpZ2luID0gYmFzZVVybCB8fCB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuYmFzZVVSSTtcbiAgcmV0dXJuIG9yaWdpbiA/IGRlY29kZVVSSShuZXcgVVJMKGVuY29kZVVSSShwYXRoKSwgb3JpZ2luKS5ocmVmKSA6IHBhdGg7XG59XG5cbi8vIHNyYy91dGlscy9tYXRjaGluZy9ub3JtYWxpemVQYXRoLnRzXG5mdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhdGgsIGJhc2VVcmwpIHtcbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBjb25zdCBtYXliZUFic29sdXRlVXJsID0gZ2V0QWJzb2x1dGVVcmwocGF0aCwgYmFzZVVybCk7XG4gIHJldHVybiBjbGVhblVybChtYXliZUFic29sdXRlVXJsKTtcbn1cblxuLy8gc3JjL3V0aWxzL21hdGNoaW5nL21hdGNoUmVxdWVzdFVybC50c1xuZnVuY3Rpb24gY29lcmNlUGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoXG4gICAgLyhbOmEtekEtWl8tXSopKFxcKnsxLDJ9KSsvZyxcbiAgICAoXywgcGFyYW1ldGVyTmFtZSwgd2lsZGNhcmQpID0+IHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBcIiguKilcIjtcbiAgICAgIGlmICghcGFyYW1ldGVyTmFtZSkge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbWV0ZXJOYW1lLnN0YXJ0c1dpdGgoXCI6XCIpID8gYCR7cGFyYW1ldGVyTmFtZX0ke3dpbGRjYXJkfWAgOiBgJHtwYXJhbWV0ZXJOYW1lfSR7ZXhwcmVzc2lvbn1gO1xuICAgIH1cbiAgKS5yZXBsYWNlKC8oW15cXC9dKSg6KSg/PVxcZCspLywgXCIkMVxcXFwkMlwiKS5yZXBsYWNlKC9eKFteXFwvXSspKDopKD89XFwvXFwvKS8sIFwiJDFcXFxcJDJcIik7XG59XG5mdW5jdGlvbiBtYXRjaFJlcXVlc3RVcmwodXJsLCBwYXRoLCBiYXNlVXJsKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplUGF0aChwYXRoLCBiYXNlVXJsKTtcbiAgY29uc3QgY2xlYW5QYXRoID0gdHlwZW9mIG5vcm1hbGl6ZWRQYXRoID09PSBcInN0cmluZ1wiID8gY29lcmNlUGF0aChub3JtYWxpemVkUGF0aCkgOiBub3JtYWxpemVkUGF0aDtcbiAgY29uc3QgY2xlYW5VcmwyID0gZ2V0Q2xlYW5VcmwodXJsKTtcbiAgY29uc3QgcmVzdWx0ID0gbWF0Y2goY2xlYW5QYXRoLCB7IGRlY29kZTogZGVjb2RlVVJJQ29tcG9uZW50IH0pKGNsZWFuVXJsMik7XG4gIGNvbnN0IHBhcmFtcyA9IHJlc3VsdCAmJiByZXN1bHQucGFyYW1zIHx8IHt9O1xuICByZXR1cm4ge1xuICAgIG1hdGNoZXM6IHJlc3VsdCAhPT0gZmFsc2UsXG4gICAgcGFyYW1zXG4gIH07XG59XG5cbi8vIHNyYy9oYW5kbGVycy9SZXF1ZXN0SGFuZGxlci50c1xuaW1wb3J0IHsgSGVhZGVycyBhcyBIZWFkZXJzNCB9IGZyb20gXCJoZWFkZXJzLXBvbHlmaWxsXCI7XG5cbi8vIHNyYy9yZXNwb25zZS50c1xuaW1wb3J0IHsgSGVhZGVycyBhcyBIZWFkZXJzMyB9IGZyb20gXCJoZWFkZXJzLXBvbHlmaWxsXCI7XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9jb21wb3NlLnRzXG5mdW5jdGlvbiBjb21wb3NlKC4uLmZucykge1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gZm5zLnJlZHVjZVJpZ2h0KChsZWZ0Rm4sIHJpZ2h0Rm4pID0+IHtcbiAgICAgIHJldHVybiBsZWZ0Rm4gaW5zdGFuY2VvZiBQcm9taXNlID8gUHJvbWlzZS5yZXNvbHZlKGxlZnRGbikudGhlbihyaWdodEZuKSA6IHJpZ2h0Rm4obGVmdEZuKTtcbiAgICB9LCBhcmdzWzBdKTtcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL05ldHdvcmtFcnJvci50c1xudmFyIE5ldHdvcmtFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJOZXR3b3JrRXJyb3JcIjtcbiAgfVxufTtcblxuLy8gc3JjL3Jlc3BvbnNlLnRzXG52YXIgZGVmYXVsdFJlc3BvbnNlID0ge1xuICBzdGF0dXM6IDIwMCxcbiAgc3RhdHVzVGV4dDogXCJPS1wiLFxuICBib2R5OiBudWxsLFxuICBkZWxheTogMCxcbiAgb25jZTogZmFsc2UsXG4gIHBhc3N0aHJvdWdoOiBmYWxzZVxufTtcbnZhciBkZWZhdWx0UmVzcG9uc2VUcmFuc2Zvcm1lcnMgPSBbXTtcbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlQ29tcG9zaXRpb24ocmVzcG9uc2VPdmVycmlkZXMsIGRlZmF1bHRUcmFuc2Zvcm1lcnMgPSBkZWZhdWx0UmVzcG9uc2VUcmFuc2Zvcm1lcnMpIHtcbiAgcmV0dXJuIGFzeW5jICguLi50cmFuc2Zvcm1lcnMpID0+IHtcbiAgICBjb25zdCBpbml0aWFsUmVzcG9uc2UgPSBPYmplY3QuYXNzaWduKFxuICAgICAge30sXG4gICAgICBkZWZhdWx0UmVzcG9uc2UsXG4gICAgICB7XG4gICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzMyh7XG4gICAgICAgICAgXCJ4LXBvd2VyZWQtYnlcIjogXCJtc3dcIlxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNlT3ZlcnJpZGVzXG4gICAgKTtcbiAgICBjb25zdCByZXNvbHZlZFRyYW5zZm9ybWVycyA9IFtcbiAgICAgIC4uLmRlZmF1bHRUcmFuc2Zvcm1lcnMsXG4gICAgICAuLi50cmFuc2Zvcm1lcnNcbiAgICBdLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCByZXNvbHZlZFJlc3BvbnNlID0gcmVzb2x2ZWRUcmFuc2Zvcm1lcnMubGVuZ3RoID4gMCA/IGNvbXBvc2UoLi4ucmVzb2x2ZWRUcmFuc2Zvcm1lcnMpKGluaXRpYWxSZXNwb25zZSkgOiBpbml0aWFsUmVzcG9uc2U7XG4gICAgcmV0dXJuIHJlc29sdmVkUmVzcG9uc2U7XG4gIH07XG59XG52YXIgcmVzcG9uc2UgPSBPYmplY3QuYXNzaWduKGNyZWF0ZVJlc3BvbnNlQ29tcG9zaXRpb24oKSwge1xuICBvbmNlOiBjcmVhdGVSZXNwb25zZUNvbXBvc2l0aW9uKHsgb25jZTogdHJ1ZSB9KSxcbiAgbmV0d29ya0Vycm9yKG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKG1lc3NhZ2UpO1xuICB9XG59KTtcblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL2dldENhbGxGcmFtZS50c1xudmFyIFNPVVJDRV9GUkFNRSA9IC9bXFwvXFxcXF1tc3dbXFwvXFxcXF1zcmNbXFwvXFxcXF0oLispLztcbnZhciBCVUlMRF9GUkFNRSA9IC8obm9kZV9tb2R1bGVzKT9bXFwvXFxcXF1saWJbXFwvXFxcXF0odW1kfGVzbXxpaWVmfGNqcylbXFwvXFxcXF18XlteXFwvXFxcXF0qJC87XG5mdW5jdGlvbiBnZXRDYWxsRnJhbWUoZXJyb3IyKSB7XG4gIGNvbnN0IHN0YWNrID0gZXJyb3IyLnN0YWNrO1xuICBpZiAoIXN0YWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZyYW1lcyA9IHN0YWNrLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDEpO1xuICBjb25zdCBkZWNsYXJhdGlvbkZyYW1lID0gZnJhbWVzLmZpbmQoKGZyYW1lKSA9PiB7XG4gICAgcmV0dXJuICEoU09VUkNFX0ZSQU1FLnRlc3QoZnJhbWUpIHx8IEJVSUxEX0ZSQU1FLnRlc3QoZnJhbWUpKTtcbiAgfSk7XG4gIGlmICghZGVjbGFyYXRpb25GcmFtZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkZWNsYXJhdGlvblBhdGggPSBkZWNsYXJhdGlvbkZyYW1lLnJlcGxhY2UoL1xccyphdCBbXigpXSpcXCgoW14pXSspXFwpLywgXCIkMVwiKS5yZXBsYWNlKC9eQC8sIFwiXCIpO1xuICByZXR1cm4gZGVjbGFyYXRpb25QYXRoO1xufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvaXNJdGVyYWJsZS50c1xuZnVuY3Rpb24gaXNJdGVyYWJsZShmbikge1xuICBpZiAoIWZuKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgZm5bU3ltYm9sLml0ZXJhdG9yXSA9PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8vIHNyYy9oYW5kbGVycy9SZXF1ZXN0SGFuZGxlci50c1xudmFyIGRlZmF1bHRDb250ZXh0ID0ge1xuICBzdGF0dXMsXG4gIHNldCxcbiAgZGVsYXksXG4gIGZldGNoXG59O1xudmFyIFJlcXVlc3RIYW5kbGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5zaG91bGRTa2lwID0gZmFsc2U7XG4gICAgdGhpcy5jdHggPSBvcHRpb25zLmN0eCB8fCBkZWZhdWx0Q29udGV4dDtcbiAgICB0aGlzLnJlc29sdmVyID0gb3B0aW9ucy5yZXNvbHZlcjtcbiAgICBjb25zdCBjYWxsRnJhbWUgPSBnZXRDYWxsRnJhbWUobmV3IEVycm9yKCkpO1xuICAgIHRoaXMuaW5mbyA9IHtcbiAgICAgIC4uLm9wdGlvbnMuaW5mbyxcbiAgICAgIGNhbGxGcmFtZVxuICAgIH07XG4gIH1cbiAgcGFyc2UoX3JlcXVlc3QsIF9yZXNvbHV0aW9uQ29udGV4dCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRlc3QocmVxdWVzdCwgcmVzb2x1dGlvbkNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGhpcy5wYXJzZShyZXF1ZXN0LCByZXNvbHV0aW9uQ29udGV4dCksXG4gICAgICByZXNvbHV0aW9uQ29udGV4dFxuICAgICk7XG4gIH1cbiAgZ2V0UHVibGljUmVxdWVzdChyZXF1ZXN0LCBfcGFyc2VkUmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cbiAgbWFya0FzU2tpcHBlZChzaG91bGRTa2lwID0gdHJ1ZSkge1xuICAgIHRoaXMuc2hvdWxkU2tpcCA9IHNob3VsZFNraXA7XG4gIH1cbiAgYXN5bmMgcnVuKHJlcXVlc3QsIHJlc29sdXRpb25Db250ZXh0KSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkU2tpcCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFJlc3VsdCA9IHRoaXMucGFyc2UocmVxdWVzdCwgcmVzb2x1dGlvbkNvbnRleHQpO1xuICAgIGNvbnN0IHNob3VsZEludGVyY2VwdCA9IHRoaXMucHJlZGljYXRlKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHBhcnNlZFJlc3VsdCxcbiAgICAgIHJlc29sdXRpb25Db250ZXh0XG4gICAgKTtcbiAgICBpZiAoIXNob3VsZEludGVyY2VwdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY1JlcXVlc3QgPSB0aGlzLmdldFB1YmxpY1JlcXVlc3QocmVxdWVzdCwgcGFyc2VkUmVzdWx0KTtcbiAgICBjb25zdCBleGVjdXRlUmVzb2x2ZXIgPSB0aGlzLndyYXBSZXNvbHZlcih0aGlzLnJlc29sdmVyKTtcbiAgICBjb25zdCBtb2NrZWRSZXNwb25zZSA9IGF3YWl0IGV4ZWN1dGVSZXNvbHZlcihcbiAgICAgIHB1YmxpY1JlcXVlc3QsXG4gICAgICByZXNwb25zZSxcbiAgICAgIHRoaXMuY3R4XG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVFeGVjdXRpb25SZXN1bHQoXG4gICAgICBwYXJzZWRSZXN1bHQsXG4gICAgICBwdWJsaWNSZXF1ZXN0LFxuICAgICAgbW9ja2VkUmVzcG9uc2VcbiAgICApO1xuICB9XG4gIHdyYXBSZXNvbHZlcihyZXNvbHZlcikge1xuICAgIHJldHVybiBhc3luYyAocmVxLCByZXMsIGN0eCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXNvbHZlckdlbmVyYXRvciB8fCBhd2FpdCByZXNvbHZlcihyZXEsIHJlcywgY3R4KTtcbiAgICAgIGlmIChpc0l0ZXJhYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gcmVzdWx0W1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCk7XG4gICAgICAgIGNvbnN0IG5leHRSZXNwb25zZSA9IGF3YWl0IHZhbHVlO1xuICAgICAgICBpZiAoIW5leHRSZXNwb25zZSAmJiBkb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZXJHZW5lcmF0b3JSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJlc29sdmVyR2VuZXJhdG9yKSB7XG4gICAgICAgICAgdGhpcy5yZXNvbHZlckdlbmVyYXRvciA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc29sdmVyR2VuZXJhdG9yUmVzdWx0ID0gbmV4dFJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gbmV4dFJlc3BvbnNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG4gIGNyZWF0ZUV4ZWN1dGlvblJlc3VsdChwYXJzZWRSZXN1bHQsIHJlcXVlc3QsIHJlc3BvbnNlMikge1xuICAgIHJldHVybiB7XG4gICAgICBoYW5kbGVyOiB0aGlzLFxuICAgICAgcGFyc2VkUmVzdWx0OiBwYXJzZWRSZXN1bHQgfHwgbnVsbCxcbiAgICAgIHJlcXVlc3QsXG4gICAgICByZXNwb25zZTogcmVzcG9uc2UyIHx8IG51bGxcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvaGFuZGxlcnMvUmVzdEhhbmRsZXIudHNcbnZhciByZXN0Q29udGV4dCA9IHtcbiAgLi4uZGVmYXVsdENvbnRleHQsXG4gIGNvb2tpZSxcbiAgYm9keSxcbiAgdGV4dCxcbiAganNvbixcbiAgeG1sXG59O1xudmFyIFJlc3RSZXF1ZXN0ID0gY2xhc3MgZXh0ZW5kcyBNb2NrZWRSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IocmVxdWVzdCwgcGFyYW1zKSB7XG4gICAgc3VwZXIocmVxdWVzdC51cmwsIHtcbiAgICAgIC4uLnJlcXVlc3QsXG4gICAgICBib2R5OiByZXF1ZXN0W1wiX2JvZHlcIl1cbiAgICB9KTtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLmlkID0gcmVxdWVzdC5pZDtcbiAgfVxufTtcbnZhciBSZXN0SGFuZGxlciA9IGNsYXNzIGV4dGVuZHMgUmVxdWVzdEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihtZXRob2QsIHBhdGgsIHJlc29sdmVyKSB7XG4gICAgc3VwZXIoe1xuICAgICAgaW5mbzoge1xuICAgICAgICBoZWFkZXI6IGAke21ldGhvZH0gJHtwYXRofWAsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG1ldGhvZFxuICAgICAgfSxcbiAgICAgIGN0eDogcmVzdENvbnRleHQsXG4gICAgICByZXNvbHZlclxuICAgIH0pO1xuICAgIHRoaXMuY2hlY2tSZWR1bmRhbnRRdWVyeVBhcmFtZXRlcnMoKTtcbiAgfVxuICBjaGVja1JlZHVuZGFudFF1ZXJ5UGFyYW1ldGVycygpIHtcbiAgICBjb25zdCB7IG1ldGhvZCwgcGF0aCB9ID0gdGhpcy5pbmZvO1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGNsZWFuVXJsKHBhdGgpO1xuICAgIGlmICh1cmwgPT09IHBhdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gZ2V0U2VhcmNoUGFyYW1zKHBhdGgpO1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gW107XG4gICAgc2VhcmNoUGFyYW1zLmZvckVhY2goKF8sIHBhcmFtTmFtZSkgPT4ge1xuICAgICAgcXVlcnlQYXJhbXMucHVzaChwYXJhbU5hbWUpO1xuICAgIH0pO1xuICAgIGRldlV0aWxzLndhcm4oXG4gICAgICBgRm91bmQgYSByZWR1bmRhbnQgdXNhZ2Ugb2YgcXVlcnkgcGFyYW1ldGVycyBpbiB0aGUgcmVxdWVzdCBoYW5kbGVyIFVSTCBmb3IgXCIke21ldGhvZH0gJHtwYXRofVwiLiBQbGVhc2UgbWF0Y2ggYWdhaW5zdCBhIHBhdGggaW5zdGVhZCBhbmQgYWNjZXNzIHF1ZXJ5IHBhcmFtZXRlcnMgaW4gdGhlIHJlc3BvbnNlIHJlc29sdmVyIGZ1bmN0aW9uIHVzaW5nIFwicmVxLnVybC5zZWFyY2hQYXJhbXNcIi5gXG4gICAgKTtcbiAgfVxuICBwYXJzZShyZXF1ZXN0LCByZXNvbHV0aW9uQ29udGV4dCkge1xuICAgIHJldHVybiBtYXRjaFJlcXVlc3RVcmwoXG4gICAgICByZXF1ZXN0LnVybCxcbiAgICAgIHRoaXMuaW5mby5wYXRoLFxuICAgICAgcmVzb2x1dGlvbkNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc29sdXRpb25Db250ZXh0LmJhc2VVcmxcbiAgICApO1xuICB9XG4gIGdldFB1YmxpY1JlcXVlc3QocmVxdWVzdCwgcGFyc2VkUmVzdWx0KSB7XG4gICAgcmV0dXJuIG5ldyBSZXN0UmVxdWVzdChyZXF1ZXN0LCBwYXJzZWRSZXN1bHQucGFyYW1zIHx8IHt9KTtcbiAgfVxuICBwcmVkaWNhdGUocmVxdWVzdCwgcGFyc2VkUmVzdWx0KSB7XG4gICAgY29uc3QgbWF0Y2hlc01ldGhvZCA9IHRoaXMuaW5mby5tZXRob2QgaW5zdGFuY2VvZiBSZWdFeHAgPyB0aGlzLmluZm8ubWV0aG9kLnRlc3QocmVxdWVzdC5tZXRob2QpIDogaXNTdHJpbmdFcXVhbCh0aGlzLmluZm8ubWV0aG9kLCByZXF1ZXN0Lm1ldGhvZCk7XG4gICAgcmV0dXJuIG1hdGNoZXNNZXRob2QgJiYgcGFyc2VkUmVzdWx0Lm1hdGNoZXM7XG4gIH1cbiAgbG9nKHJlcXVlc3QsIHJlc3BvbnNlMikge1xuICAgIGNvbnN0IHB1YmxpY1VybCA9IGdldFB1YmxpY1VybEZyb21SZXF1ZXN0KHJlcXVlc3QpO1xuICAgIGNvbnN0IGxvZ2dlZFJlcXVlc3QgPSBwcmVwYXJlUmVxdWVzdChyZXF1ZXN0KTtcbiAgICBjb25zdCBsb2dnZWRSZXNwb25zZSA9IHByZXBhcmVSZXNwb25zZShyZXNwb25zZTIpO1xuICAgIGNvbnN0IHN0YXR1c0NvbG9yID0gZ2V0U3RhdHVzQ29kZUNvbG9yKHJlc3BvbnNlMi5zdGF0dXMpO1xuICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXG4gICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFwiJXMgJXMgJXMgKCVjJXMlYylcIiksXG4gICAgICBnZXRUaW1lc3RhbXAoKSxcbiAgICAgIHJlcXVlc3QubWV0aG9kLFxuICAgICAgcHVibGljVXJsLFxuICAgICAgYGNvbG9yOiR7c3RhdHVzQ29sb3J9YCxcbiAgICAgIGAke3Jlc3BvbnNlMi5zdGF0dXN9ICR7cmVzcG9uc2UyLnN0YXR1c1RleHR9YCxcbiAgICAgIFwiY29sb3I6aW5oZXJpdFwiXG4gICAgKTtcbiAgICBjb25zb2xlLmxvZyhcIlJlcXVlc3RcIiwgbG9nZ2VkUmVxdWVzdCk7XG4gICAgY29uc29sZS5sb2coXCJIYW5kbGVyOlwiLCB0aGlzKTtcbiAgICBjb25zb2xlLmxvZyhcIlJlc3BvbnNlXCIsIGxvZ2dlZFJlc3BvbnNlKTtcbiAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb250ZXh0L2ZpZWxkLnRzXG5pbXBvcnQgeyBpbnZhcmlhbnQgYXMgaW52YXJpYW50MiB9IGZyb20gXCJvdXR2YXJpYW50XCI7XG52YXIgZmllbGQgPSAoZmllbGROYW1lLCBmaWVsZFZhbHVlKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgdmFsaWRhdGVGaWVsZE5hbWUoZmllbGROYW1lKTtcbiAgICBjb25zdCBwcmV2Qm9keSA9IGpzb25QYXJzZShyZXMuYm9keSkgfHwge307XG4gICAgY29uc3QgbmV4dEJvZHkgPSBtZXJnZVJpZ2h0KHByZXZCb2R5LCB7IFtmaWVsZE5hbWVdOiBmaWVsZFZhbHVlIH0pO1xuICAgIHJldHVybiBqc29uKG5leHRCb2R5KShyZXMpO1xuICB9O1xufTtcbmZ1bmN0aW9uIHZhbGlkYXRlRmllbGROYW1lKGZpZWxkTmFtZSkge1xuICBpbnZhcmlhbnQyKFxuICAgIGZpZWxkTmFtZS50cmltKCkgIT09IFwiXCIsXG4gICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgIFwiRmFpbGVkIHRvIHNldCBhIGN1c3RvbSBmaWVsZCBvbiBhIEdyYXBoUUwgcmVzcG9uc2U6IGZpZWxkIG5hbWUgY2Fubm90IGJlIGVtcHR5LlwiXG4gICAgKVxuICApO1xuICBpbnZhcmlhbnQyKFxuICAgIGZpZWxkTmFtZSAhPT0gXCJkYXRhXCIsXG4gICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICdGYWlsZWQgdG8gc2V0IGEgY3VzdG9tIFwiJXNcIiBmaWVsZCBvbiBhIG1vY2tlZCBHcmFwaFFMIHJlc3BvbnNlOiBmb3JiaWRkZW4gZmllbGQgbmFtZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgXCJjdHguZGF0YSgpXCIgaW5zdGVhZD8nLFxuICAgICAgZmllbGROYW1lXG4gICAgKVxuICApO1xuICBpbnZhcmlhbnQyKFxuICAgIGZpZWxkTmFtZSAhPT0gXCJlcnJvcnNcIixcbiAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgJ0ZhaWxlZCB0byBzZXQgYSBjdXN0b20gXCIlc1wiIGZpZWxkIG9uIGEgbW9ja2VkIEdyYXBoUUwgcmVzcG9uc2U6IGZvcmJpZGRlbiBmaWVsZCBuYW1lLiBEaWQgeW91IG1lYW4gdG8gY2FsbCBcImN0eC5lcnJvcnMoKVwiIGluc3RlYWQ/JyxcbiAgICAgIGZpZWxkTmFtZVxuICAgIClcbiAgKTtcbiAgaW52YXJpYW50MihcbiAgICBmaWVsZE5hbWUgIT09IFwiZXh0ZW5zaW9uc1wiLFxuICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAnRmFpbGVkIHRvIHNldCBhIGN1c3RvbSBcIiVzXCIgZmllbGQgb24gYSBtb2NrZWQgR3JhcGhRTCByZXNwb25zZTogZm9yYmlkZGVuIGZpZWxkIG5hbWUuIERpZCB5b3UgbWVhbiB0byBjYWxsIFwiY3R4LmV4dGVuc2lvbnMoKVwiIGluc3RlYWQ/JyxcbiAgICAgIGZpZWxkTmFtZVxuICAgIClcbiAgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL3RyeUNhdGNoLnRzXG5mdW5jdGlvbiB0cnlDYXRjaChmbiwgb25FeGNlcHRpb24pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBmbigpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yMikge1xuICAgIG9uRXhjZXB0aW9uID09IG51bGwgPyB2b2lkIDAgOiBvbkV4Y2VwdGlvbihlcnJvcjIpO1xuICB9XG59XG5cbi8vIHNyYy9oYW5kbGVycy9HcmFwaFFMSGFuZGxlci50c1xudmFyIGdyYXBocWxDb250ZXh0ID0ge1xuICAuLi5kZWZhdWx0Q29udGV4dCxcbiAgZGF0YSxcbiAgZXh0ZW5zaW9ucyxcbiAgZXJyb3JzLFxuICBjb29raWUsXG4gIGZpZWxkXG59O1xuZnVuY3Rpb24gaXNEb2N1bWVudE5vZGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBcImtpbmRcIiBpbiB2YWx1ZSAmJiBcImRlZmluaXRpb25zXCIgaW4gdmFsdWU7XG59XG52YXIgR3JhcGhRTFJlcXVlc3QgPSBjbGFzcyBleHRlbmRzIE1vY2tlZFJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvcihyZXF1ZXN0LCB2YXJpYWJsZXMsIG9wZXJhdGlvbk5hbWUpIHtcbiAgICBzdXBlcihyZXF1ZXN0LnVybCwge1xuICAgICAgLi4ucmVxdWVzdCxcbiAgICAgIGJvZHk6IHJlcXVlc3RbXCJfYm9keVwiXVxuICAgIH0pO1xuICAgIHRoaXMudmFyaWFibGVzID0gdmFyaWFibGVzO1xuICAgIHRoaXMub3BlcmF0aW9uTmFtZSA9IG9wZXJhdGlvbk5hbWU7XG4gIH1cbn07XG52YXIgR3JhcGhRTEhhbmRsZXIgPSBjbGFzcyBleHRlbmRzIFJlcXVlc3RIYW5kbGVyIHtcbiAgY29uc3RydWN0b3Iob3BlcmF0aW9uVHlwZSwgb3BlcmF0aW9uTmFtZSwgZW5kcG9pbnQsIHJlc29sdmVyKSB7XG4gICAgbGV0IHJlc29sdmVkT3BlcmF0aW9uTmFtZSA9IG9wZXJhdGlvbk5hbWU7XG4gICAgaWYgKGlzRG9jdW1lbnROb2RlKG9wZXJhdGlvbk5hbWUpKSB7XG4gICAgICBjb25zdCBwYXJzZWROb2RlID0gcGFyc2VEb2N1bWVudE5vZGUob3BlcmF0aW9uTmFtZSk7XG4gICAgICBpZiAocGFyc2VkTm9kZS5vcGVyYXRpb25UeXBlICE9PSBvcGVyYXRpb25UeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRmFpbGVkIHRvIGNyZWF0ZSBhIEdyYXBoUUwgaGFuZGxlcjogcHJvdmlkZWQgYSBEb2N1bWVudE5vZGUgd2l0aCBhIG1pc21hdGNoZWQgb3BlcmF0aW9uIHR5cGUgKGV4cGVjdGVkIFwiJHtvcGVyYXRpb25UeXBlfVwiLCBidXQgZ290IFwiJHtwYXJzZWROb2RlLm9wZXJhdGlvblR5cGV9XCIpLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghcGFyc2VkTm9kZS5vcGVyYXRpb25OYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRmFpbGVkIHRvIGNyZWF0ZSBhIEdyYXBoUUwgaGFuZGxlcjogcHJvdmlkZWQgYSBEb2N1bWVudE5vZGUgd2l0aCBubyBvcGVyYXRpb24gbmFtZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXNvbHZlZE9wZXJhdGlvbk5hbWUgPSBwYXJzZWROb2RlLm9wZXJhdGlvbk5hbWU7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlciA9IG9wZXJhdGlvblR5cGUgPT09IFwiYWxsXCIgPyBgJHtvcGVyYXRpb25UeXBlfSAob3JpZ2luOiAke2VuZHBvaW50LnRvU3RyaW5nKCl9KWAgOiBgJHtvcGVyYXRpb25UeXBlfSAke3Jlc29sdmVkT3BlcmF0aW9uTmFtZX0gKG9yaWdpbjogJHtlbmRwb2ludC50b1N0cmluZygpfSlgO1xuICAgIHN1cGVyKHtcbiAgICAgIGluZm86IHtcbiAgICAgICAgaGVhZGVyLFxuICAgICAgICBvcGVyYXRpb25UeXBlLFxuICAgICAgICBvcGVyYXRpb25OYW1lOiByZXNvbHZlZE9wZXJhdGlvbk5hbWVcbiAgICAgIH0sXG4gICAgICBjdHg6IGdyYXBocWxDb250ZXh0LFxuICAgICAgcmVzb2x2ZXJcbiAgICB9KTtcbiAgICB0aGlzLmVuZHBvaW50ID0gZW5kcG9pbnQ7XG4gIH1cbiAgcGFyc2UocmVxdWVzdCkge1xuICAgIHJldHVybiB0cnlDYXRjaChcbiAgICAgICgpID0+IHBhcnNlR3JhcGhRTFJlcXVlc3QocmVxdWVzdCksXG4gICAgICAoZXJyb3IyKSA9PiBjb25zb2xlLmVycm9yKGVycm9yMi5tZXNzYWdlKVxuICAgICk7XG4gIH1cbiAgZ2V0UHVibGljUmVxdWVzdChyZXF1ZXN0LCBwYXJzZWRSZXN1bHQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBuZXcgR3JhcGhRTFJlcXVlc3QoXG4gICAgICByZXF1ZXN0LFxuICAgICAgKF9hID0gcGFyc2VkUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRSZXN1bHQudmFyaWFibGVzKSAhPSBudWxsID8gX2EgOiB7fSxcbiAgICAgIChfYiA9IHBhcnNlZFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkUmVzdWx0Lm9wZXJhdGlvbk5hbWUpICE9IG51bGwgPyBfYiA6IFwiXCJcbiAgICApO1xuICB9XG4gIHByZWRpY2F0ZShyZXF1ZXN0LCBwYXJzZWRSZXN1bHQpIHtcbiAgICBpZiAoIXBhcnNlZFJlc3VsdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXBhcnNlZFJlc3VsdC5vcGVyYXRpb25OYW1lICYmIHRoaXMuaW5mby5vcGVyYXRpb25UeXBlICE9PSBcImFsbFwiKSB7XG4gICAgICBjb25zdCBwdWJsaWNVcmwgPSBnZXRQdWJsaWNVcmxGcm9tUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgIGRldlV0aWxzLndhcm4oYEZhaWxlZCB0byBpbnRlcmNlcHQgYSBHcmFwaFFMIHJlcXVlc3QgYXQgXCIke3JlcXVlc3QubWV0aG9kfSAke3B1YmxpY1VybH1cIjogYW5vbnltb3VzIEdyYXBoUUwgb3BlcmF0aW9ucyBhcmUgbm90IHN1cHBvcnRlZC5cblxuQ29uc2lkZXIgbmFtaW5nIHRoaXMgb3BlcmF0aW9uIG9yIHVzaW5nIFwiZ3JhcGhxbC5vcGVyYXRpb24oKVwiIHJlcXVlc3QgaGFuZGxlciB0byBpbnRlcmNlcHQgR3JhcGhRTCByZXF1ZXN0cyByZWdhcmRsZXNzIG9mIHRoZWlyIG9wZXJhdGlvbiBuYW1lL3R5cGUuIFJlYWQgbW9yZTogaHR0cHM6Ly9tc3dqcy5pby9kb2NzL2FwaS9ncmFwaHFsL29wZXJhdGlvbiAgICAgIGApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBoYXNNYXRjaGluZ1VybCA9IG1hdGNoUmVxdWVzdFVybChyZXF1ZXN0LnVybCwgdGhpcy5lbmRwb2ludCk7XG4gICAgY29uc3QgaGFzTWF0Y2hpbmdPcGVyYXRpb25UeXBlID0gdGhpcy5pbmZvLm9wZXJhdGlvblR5cGUgPT09IFwiYWxsXCIgfHwgcGFyc2VkUmVzdWx0Lm9wZXJhdGlvblR5cGUgPT09IHRoaXMuaW5mby5vcGVyYXRpb25UeXBlO1xuICAgIGNvbnN0IGhhc01hdGNoaW5nT3BlcmF0aW9uTmFtZSA9IHRoaXMuaW5mby5vcGVyYXRpb25OYW1lIGluc3RhbmNlb2YgUmVnRXhwID8gdGhpcy5pbmZvLm9wZXJhdGlvbk5hbWUudGVzdChwYXJzZWRSZXN1bHQub3BlcmF0aW9uTmFtZSB8fCBcIlwiKSA6IHBhcnNlZFJlc3VsdC5vcGVyYXRpb25OYW1lID09PSB0aGlzLmluZm8ub3BlcmF0aW9uTmFtZTtcbiAgICByZXR1cm4gaGFzTWF0Y2hpbmdVcmwubWF0Y2hlcyAmJiBoYXNNYXRjaGluZ09wZXJhdGlvblR5cGUgJiYgaGFzTWF0Y2hpbmdPcGVyYXRpb25OYW1lO1xuICB9XG4gIGxvZyhyZXF1ZXN0LCByZXNwb25zZTIsIHBhcnNlZFJlcXVlc3QpIHtcbiAgICBjb25zdCBsb2dnZWRSZXF1ZXN0ID0gcHJlcGFyZVJlcXVlc3QocmVxdWVzdCk7XG4gICAgY29uc3QgbG9nZ2VkUmVzcG9uc2UgPSBwcmVwYXJlUmVzcG9uc2UocmVzcG9uc2UyKTtcbiAgICBjb25zdCBzdGF0dXNDb2xvciA9IGdldFN0YXR1c0NvZGVDb2xvcihyZXNwb25zZTIuc3RhdHVzKTtcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IChwYXJzZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRSZXF1ZXN0Lm9wZXJhdGlvbk5hbWUpID8gYCR7cGFyc2VkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkUmVxdWVzdC5vcGVyYXRpb25UeXBlfSAke3BhcnNlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcnNlZFJlcXVlc3Qub3BlcmF0aW9uTmFtZX1gIDogYGFub255bW91cyAke3BhcnNlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcnNlZFJlcXVlc3Qub3BlcmF0aW9uVHlwZX1gO1xuICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXG4gICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFwiJXMgJXMgKCVjJXMlYylcIiksXG4gICAgICBnZXRUaW1lc3RhbXAoKSxcbiAgICAgIGAke3JlcXVlc3RJbmZvfWAsXG4gICAgICBgY29sb3I6JHtzdGF0dXNDb2xvcn1gLFxuICAgICAgYCR7cmVzcG9uc2UyLnN0YXR1c30gJHtyZXNwb25zZTIuc3RhdHVzVGV4dH1gLFxuICAgICAgXCJjb2xvcjppbmhlcml0XCJcbiAgICApO1xuICAgIGNvbnNvbGUubG9nKFwiUmVxdWVzdDpcIiwgbG9nZ2VkUmVxdWVzdCk7XG4gICAgY29uc29sZS5sb2coXCJIYW5kbGVyOlwiLCB0aGlzKTtcbiAgICBjb25zb2xlLmxvZyhcIlJlc3BvbnNlOlwiLCBsb2dnZWRSZXNwb25zZSk7XG4gICAgY29uc29sZS5ncm91cEVuZCgpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9vblVuaGFuZGxlZFJlcXVlc3QudHNcbnZhciBNQVhfTUFUQ0hfU0NPUkUgPSAzO1xudmFyIE1BWF9TVUdHRVNUSU9OX0NPVU5UID0gNDtcbnZhciBUWVBFX01BVENIX0RFTFRBID0gMC41O1xuZnVuY3Rpb24gZ3JvdXBIYW5kbGVyc0J5VHlwZShoYW5kbGVycykge1xuICByZXR1cm4gaGFuZGxlcnMucmVkdWNlKFxuICAgIChncm91cHMsIGhhbmRsZXIpID0+IHtcbiAgICAgIGlmIChoYW5kbGVyIGluc3RhbmNlb2YgUmVzdEhhbmRsZXIpIHtcbiAgICAgICAgZ3JvdXBzLnJlc3QucHVzaChoYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYW5kbGVyIGluc3RhbmNlb2YgR3JhcGhRTEhhbmRsZXIpIHtcbiAgICAgICAgZ3JvdXBzLmdyYXBocWwucHVzaChoYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cHM7XG4gICAgfSxcbiAgICB7XG4gICAgICByZXN0OiBbXSxcbiAgICAgIGdyYXBocWw6IFtdXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gZ2V0UmVzdEhhbmRsZXJTY29yZSgpIHtcbiAgcmV0dXJuIChyZXF1ZXN0LCBoYW5kbGVyKSA9PiB7XG4gICAgY29uc3QgeyBwYXRoLCBtZXRob2QgfSA9IGhhbmRsZXIuaW5mbztcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBtZXRob2QgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgY29uc3QgaGFzU2FtZU1ldGhvZCA9IGlzU3RyaW5nRXF1YWwocmVxdWVzdC5tZXRob2QsIG1ldGhvZCk7XG4gICAgY29uc3QgbWV0aG9kU2NvcmVEZWx0YSA9IGhhc1NhbWVNZXRob2QgPyBUWVBFX01BVENIX0RFTFRBIDogMDtcbiAgICBjb25zdCByZXF1ZXN0UHVibGljVXJsID0gZ2V0UHVibGljVXJsRnJvbVJlcXVlc3QocmVxdWVzdCk7XG4gICAgY29uc3Qgc2NvcmUgPSBnZXRTdHJpbmdNYXRjaFNjb3JlKHJlcXVlc3RQdWJsaWNVcmwsIHBhdGgpO1xuICAgIHJldHVybiBzY29yZSAtIG1ldGhvZFNjb3JlRGVsdGE7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRHcmFwaFFMSGFuZGxlclNjb3JlKHBhcnNlZFF1ZXJ5KSB7XG4gIHJldHVybiAoXywgaGFuZGxlcikgPT4ge1xuICAgIGlmICh0eXBlb2YgcGFyc2VkUXVlcnkub3BlcmF0aW9uTmFtZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICBjb25zdCB7IG9wZXJhdGlvblR5cGUsIG9wZXJhdGlvbk5hbWUgfSA9IGhhbmRsZXIuaW5mbztcbiAgICBpZiAodHlwZW9mIG9wZXJhdGlvbk5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgY29uc3QgaGFzU2FtZU9wZXJhdGlvblR5cGUgPSBwYXJzZWRRdWVyeS5vcGVyYXRpb25UeXBlID09PSBvcGVyYXRpb25UeXBlO1xuICAgIGNvbnN0IG9wZXJhdGlvblR5cGVTY29yZURlbHRhID0gaGFzU2FtZU9wZXJhdGlvblR5cGUgPyBUWVBFX01BVENIX0RFTFRBIDogMDtcbiAgICBjb25zdCBzY29yZSA9IGdldFN0cmluZ01hdGNoU2NvcmUocGFyc2VkUXVlcnkub3BlcmF0aW9uTmFtZSwgb3BlcmF0aW9uTmFtZSk7XG4gICAgcmV0dXJuIHNjb3JlIC0gb3BlcmF0aW9uVHlwZVNjb3JlRGVsdGE7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRTdWdnZXN0ZWRIYW5kbGVyKHJlcXVlc3QsIGhhbmRsZXJzLCBnZXRTY29yZSkge1xuICBjb25zdCBzdWdnZXN0ZWRIYW5kbGVycyA9IGhhbmRsZXJzLnJlZHVjZSgoc3VnZ2VzdGlvbnMsIGhhbmRsZXIpID0+IHtcbiAgICBjb25zdCBzY29yZSA9IGdldFNjb3JlKHJlcXVlc3QsIGhhbmRsZXIpO1xuICAgIHJldHVybiBzdWdnZXN0aW9ucy5jb25jYXQoW1tzY29yZSwgaGFuZGxlcl1dKTtcbiAgfSwgW10pLnNvcnQoKFtsZWZ0U2NvcmVdLCBbcmlnaHRTY29yZV0pID0+IGxlZnRTY29yZSAtIHJpZ2h0U2NvcmUpLmZpbHRlcigoW3Njb3JlXSkgPT4gc2NvcmUgPD0gTUFYX01BVENIX1NDT1JFKS5zbGljZSgwLCBNQVhfU1VHR0VTVElPTl9DT1VOVCkubWFwKChbLCBoYW5kbGVyXSkgPT4gaGFuZGxlcik7XG4gIHJldHVybiBzdWdnZXN0ZWRIYW5kbGVycztcbn1cbmZ1bmN0aW9uIGdldFN1Z2dlc3RlZEhhbmRsZXJzTWVzc2FnZShoYW5kbGVycykge1xuICBpZiAoaGFuZGxlcnMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBgRGlkIHlvdSBtZWFuIHRvIHJlcXVlc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVzb3VyY2VzIGluc3RlYWQ/XG5cbiR7aGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBgICBcXHUyMDIyICR7aGFuZGxlci5pbmZvLmhlYWRlcn1gKS5qb2luKFwiXFxuXCIpfWA7XG4gIH1cbiAgcmV0dXJuIGBEaWQgeW91IG1lYW4gdG8gcmVxdWVzdCBcIiR7aGFuZGxlcnNbMF0uaW5mby5oZWFkZXJ9XCIgaW5zdGVhZD9gO1xufVxuZnVuY3Rpb24gb25VbmhhbmRsZWRSZXF1ZXN0KHJlcXVlc3QsIGhhbmRsZXJzLCBzdHJhdGVneSA9IFwid2FyblwiKSB7XG4gIGNvbnN0IHBhcnNlZEdyYXBoUUxRdWVyeSA9IHRyeUNhdGNoKCgpID0+IHBhcnNlR3JhcGhRTFJlcXVlc3QocmVxdWVzdCkpO1xuICBmdW5jdGlvbiBnZW5lcmF0ZUhhbmRsZXJTdWdnZXN0aW9uKCkge1xuICAgIGNvbnN0IGhhbmRsZXJHcm91cHMgPSBncm91cEhhbmRsZXJzQnlUeXBlKGhhbmRsZXJzKTtcbiAgICBjb25zdCByZWxldmFudEhhbmRsZXJzID0gcGFyc2VkR3JhcGhRTFF1ZXJ5ID8gaGFuZGxlckdyb3Vwcy5ncmFwaHFsIDogaGFuZGxlckdyb3Vwcy5yZXN0O1xuICAgIGNvbnN0IHN1Z2dlc3RlZEhhbmRsZXJzID0gZ2V0U3VnZ2VzdGVkSGFuZGxlcihcbiAgICAgIHJlcXVlc3QsXG4gICAgICByZWxldmFudEhhbmRsZXJzLFxuICAgICAgcGFyc2VkR3JhcGhRTFF1ZXJ5ID8gZ2V0R3JhcGhRTEhhbmRsZXJTY29yZShwYXJzZWRHcmFwaFFMUXVlcnkpIDogZ2V0UmVzdEhhbmRsZXJTY29yZSgpXG4gICAgKTtcbiAgICByZXR1cm4gc3VnZ2VzdGVkSGFuZGxlcnMubGVuZ3RoID4gMCA/IGdldFN1Z2dlc3RlZEhhbmRsZXJzTWVzc2FnZShzdWdnZXN0ZWRIYW5kbGVycykgOiBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVW5oYW5kbGVkUmVxdWVzdE1lc3NhZ2UoKSB7XG4gICAgY29uc3QgcHVibGljVXJsID0gZ2V0UHVibGljVXJsRnJvbVJlcXVlc3QocmVxdWVzdCk7XG4gICAgY29uc3QgcmVxdWVzdEhlYWRlciA9IHBhcnNlZEdyYXBoUUxRdWVyeSA/IGAke3BhcnNlZEdyYXBoUUxRdWVyeS5vcGVyYXRpb25UeXBlfSAke3BhcnNlZEdyYXBoUUxRdWVyeS5vcGVyYXRpb25OYW1lfSAoJHtyZXF1ZXN0Lm1ldGhvZH0gJHtwdWJsaWNVcmx9KWAgOiBgJHtyZXF1ZXN0Lm1ldGhvZH0gJHtwdWJsaWNVcmx9YDtcbiAgICBjb25zdCBoYW5kbGVyU3VnZ2VzdGlvbiA9IGdlbmVyYXRlSGFuZGxlclN1Z2dlc3Rpb24oKTtcbiAgICBjb25zdCBtZXNzYWdlVGVtcGxhdGUgPSBbXG4gICAgICBgY2FwdHVyZWQgYSByZXF1ZXN0IHdpdGhvdXQgYSBtYXRjaGluZyByZXF1ZXN0IGhhbmRsZXI6YCxcbiAgICAgIGAgIFxcdTIwMjIgJHtyZXF1ZXN0SGVhZGVyfWAsXG4gICAgICBoYW5kbGVyU3VnZ2VzdGlvbixcbiAgICAgIGBJZiB5b3Ugc3RpbGwgd2lzaCB0byBpbnRlcmNlcHQgdGhpcyB1bmhhbmRsZWQgcmVxdWVzdCwgcGxlYXNlIGNyZWF0ZSBhIHJlcXVlc3QgaGFuZGxlciBmb3IgaXQuXG5SZWFkIG1vcmU6IGh0dHBzOi8vbXN3anMuaW8vZG9jcy9nZXR0aW5nLXN0YXJ0ZWQvbW9ja3NgXG4gICAgXS5maWx0ZXIoQm9vbGVhbik7XG4gICAgcmV0dXJuIG1lc3NhZ2VUZW1wbGF0ZS5qb2luKFwiXFxuXFxuXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5U3RyYXRlZ3koc3RyYXRlZ3kyKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGdlbmVyYXRlVW5oYW5kbGVkUmVxdWVzdE1lc3NhZ2UoKTtcbiAgICBzd2l0Y2ggKHN0cmF0ZWd5Mikge1xuICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgZGV2VXRpbHMuZXJyb3IoXCJFcnJvcjogJXNcIiwgbWVzc2FnZSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAgICAgJ0Nhbm5vdCBieXBhc3MgYSByZXF1ZXN0IHdoZW4gdXNpbmcgdGhlIFwiZXJyb3JcIiBzdHJhdGVneSBmb3IgdGhlIFwib25VbmhhbmRsZWRSZXF1ZXN0XCIgb3B0aW9uLidcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjYXNlIFwid2FyblwiOiB7XG4gICAgICAgIGRldlV0aWxzLndhcm4oXCJXYXJuaW5nOiAlc1wiLCBtZXNzYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYnlwYXNzXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgICAnRmFpbGVkIHRvIHJlYWN0IHRvIGFuIHVuaGFuZGxlZCByZXF1ZXN0OiB1bmtub3duIHN0cmF0ZWd5IFwiJXNcIi4gUGxlYXNlIHByb3ZpZGUgb25lIG9mIHRoZSBzdXBwb3J0ZWQgc3RyYXRlZ2llcyAoXCJieXBhc3NcIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIikgb3IgYSBjdXN0b20gY2FsbGJhY2sgZnVuY3Rpb24gYXMgdGhlIHZhbHVlIG9mIHRoZSBcIm9uVW5oYW5kbGVkUmVxdWVzdFwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgc3RyYXRlZ3kyXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHN0cmF0ZWd5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBzdHJhdGVneShyZXF1ZXN0LCB7XG4gICAgICB3YXJuaW5nOiBhcHBseVN0cmF0ZWd5LmJpbmQobnVsbCwgXCJ3YXJuXCIpLFxuICAgICAgZXJyb3I6IGFwcGx5U3RyYXRlZ3kuYmluZChudWxsLCBcImVycm9yXCIpXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFwcGx5U3RyYXRlZ3koc3RyYXRlZ3kpO1xufVxuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9yZWFkUmVzcG9uc2VDb29raWVzLnRzXG5pbXBvcnQgeyBzdG9yZSBhcyBzdG9yZTIgfSBmcm9tIFwiQG1zd2pzL2Nvb2tpZXNcIjtcbmZ1bmN0aW9uIHJlYWRSZXNwb25zZUNvb2tpZXMocmVxdWVzdCwgcmVzcG9uc2UyKSB7XG4gIHN0b3JlMi5hZGQoeyAuLi5yZXF1ZXN0LCB1cmw6IHJlcXVlc3QudXJsLnRvU3RyaW5nKCkgfSwgcmVzcG9uc2UyKTtcbiAgc3RvcmUyLnBlcnNpc3QoKTtcbn1cblxuLy8gc3JjL3V0aWxzL2hhbmRsZVJlcXVlc3QudHNcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3QocmVxdWVzdCwgaGFuZGxlcnMsIG9wdGlvbnMsIGVtaXR0ZXIsIGhhbmRsZVJlcXVlc3RPcHRpb25zKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0OnN0YXJ0XCIsIHJlcXVlc3QpO1xuICBpZiAocmVxdWVzdC5oZWFkZXJzLmdldChcIngtbXN3LWJ5cGFzc1wiKSA9PT0gXCJ0cnVlXCIpIHtcbiAgICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0OmVuZFwiLCByZXF1ZXN0KTtcbiAgICAoX2EgPSBoYW5kbGVSZXF1ZXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUmVxdWVzdE9wdGlvbnMub25QYXNzdGhyb3VnaFJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChoYW5kbGVSZXF1ZXN0T3B0aW9ucywgcmVxdWVzdCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IFtsb29rdXBFcnJvciwgbG9va3VwUmVzdWx0XSA9IGF3YWl0IHVudGlsKCgpID0+IHtcbiAgICByZXR1cm4gZ2V0UmVzcG9uc2UoXG4gICAgICByZXF1ZXN0LFxuICAgICAgaGFuZGxlcnMsXG4gICAgICBoYW5kbGVSZXF1ZXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUmVxdWVzdE9wdGlvbnMucmVzb2x1dGlvbkNvbnRleHRcbiAgICApO1xuICB9KTtcbiAgaWYgKGxvb2t1cEVycm9yKSB7XG4gICAgZW1pdHRlci5lbWl0KFwidW5oYW5kbGVkRXhjZXB0aW9uXCIsIGxvb2t1cEVycm9yLCByZXF1ZXN0KTtcbiAgICB0aHJvdyBsb29rdXBFcnJvcjtcbiAgfVxuICBjb25zdCB7IGhhbmRsZXIsIHJlc3BvbnNlOiByZXNwb25zZTIgfSA9IGxvb2t1cFJlc3VsdDtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgb25VbmhhbmRsZWRSZXF1ZXN0KHJlcXVlc3QsIGhhbmRsZXJzLCBvcHRpb25zLm9uVW5oYW5kbGVkUmVxdWVzdCk7XG4gICAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDp1bmhhbmRsZWRcIiwgcmVxdWVzdCk7XG4gICAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDplbmRcIiwgcmVxdWVzdCk7XG4gICAgKF9iID0gaGFuZGxlUmVxdWVzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVJlcXVlc3RPcHRpb25zLm9uUGFzc3Rocm91Z2hSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoaGFuZGxlUmVxdWVzdE9wdGlvbnMsIHJlcXVlc3QpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXJlc3BvbnNlMikge1xuICAgIGRldlV0aWxzLndhcm4oXG4gICAgICBgRXhwZWN0ZWQgcmVzcG9uc2UgcmVzb2x2ZXIgdG8gcmV0dXJuIGEgbW9ja2VkIHJlc3BvbnNlIE9iamVjdCwgYnV0IGdvdCAlcy4gVGhlIG9yaWdpbmFsIHJlc3BvbnNlIGlzIGdvaW5nIHRvIGJlIHVzZWQgaW5zdGVhZC5cblxuICBcXHUyMDIyICVzXG4gICAgJXNgLFxuICAgICAgcmVzcG9uc2UyLFxuICAgICAgaGFuZGxlci5pbmZvLmhlYWRlcixcbiAgICAgIGhhbmRsZXIuaW5mby5jYWxsRnJhbWVcbiAgICApO1xuICAgIGVtaXR0ZXIuZW1pdChcInJlcXVlc3Q6ZW5kXCIsIHJlcXVlc3QpO1xuICAgIChfYyA9IGhhbmRsZVJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVSZXF1ZXN0T3B0aW9ucy5vblBhc3N0aHJvdWdoUmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKGhhbmRsZVJlcXVlc3RPcHRpb25zLCByZXF1ZXN0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHJlc3BvbnNlMi5wYXNzdGhyb3VnaCkge1xuICAgIGVtaXR0ZXIuZW1pdChcInJlcXVlc3Q6ZW5kXCIsIHJlcXVlc3QpO1xuICAgIChfZCA9IGhhbmRsZVJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVSZXF1ZXN0T3B0aW9ucy5vblBhc3N0aHJvdWdoUmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZC5jYWxsKGhhbmRsZVJlcXVlc3RPcHRpb25zLCByZXF1ZXN0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVhZFJlc3BvbnNlQ29va2llcyhyZXF1ZXN0LCByZXNwb25zZTIpO1xuICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0Om1hdGNoXCIsIHJlcXVlc3QpO1xuICBjb25zdCByZXF1aXJlZExvb2t1cFJlc3VsdCA9IGxvb2t1cFJlc3VsdDtcbiAgY29uc3QgdHJhbnNmb3JtZWRSZXNwb25zZSA9ICgoX2UgPSBoYW5kbGVSZXF1ZXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUmVxdWVzdE9wdGlvbnMudHJhbnNmb3JtUmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZS5jYWxsKGhhbmRsZVJlcXVlc3RPcHRpb25zLCByZXNwb25zZTIpKSB8fCByZXNwb25zZTI7XG4gIChfZiA9IGhhbmRsZVJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVSZXF1ZXN0T3B0aW9ucy5vbk1vY2tlZFJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2YuY2FsbChcbiAgICBoYW5kbGVSZXF1ZXN0T3B0aW9ucyxcbiAgICB0cmFuc2Zvcm1lZFJlc3BvbnNlLFxuICAgIHJlcXVpcmVkTG9va3VwUmVzdWx0XG4gICk7XG4gIGVtaXR0ZXIuZW1pdChcInJlcXVlc3Q6ZW5kXCIsIHJlcXVlc3QpO1xuICByZXR1cm4gdHJhbnNmb3JtZWRSZXNwb25zZTtcbn1cblxuLy8gc3JjL25vZGUvU2V0dXBTZXJ2ZXJBcGkudHNcbnZhciB7IGJvbGQgfSA9IGNoYWxrO1xudmFyIERFRkFVTFRfTElTVEVOX09QVElPTlMgPSB7XG4gIG9uVW5oYW5kbGVkUmVxdWVzdDogXCJ3YXJuXCJcbn07XG52YXIgU2V0dXBTZXJ2ZXJBcGkgPSBjbGFzcyBleHRlbmRzIFNldHVwQXBpIHtcbiAgY29uc3RydWN0b3IoaW50ZXJjZXB0b3JzLCAuLi5oYW5kbGVycykge1xuICAgIHN1cGVyKC4uLmhhbmRsZXJzKTtcbiAgICB0aGlzLmludGVyY2VwdG9yID0gbmV3IEJhdGNoSW50ZXJjZXB0b3Ioe1xuICAgICAgbmFtZTogXCJzZXR1cC1zZXJ2ZXJcIixcbiAgICAgIGludGVyY2VwdG9yczogaW50ZXJjZXB0b3JzLm1hcCgoSW50ZXJjZXB0b3IyKSA9PiBuZXcgSW50ZXJjZXB0b3IyKCkpXG4gICAgfSk7XG4gICAgdGhpcy5yZXNvbHZlZE9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuICBpbml0KCkge1xuICAgIHRoaXMuaW50ZXJjZXB0b3Iub24oXCJyZXF1ZXN0XCIsIGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICBjb25zdCBtb2NrZWRSZXF1ZXN0ID0gbmV3IE1vY2tlZFJlcXVlc3QocmVxdWVzdC51cmwsIHtcbiAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAgYm9keTogYXdhaXQgcmVxdWVzdC5hcnJheUJ1ZmZlcigpXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlMiA9IGF3YWl0IGhhbmRsZVJlcXVlc3QoXG4gICAgICAgIG1vY2tlZFJlcXVlc3QsXG4gICAgICAgIHRoaXMuY3VycmVudEhhbmRsZXJzLFxuICAgICAgICB0aGlzLnJlc29sdmVkT3B0aW9ucyxcbiAgICAgICAgdGhpcy5lbWl0dGVyLFxuICAgICAgICB7XG4gICAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2UocmVzcG9uc2UzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlMy5zdGF0dXMsXG4gICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlMy5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZTMuaGVhZGVycy5hbGwoKSxcbiAgICAgICAgICAgICAgYm9keTogcmVzcG9uc2UzLmJvZHksXG4gICAgICAgICAgICAgIGRlbGF5OiByZXNwb25zZTMuZGVsYXlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlMikge1xuICAgICAgICBpZiAocmVzcG9uc2UyLmRlbGF5KSB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgcmVzcG9uc2UyLmRlbGF5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0LnJlc3BvbmRXaXRoKHJlc3BvbnNlMik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSk7XG4gICAgdGhpcy5pbnRlcmNlcHRvci5vbihcInJlc3BvbnNlXCIsIChyZXF1ZXN0LCByZXNwb25zZTIpID0+IHtcbiAgICAgIGlmICghcmVxdWVzdC5pZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVzcG9uc2UyLmhlYWRlcnMuZ2V0KFwieC1wb3dlcmVkLWJ5XCIpID09PSBcIm1zd1wiKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KFwicmVzcG9uc2U6bW9ja2VkXCIsIHJlc3BvbnNlMiwgcmVxdWVzdC5pZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdChcInJlc3BvbnNlOmJ5cGFzc1wiLCByZXNwb25zZTIsIHJlcXVlc3QuaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGxpc3RlbihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnJlc29sdmVkT3B0aW9ucyA9IG1lcmdlUmlnaHQoXG4gICAgICBERUZBVUxUX0xJU1RFTl9PUFRJT05TLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgdGhpcy5pbnRlcmNlcHRvci5hcHBseSgpO1xuICAgIGludmFyaWFudDMoXG4gICAgICBbSW50ZXJjZXB0b3JSZWFkeVN0YXRlLkFQUExZSU5HLCBJbnRlcmNlcHRvclJlYWR5U3RhdGUuQVBQTElFRF0uaW5jbHVkZXMoXG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3IucmVhZHlTdGF0ZVxuICAgICAgKSxcbiAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICdGYWlsZWQgdG8gc3RhcnQgXCJzZXR1cFNlcnZlclwiOiB0aGUgaW50ZXJjZXB0b3IgZmFpbGVkIHRvIGFwcGx5LiBUaGlzIGlzIGxpa2VseSBhbiBpc3N1ZSB3aXRoIHRoZSBsaWJyYXJ5IGFuZCB5b3Ugc2hvdWxkIHJlcG9ydCBpdCBhdCBcIiVzXCIuJ1xuICAgICAgKSxcbiAgICAgIFwiaHR0cHM6Ly9naXRodWIuY29tL21zd2pzL21zdy9pc3N1ZXMvbmV3L2Nob29zZVwiXG4gICAgKTtcbiAgfVxuICBwcmludEhhbmRsZXJzKCkge1xuICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5saXN0SGFuZGxlcnMoKTtcbiAgICBoYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICBjb25zdCB7IGhlYWRlciwgY2FsbEZyYW1lIH0gPSBoYW5kbGVyLmluZm87XG4gICAgICBjb25zdCBwcmFnbWEgPSBoYW5kbGVyLmluZm8uaGFzT3duUHJvcGVydHkoXCJvcGVyYXRpb25UeXBlXCIpID8gXCJbZ3JhcGhxbF1cIiA6IFwiW3Jlc3RdXCI7XG4gICAgICBjb25zb2xlLmxvZyhgJHtib2xkKGAke3ByYWdtYX0gJHtoZWFkZXJ9YCl9XG4gIERlY2xhcmF0aW9uOiAke2NhbGxGcmFtZX1cbmApO1xuICAgIH0pO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLmludGVyY2VwdG9yLmRpc3Bvc2UoKTtcbiAgfVxufTtcblxuLy8gc3JjL25vZGUvc2V0dXBTZXJ2ZXIudHNcbmltcG9ydCB7IENsaWVudFJlcXVlc3RJbnRlcmNlcHRvciB9IGZyb20gXCJAbXN3anMvaW50ZXJjZXB0b3JzL2xpYi9pbnRlcmNlcHRvcnMvQ2xpZW50UmVxdWVzdC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgWE1MSHR0cFJlcXVlc3RJbnRlcmNlcHRvciB9IGZyb20gXCJAbXN3anMvaW50ZXJjZXB0b3JzL2xpYi9pbnRlcmNlcHRvcnMvWE1MSHR0cFJlcXVlc3QvaW5kZXguanNcIjtcbmltcG9ydCB7IEZldGNoSW50ZXJjZXB0b3IgfSBmcm9tIFwiQG1zd2pzL2ludGVyY2VwdG9ycy9saWIvaW50ZXJjZXB0b3JzL2ZldGNoL2luZGV4LmpzXCI7XG52YXIgc2V0dXBTZXJ2ZXIgPSAoLi4uaGFuZGxlcnMpID0+IHtcbiAgcmV0dXJuIG5ldyBTZXR1cFNlcnZlckFwaShcbiAgICBbQ2xpZW50UmVxdWVzdEludGVyY2VwdG9yLCBYTUxIdHRwUmVxdWVzdEludGVyY2VwdG9yLCBGZXRjaEludGVyY2VwdG9yXSxcbiAgICAuLi5oYW5kbGVyc1xuICApO1xufTtcbmV4cG9ydCB7XG4gIFNldHVwU2VydmVyQXBpLFxuICBzZXR1cFNlcnZlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/msw/lib/node/index.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/msw/lib/node/index.mjs":
/*!*************************************************!*\
  !*** ../../node_modules/msw/lib/node/index.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SetupServerApi: () => (/* binding */ SetupServerApi),\n/* harmony export */   setupServer: () => (/* binding */ setupServer)\n/* harmony export */ });\n/* harmony import */ var timers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! timers */ \"timers\");\n/* harmony import */ var chalk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chalk */ \"(rsc)/../../node_modules/chalk/source/index.js\");\n/* harmony import */ var outvariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! outvariant */ \"(rsc)/../../node_modules/outvariant/lib/index.mjs\");\n/* harmony import */ var _mswjs_interceptors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @mswjs/interceptors */ \"(rsc)/../../node_modules/@mswjs/interceptors/lib/index.js\");\n/* harmony import */ var strict_event_emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! strict-event-emitter */ \"(rsc)/../../node_modules/strict-event-emitter/lib/index.js\");\n/* harmony import */ var cookie__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cookie */ \"(rsc)/../../node_modules/cookie/index.js\");\n/* harmony import */ var _mswjs_cookies__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @mswjs/cookies */ \"(rsc)/../../node_modules/@mswjs/cookies/lib/index.js\");\n/* harmony import */ var _mswjs_interceptors_lib_utils_bufferUtils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @mswjs/interceptors/lib/utils/bufferUtils.js */ \"(rsc)/../../node_modules/@mswjs/interceptors/lib/utils/bufferUtils.js\");\n/* harmony import */ var headers_polyfill__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! headers-polyfill */ \"(rsc)/../../node_modules/headers-polyfill/lib/index.mjs\");\n/* harmony import */ var _open_draft_until__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @open-draft/until */ \"(rsc)/../../node_modules/@open-draft/until/lib/index.js\");\n/* harmony import */ var js_levenshtein__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! js-levenshtein */ \"(rsc)/../../node_modules/js-levenshtein/index.js\");\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! graphql */ \"(rsc)/../../node_modules/graphql/language/parser.mjs\");\n/* harmony import */ var is_node_process__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! is-node-process */ \"(rsc)/../../node_modules/is-node-process/lib/index.mjs\");\n/* harmony import */ var path_to_regexp__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! path-to-regexp */ \"(rsc)/../../node_modules/msw/node_modules/path-to-regexp/dist.es2015/index.js\");\n/* harmony import */ var _mswjs_interceptors_lib_utils_getCleanUrl_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @mswjs/interceptors/lib/utils/getCleanUrl.js */ \"(rsc)/../../node_modules/@mswjs/interceptors/lib/utils/getCleanUrl.js\");\n/* harmony import */ var _mswjs_interceptors_lib_interceptors_ClientRequest_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @mswjs/interceptors/lib/interceptors/ClientRequest/index.js */ \"(rsc)/../../node_modules/@mswjs/interceptors/lib/interceptors/ClientRequest/index.js\");\n/* harmony import */ var _mswjs_interceptors_lib_interceptors_XMLHttpRequest_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @mswjs/interceptors/lib/interceptors/XMLHttpRequest/index.js */ \"(rsc)/../../node_modules/@mswjs/interceptors/lib/interceptors/XMLHttpRequest/index.js\");\n/* harmony import */ var _mswjs_interceptors_lib_interceptors_fetch_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @mswjs/interceptors/lib/interceptors/fetch/index.js */ \"(rsc)/../../node_modules/@mswjs/interceptors/lib/interceptors/fetch/index.js\");\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\")\n    return require.apply(this, arguments);\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n});\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// config/polyfills-node.ts\n\nvar setTimeout = timers__WEBPACK_IMPORTED_MODULE_0__.setTimeout;\n\n// src/node/SetupServerApi.ts\n\n\n\n\n// src/SetupApi.ts\n\n\n\n// src/utils/internal/devUtils.ts\n\nvar LIBRARY_PREFIX = \"[MSW]\";\nfunction formatMessage(message, ...positionals) {\n  const interpolatedMessage = (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.format)(message, ...positionals);\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`;\n}\nfunction warn(message, ...positionals) {\n  console.warn(formatMessage(message, ...positionals));\n}\nfunction error(message, ...positionals) {\n  console.error(formatMessage(message, ...positionals));\n}\nvar devUtils = {\n  formatMessage,\n  warn,\n  error\n};\n\n// src/utils/internal/pipeEvents.ts\nfunction pipeEvents(source, destination) {\n  const rawEmit = source.emit;\n  if (rawEmit._isPiped) {\n    return;\n  }\n  source.emit = function(event, ...data2) {\n    destination.emit(event, ...data2);\n    return rawEmit.call(this, event, ...data2);\n  };\n  source.emit._isPiped = true;\n}\n\n// src/utils/internal/toReadonlyArray.ts\nfunction toReadonlyArray(source) {\n  const clone = [...source];\n  Object.freeze(clone);\n  return clone;\n}\n\n// src/SetupApi.ts\nvar SetupApi = class {\n  constructor(...initialHandlers) {\n    this.validateHandlers(...initialHandlers);\n    this.initialHandlers = toReadonlyArray(initialHandlers);\n    this.currentHandlers = [...initialHandlers];\n    this.emitter = new strict_event_emitter__WEBPACK_IMPORTED_MODULE_4__.Emitter();\n    this.publicEmitter = new strict_event_emitter__WEBPACK_IMPORTED_MODULE_4__.Emitter();\n    pipeEvents(this.emitter, this.publicEmitter);\n    this.events = this.createLifeCycleEvents();\n  }\n  validateHandlers(...handlers) {\n    for (const handler of handlers) {\n      (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(\n        !Array.isArray(handler),\n        devUtils.formatMessage(\n          'Failed to construct \"%s\" given an Array of request handlers. Make sure you spread the request handlers when calling the respective setup function.'\n        ),\n        this.constructor.name\n      );\n    }\n  }\n  dispose() {\n    this.emitter.removeAllListeners();\n    this.publicEmitter.removeAllListeners();\n  }\n  use(...runtimeHandlers) {\n    this.currentHandlers.unshift(...runtimeHandlers);\n  }\n  restoreHandlers() {\n    this.currentHandlers.forEach((handler) => {\n      handler.markAsSkipped(false);\n    });\n  }\n  resetHandlers(...nextHandlers) {\n    this.currentHandlers = nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers];\n  }\n  listHandlers() {\n    return toReadonlyArray(this.currentHandlers);\n  }\n  createLifeCycleEvents() {\n    return {\n      on: (...args) => {\n        return this.publicEmitter.on(...args);\n      },\n      removeListener: (...args) => {\n        return this.publicEmitter.removeListener(...args);\n      },\n      removeAllListeners: (...args) => {\n        return this.publicEmitter.removeAllListeners(...args);\n      }\n    };\n  }\n};\n\n// src/utils/internal/isObject.ts\nfunction isObject(value) {\n  return value != null && typeof value === \"object\" && !Array.isArray(value);\n}\n\n// src/utils/internal/mergeRight.ts\nfunction mergeRight(left, right) {\n  return Object.entries(right).reduce((result, [key, rightValue]) => {\n    const leftValue = result[key];\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue);\n      return result;\n    }\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue);\n      return result;\n    }\n    result[key] = rightValue;\n    return result;\n  }, Object.assign({}, left));\n}\n\n// src/utils/request/MockedRequest.ts\n\n\n\n\n\n\n// src/utils/request/getRequestCookies.ts\n\nfunction getAllCookies() {\n  return cookie__WEBPACK_IMPORTED_MODULE_5__.parse(document.cookie);\n}\nfunction getRequestCookies(request) {\n  if (typeof document === \"undefined\" || typeof location === \"undefined\") {\n    return {};\n  }\n  switch (request.credentials) {\n    case \"same-origin\": {\n      return location.origin === request.url.origin ? getAllCookies() : {};\n    }\n    case \"include\": {\n      return getAllCookies();\n    }\n    default: {\n      return {};\n    }\n  }\n}\n\n// src/utils/internal/jsonParse.ts\nfunction jsonParse(value) {\n  try {\n    return JSON.parse(value);\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/internal/parseMultipartData.ts\n\nfunction parseContentHeaders(headersString) {\n  var _a, _b;\n  const headers = (0,headers_polyfill__WEBPACK_IMPORTED_MODULE_8__.stringToHeaders)(headersString);\n  const contentType = headers.get(\"content-type\") || \"text/plain\";\n  const disposition = headers.get(\"content-disposition\");\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.');\n  }\n  const directives = disposition.split(\";\").reduce((acc, chunk) => {\n    const [name2, ...rest] = chunk.trim().split(\"=\");\n    acc[name2] = rest.join(\"=\");\n    return acc;\n  }, {});\n  const name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);\n  const filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);\n  return {\n    name,\n    filename,\n    contentType\n  };\n}\nfunction parseMultipartData(data2, headers) {\n  const contentType = headers == null ? void 0 : headers.get(\"content-type\");\n  if (!contentType) {\n    return void 0;\n  }\n  const [, ...directives] = contentType.split(/; */);\n  const boundary = directives.filter((d) => d.startsWith(\"boundary=\")).map((s) => s.replace(/^boundary=/, \"\"))[0];\n  if (!boundary) {\n    return void 0;\n  }\n  const boundaryRegExp = new RegExp(`--+${boundary}`);\n  const fields = data2.split(boundaryRegExp).filter((chunk) => chunk.startsWith(\"\\r\\n\") && chunk.endsWith(\"\\r\\n\")).map((chunk) => chunk.trimStart().replace(/\\r\\n$/, \"\"));\n  if (!fields.length) {\n    return void 0;\n  }\n  const parsedBody = {};\n  try {\n    for (const field2 of fields) {\n      const [contentHeaders, ...rest] = field2.split(\"\\r\\n\\r\\n\");\n      const contentBody = rest.join(\"\\r\\n\\r\\n\");\n      const { contentType: contentType2, filename, name } = parseContentHeaders(contentHeaders);\n      const value = filename === void 0 ? contentBody : new File([contentBody], filename, { type: contentType2 });\n      const parsedValue = parsedBody[name];\n      if (parsedValue === void 0) {\n        parsedBody[name] = value;\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value];\n      } else {\n        parsedBody[name] = [parsedValue, value];\n      }\n    }\n    return parsedBody;\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/request/parseBody.ts\nfunction parseBody(body2, headers) {\n  var _a;\n  if (!body2) {\n    return body2;\n  }\n  const contentType = ((_a = headers == null ? void 0 : headers.get(\"content-type\")) == null ? void 0 : _a.toLowerCase()) || \"\";\n  const hasMultipartContent = contentType.startsWith(\"multipart/form-data\");\n  if (hasMultipartContent && typeof body2 !== \"object\") {\n    return parseMultipartData(body2.toString(), headers) || body2;\n  }\n  const hasJsonContent = contentType.includes(\"json\");\n  if (hasJsonContent && typeof body2 !== \"object\") {\n    return jsonParse(body2.toString()) || body2;\n  }\n  return body2;\n}\n\n// src/utils/internal/isStringEqual.ts\nfunction isStringEqual(actual, expected) {\n  return actual.toLowerCase() === expected.toLowerCase();\n}\n\n// src/utils/request/MockedRequest.ts\nvar MockedRequest = class extends _mswjs_interceptors__WEBPACK_IMPORTED_MODULE_3__.IsomorphicRequest {\n  constructor(url, init = {}) {\n    super(url, init);\n    if (init.id) {\n      this.id = init.id;\n    }\n    this.cache = init.cache || \"default\";\n    this.destination = init.destination || \"\";\n    this.integrity = init.integrity || \"\";\n    this.keepalive = init.keepalive || false;\n    this.mode = init.mode || \"cors\";\n    this.priority = init.priority || \"auto\";\n    this.redirect = init.redirect || \"follow\";\n    this.referrer = init.referrer || \"\";\n    this.referrerPolicy = init.referrerPolicy || \"no-referrer\";\n    this.cookies = init.cookies || this.getCookies();\n  }\n  get body() {\n    const text2 = (0,_mswjs_interceptors_lib_utils_bufferUtils_js__WEBPACK_IMPORTED_MODULE_7__.decodeBuffer)(this[\"_body\"]);\n    const body2 = parseBody(text2, this.headers);\n    if (isStringEqual(this.method, \"GET\") && body2 === \"\") {\n      return void 0;\n    }\n    return body2;\n  }\n  passthrough() {\n    return {\n      status: 101,\n      statusText: \"Continue\",\n      headers: new headers_polyfill__WEBPACK_IMPORTED_MODULE_8__.Headers(),\n      body: null,\n      passthrough: true,\n      once: false\n    };\n  }\n  getCookies() {\n    var _a;\n    const requestCookiesString = this.headers.get(\"cookie\");\n    const ownCookies = requestCookiesString ? cookie__WEBPACK_IMPORTED_MODULE_5__.parse(requestCookiesString) : {};\n    _mswjs_cookies__WEBPACK_IMPORTED_MODULE_6__.store.hydrate();\n    const cookiesFromStore = Array.from(\n      (_a = _mswjs_cookies__WEBPACK_IMPORTED_MODULE_6__.store.get({ ...this, url: this.url.href })) == null ? void 0 : _a.entries()\n    ).reduce((cookies, [name, { value }]) => {\n      return Object.assign(cookies, { [name.trim()]: value });\n    }, {});\n    const cookiesFromDocument = getRequestCookies(this);\n    const forwardedCookies = {\n      ...cookiesFromDocument,\n      ...cookiesFromStore\n    };\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append(\"cookie\", `${name}=${value}`);\n    }\n    return {\n      ...forwardedCookies,\n      ...ownCookies\n    };\n  }\n};\n\n// src/utils/handleRequest.ts\n\n\n// src/utils/getResponse.ts\nvar getResponse = async (request, handlers, resolutionContext) => {\n  const relevantHandlers = handlers.filter((handler) => {\n    return handler.test(request, resolutionContext);\n  });\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  const result = await relevantHandlers.reduce(async (executionResult, handler) => {\n    const previousResults = await executionResult;\n    if (!!(previousResults == null ? void 0 : previousResults.response)) {\n      return executionResult;\n    }\n    const result2 = await handler.run(request, resolutionContext);\n    if (result2 === null || result2.handler.shouldSkip) {\n      return null;\n    }\n    if (!result2.response) {\n      return {\n        request: result2.request,\n        handler: result2.handler,\n        response: void 0,\n        parsedResult: result2.parsedResult\n      };\n    }\n    if (result2.response.once) {\n      handler.markAsSkipped(true);\n    }\n    return result2;\n  }, Promise.resolve(null));\n  if (!result) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response\n  };\n};\n\n// src/utils/request/onUnhandledRequest.ts\n\n\n// src/utils/internal/parseGraphQLRequest.ts\n\n\n// src/utils/request/getPublicUrlFromRequest.ts\nvar getPublicUrlFromRequest = (request) => {\n  return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(\n    request.url.pathname,\n    `${request.url.protocol}//${request.url.host}`\n  ).href;\n};\n\n// src/utils/internal/parseGraphQLRequest.ts\nfunction parseDocumentNode(node) {\n  var _a;\n  const operationDef = node.definitions.find((def) => {\n    return def.kind === \"OperationDefinition\";\n  });\n  return {\n    operationType: operationDef == null ? void 0 : operationDef.operation,\n    operationName: (_a = operationDef == null ? void 0 : operationDef.name) == null ? void 0 : _a.value\n  };\n}\nfunction parseQuery(query) {\n  try {\n    const ast = (0,graphql__WEBPACK_IMPORTED_MODULE_11__.parse)(query);\n    return parseDocumentNode(ast);\n  } catch (error2) {\n    return error2;\n  }\n}\nfunction extractMultipartVariables(variables, map, files) {\n  const operations = { variables };\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`);\n    }\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split(\".\").reverse();\n      const paths = reversedPaths.reverse();\n      let target = operations;\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`);\n        }\n        target = target[path];\n      }\n      target[lastPath] = files[key];\n    }\n  }\n  return operations.variables;\n}\nfunction getGraphQLInput(request) {\n  var _a, _b;\n  switch (request.method) {\n    case \"GET\": {\n      const query = request.url.searchParams.get(\"query\");\n      const variables = request.url.searchParams.get(\"variables\") || \"\";\n      return {\n        query,\n        variables: jsonParse(variables)\n      };\n    }\n    case \"POST\": {\n      if ((_a = request.body) == null ? void 0 : _a.query) {\n        const { query, variables } = request.body;\n        return {\n          query,\n          variables\n        };\n      }\n      if ((_b = request.body) == null ? void 0 : _b.operations) {\n        const { operations, map, ...files } = request.body;\n        const parsedOperations = jsonParse(\n          operations\n        ) || {};\n        if (!parsedOperations.query) {\n          return null;\n        }\n        const parsedMap = jsonParse(map || \"\") || {};\n        const variables = parsedOperations.variables ? extractMultipartVariables(\n          parsedOperations.variables,\n          parsedMap,\n          files\n        ) : {};\n        return {\n          query: parsedOperations.query,\n          variables\n        };\n      }\n    }\n    default:\n      return null;\n  }\n}\nfunction parseGraphQLRequest(request) {\n  const input = getGraphQLInput(request);\n  if (!input || !input.query) {\n    return void 0;\n  }\n  const { query, variables } = input;\n  const parsedResult = parseQuery(query);\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s',\n        request.method,\n        requestPublicUrl,\n        parsedResult.message\n      )\n    );\n  }\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables\n  };\n}\n\n// node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json\nvar codes_default = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"103\": \"Early Hints\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a Teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Too Early\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n};\n\n// src/context/status.ts\nvar status = (statusCode, statusText) => {\n  return (res) => {\n    res.status = statusCode;\n    res.statusText = statusText || codes_default[String(statusCode)];\n    return res;\n  };\n};\n\n// src/context/set.ts\n\nfunction set(...args) {\n  return (res) => {\n    const [name, value] = args;\n    if (typeof name === \"string\") {\n      res.headers.append(name, value);\n    } else {\n      const headers = (0,headers_polyfill__WEBPACK_IMPORTED_MODULE_8__.objectToHeaders)(name);\n      headers.forEach((value2, name2) => {\n        res.headers.append(name2, value2);\n      });\n    }\n    return res;\n  };\n}\n\n// src/context/cookie.ts\n\nvar cookie = (name, value, options) => {\n  return (res) => {\n    const serializedCookie = cookie__WEBPACK_IMPORTED_MODULE_5__.serialize(name, value, options);\n    res.headers.append(\"Set-Cookie\", serializedCookie);\n    if (typeof document !== \"undefined\") {\n      document.cookie = serializedCookie;\n    }\n    return res;\n  };\n};\n\n// src/context/body.ts\nvar body = (value) => {\n  return (res) => {\n    res.body = value;\n    return res;\n  };\n};\n\n// src/context/json.ts\nvar json = (body2) => {\n  return (res) => {\n    res.headers.set(\"Content-Type\", \"application/json\");\n    res.body = JSON.stringify(body2);\n    return res;\n  };\n};\n\n// src/context/data.ts\nvar data = (payload) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { data: payload });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/extensions.ts\nvar extensions = (payload) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { extensions: payload });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/delay.ts\n\nvar SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;\nvar MIN_SERVER_RESPONSE_TIME = 100;\nvar MAX_SERVER_RESPONSE_TIME = 400;\nvar NODE_SERVER_RESPONSE_TIME = 5;\nvar getRandomServerResponseTime = () => {\n  if ((0,is_node_process__WEBPACK_IMPORTED_MODULE_12__.isNodeProcess)()) {\n    return NODE_SERVER_RESPONSE_TIME;\n  }\n  return Math.floor(\n    Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME\n  );\n};\nvar delay = (durationOrMode) => {\n  return (res) => {\n    let delayTime;\n    if (typeof durationOrMode === \"string\") {\n      switch (durationOrMode) {\n        case \"infinite\": {\n          delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;\n          break;\n        }\n        case \"real\": {\n          delayTime = getRandomServerResponseTime();\n          break;\n        }\n        default: {\n          throw new Error(\n            `Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`\n          );\n        }\n      }\n    } else if (typeof durationOrMode === \"undefined\") {\n      delayTime = getRandomServerResponseTime();\n    } else {\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\n          `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`\n        );\n      }\n      delayTime = durationOrMode;\n    }\n    res.delay = delayTime;\n    return res;\n  };\n};\n\n// src/context/errors.ts\nvar errors = (errorsList) => {\n  return (res) => {\n    if (errorsList == null) {\n      return res;\n    }\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { errors: errorsList });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/fetch.ts\n\n\nvar useFetch = (0,is_node_process__WEBPACK_IMPORTED_MODULE_12__.isNodeProcess)() ? (input, init) => Promise.resolve().then(() => __toESM(__require(\"node-fetch\"))).then(\n  ({ default: nodeFetch }) => nodeFetch(input, init)\n) : globalThis.fetch;\nvar augmentRequestInit = (requestInit) => {\n  const headers = new headers_polyfill__WEBPACK_IMPORTED_MODULE_8__.Headers(requestInit.headers);\n  headers.set(\"x-msw-bypass\", \"true\");\n  return {\n    ...requestInit,\n    headers: headers.all()\n  };\n};\nvar createFetchRequestParameters = (input) => {\n  const { body: body2, method } = input;\n  const requestParameters = {\n    ...input,\n    body: void 0\n  };\n  if ([\"GET\", \"HEAD\"].includes(method)) {\n    return requestParameters;\n  }\n  if (typeof body2 === \"object\" || typeof body2 === \"number\" || typeof body2 === \"boolean\") {\n    requestParameters.body = JSON.stringify(body2);\n  } else {\n    requestParameters.body = body2;\n  }\n  return requestParameters;\n};\nvar fetch = (input, requestInit = {}) => {\n  if (typeof input === \"string\") {\n    return useFetch(input, augmentRequestInit(requestInit));\n  }\n  const requestParameters = createFetchRequestParameters(input);\n  const derivedRequestInit = augmentRequestInit(requestParameters);\n  return useFetch(input.url.href, derivedRequestInit);\n};\n\n// src/context/text.ts\nvar text = (body2) => {\n  return (res) => {\n    res.headers.set(\"Content-Type\", \"text/plain\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/context/xml.ts\nvar xml = (body2) => {\n  return (res) => {\n    res.headers.set(\"Content-Type\", \"text/xml\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/utils/logging/getStatusCodeColor.ts\nfunction getStatusCodeColor(status2) {\n  if (status2 < 300) {\n    return \"#69AB32\" /* Success */;\n  }\n  if (status2 < 400) {\n    return \"#F0BB4B\" /* Warning */;\n  }\n  return \"#E95F5D\" /* Danger */;\n}\n\n// src/utils/logging/getTimestamp.ts\nfunction getTimestamp() {\n  const now = new Date();\n  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map((chunk) => chunk.slice(0, 2)).map((chunk) => chunk.padStart(2, \"0\")).join(\":\");\n}\n\n// src/utils/logging/prepareRequest.ts\nfunction prepareRequest(request) {\n  return {\n    ...request,\n    body: request.body,\n    headers: request.headers.all()\n  };\n}\n\n// src/utils/logging/prepareResponse.ts\n\nfunction prepareResponse(res) {\n  const responseHeaders = (0,headers_polyfill__WEBPACK_IMPORTED_MODULE_8__.objectToHeaders)(res.headers);\n  const parsedBody = parseBody(res.body, responseHeaders);\n  return {\n    ...res,\n    body: parsedBody\n  };\n}\n\n// src/utils/matching/matchRequestUrl.ts\n\n\n\n// src/utils/url/cleanUrl.ts\nvar REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g;\nfunction getSearchParams(path) {\n  return new URL(`/${path}`, \"http://localhost\").searchParams;\n}\nfunction cleanUrl(path) {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, \"\");\n}\n\n// src/utils/url/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n}\n\n// src/utils/url/getAbsoluteUrl.ts\nfunction getAbsoluteUrl(path, baseUrl) {\n  if (isAbsoluteUrl(path)) {\n    return path;\n  }\n  if (path.startsWith(\"*\")) {\n    return path;\n  }\n  const origin = baseUrl || typeof document !== \"undefined\" && document.baseURI;\n  return origin ? decodeURI(new URL(encodeURI(path), origin).href) : path;\n}\n\n// src/utils/matching/normalizePath.ts\nfunction normalizePath(path, baseUrl) {\n  if (path instanceof RegExp) {\n    return path;\n  }\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);\n  return cleanUrl(maybeAbsoluteUrl);\n}\n\n// src/utils/matching/matchRequestUrl.ts\nfunction coercePath(path) {\n  return path.replace(\n    /([:a-zA-Z_-]*)(\\*{1,2})+/g,\n    (_, parameterName, wildcard) => {\n      const expression = \"(.*)\";\n      if (!parameterName) {\n        return expression;\n      }\n      return parameterName.startsWith(\":\") ? `${parameterName}${wildcard}` : `${parameterName}${expression}`;\n    }\n  ).replace(/([^\\/])(:)(?=\\d+)/, \"$1\\\\$2\").replace(/^([^\\/]+)(:)(?=\\/\\/)/, \"$1\\\\$2\");\n}\nfunction matchRequestUrl(url, path, baseUrl) {\n  const normalizedPath = normalizePath(path, baseUrl);\n  const cleanPath = typeof normalizedPath === \"string\" ? coercePath(normalizedPath) : normalizedPath;\n  const cleanUrl2 = (0,_mswjs_interceptors_lib_utils_getCleanUrl_js__WEBPACK_IMPORTED_MODULE_13__.getCleanUrl)(url);\n  const result = (0,path_to_regexp__WEBPACK_IMPORTED_MODULE_14__.match)(cleanPath, { decode: decodeURIComponent })(cleanUrl2);\n  const params = result && result.params || {};\n  return {\n    matches: result !== false,\n    params\n  };\n}\n\n// src/handlers/RequestHandler.ts\n\n\n// src/response.ts\n\n\n// src/utils/internal/compose.ts\nfunction compose(...fns) {\n  return (...args) => {\n    return fns.reduceRight((leftFn, rightFn) => {\n      return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);\n    }, args[0]);\n  };\n}\n\n// src/utils/NetworkError.ts\nvar NetworkError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"NetworkError\";\n  }\n};\n\n// src/response.ts\nvar defaultResponse = {\n  status: 200,\n  statusText: \"OK\",\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false\n};\nvar defaultResponseTransformers = [];\nfunction createResponseComposition(responseOverrides, defaultTransformers = defaultResponseTransformers) {\n  return async (...transformers) => {\n    const initialResponse = Object.assign(\n      {},\n      defaultResponse,\n      {\n        headers: new headers_polyfill__WEBPACK_IMPORTED_MODULE_8__.Headers({\n          \"x-powered-by\": \"msw\"\n        })\n      },\n      responseOverrides\n    );\n    const resolvedTransformers = [\n      ...defaultTransformers,\n      ...transformers\n    ].filter(Boolean);\n    const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;\n    return resolvedResponse;\n  };\n}\nvar response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({ once: true }),\n  networkError(message) {\n    throw new NetworkError(message);\n  }\n});\n\n// src/utils/internal/getCallFrame.ts\nvar SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/;\nvar BUILD_FRAME = /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/;\nfunction getCallFrame(error2) {\n  const stack = error2.stack;\n  if (!stack) {\n    return;\n  }\n  const frames = stack.split(\"\\n\").slice(1);\n  const declarationFrame = frames.find((frame) => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame));\n  });\n  if (!declarationFrame) {\n    return;\n  }\n  const declarationPath = declarationFrame.replace(/\\s*at [^()]*\\(([^)]+)\\)/, \"$1\").replace(/^@/, \"\");\n  return declarationPath;\n}\n\n// src/utils/internal/isIterable.ts\nfunction isIterable(fn) {\n  if (!fn) {\n    return false;\n  }\n  return typeof fn[Symbol.iterator] == \"function\";\n}\n\n// src/handlers/RequestHandler.ts\nvar defaultContext = {\n  status,\n  set,\n  delay,\n  fetch\n};\nvar RequestHandler = class {\n  constructor(options) {\n    this.shouldSkip = false;\n    this.ctx = options.ctx || defaultContext;\n    this.resolver = options.resolver;\n    const callFrame = getCallFrame(new Error());\n    this.info = {\n      ...options.info,\n      callFrame\n    };\n  }\n  parse(_request, _resolutionContext) {\n    return null;\n  }\n  test(request, resolutionContext) {\n    return this.predicate(\n      request,\n      this.parse(request, resolutionContext),\n      resolutionContext\n    );\n  }\n  getPublicRequest(request, _parsedResult) {\n    return request;\n  }\n  markAsSkipped(shouldSkip = true) {\n    this.shouldSkip = shouldSkip;\n  }\n  async run(request, resolutionContext) {\n    if (this.shouldSkip) {\n      return null;\n    }\n    const parsedResult = this.parse(request, resolutionContext);\n    const shouldIntercept = this.predicate(\n      request,\n      parsedResult,\n      resolutionContext\n    );\n    if (!shouldIntercept) {\n      return null;\n    }\n    const publicRequest = this.getPublicRequest(request, parsedResult);\n    const executeResolver = this.wrapResolver(this.resolver);\n    const mockedResponse = await executeResolver(\n      publicRequest,\n      response,\n      this.ctx\n    );\n    return this.createExecutionResult(\n      parsedResult,\n      publicRequest,\n      mockedResponse\n    );\n  }\n  wrapResolver(resolver) {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || await resolver(req, res, ctx);\n      if (isIterable(result)) {\n        const { value, done } = result[Symbol.iterator]().next();\n        const nextResponse = await value;\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult;\n        }\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result;\n        }\n        this.resolverGeneratorResult = nextResponse;\n        return nextResponse;\n      }\n      return result;\n    };\n  }\n  createExecutionResult(parsedResult, request, response2) {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response2 || null\n    };\n  }\n};\n\n// src/handlers/RestHandler.ts\nvar restContext = {\n  ...defaultContext,\n  cookie,\n  body,\n  text,\n  json,\n  xml\n};\nvar RestRequest = class extends MockedRequest {\n  constructor(request, params) {\n    super(request.url, {\n      ...request,\n      body: request[\"_body\"]\n    });\n    this.params = params;\n    this.id = request.id;\n  }\n};\nvar RestHandler = class extends RequestHandler {\n  constructor(method, path, resolver) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method\n      },\n      ctx: restContext,\n      resolver\n    });\n    this.checkRedundantQueryParameters();\n  }\n  checkRedundantQueryParameters() {\n    const { method, path } = this.info;\n    if (path instanceof RegExp) {\n      return;\n    }\n    const url = cleanUrl(path);\n    if (url === path) {\n      return;\n    }\n    const searchParams = getSearchParams(path);\n    const queryParams = [];\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName);\n    });\n    devUtils.warn(\n      `Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`\n    );\n  }\n  parse(request, resolutionContext) {\n    return matchRequestUrl(\n      request.url,\n      this.info.path,\n      resolutionContext == null ? void 0 : resolutionContext.baseUrl\n    );\n  }\n  getPublicRequest(request, parsedResult) {\n    return new RestRequest(request, parsedResult.params || {});\n  }\n  predicate(request, parsedResult) {\n    const matchesMethod = this.info.method instanceof RegExp ? this.info.method.test(request.method) : isStringEqual(this.info.method, request.method);\n    return matchesMethod && parsedResult.matches;\n  }\n  log(request, response2) {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    console.groupCollapsed(\n      devUtils.formatMessage(\"%s %s %s (%c%s%c)\"),\n      getTimestamp(),\n      request.method,\n      publicUrl,\n      `color:${statusColor}`,\n      `${response2.status} ${response2.statusText}`,\n      \"color:inherit\"\n    );\n    console.log(\"Request\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/context/field.ts\n\nvar field = (fieldName, fieldValue) => {\n  return (res) => {\n    validateFieldName(fieldName);\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { [fieldName]: fieldValue });\n    return json(nextBody)(res);\n  };\n};\nfunction validateFieldName(fieldName) {\n  (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(\n    fieldName.trim() !== \"\",\n    devUtils.formatMessage(\n      \"Failed to set a custom field on a GraphQL response: field name cannot be empty.\"\n    )\n  );\n  (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(\n    fieldName !== \"data\",\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?',\n      fieldName\n    )\n  );\n  (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(\n    fieldName !== \"errors\",\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?',\n      fieldName\n    )\n  );\n  (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(\n    fieldName !== \"extensions\",\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?',\n      fieldName\n    )\n  );\n}\n\n// src/utils/internal/tryCatch.ts\nfunction tryCatch(fn, onException) {\n  try {\n    const result = fn();\n    return result;\n  } catch (error2) {\n    onException == null ? void 0 : onException(error2);\n  }\n}\n\n// src/handlers/GraphQLHandler.ts\nvar graphqlContext = {\n  ...defaultContext,\n  data,\n  extensions,\n  errors,\n  cookie,\n  field\n};\nfunction isDocumentNode(value) {\n  if (value == null) {\n    return false;\n  }\n  return typeof value === \"object\" && \"kind\" in value && \"definitions\" in value;\n}\nvar GraphQLRequest = class extends MockedRequest {\n  constructor(request, variables, operationName) {\n    super(request.url, {\n      ...request,\n      body: request[\"_body\"]\n    });\n    this.variables = variables;\n    this.operationName = operationName;\n  }\n};\nvar GraphQLHandler = class extends RequestHandler {\n  constructor(operationType, operationName, endpoint, resolver) {\n    let resolvedOperationName = operationName;\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName);\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`\n        );\n      }\n      if (!parsedNode.operationName) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`\n        );\n      }\n      resolvedOperationName = parsedNode.operationName;\n    }\n    const header = operationType === \"all\" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`;\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName\n      },\n      ctx: graphqlContext,\n      resolver\n    });\n    this.endpoint = endpoint;\n  }\n  parse(request) {\n    return tryCatch(\n      () => parseGraphQLRequest(request),\n      (error2) => console.error(error2.message)\n    );\n  }\n  getPublicRequest(request, parsedResult) {\n    var _a, _b;\n    return new GraphQLRequest(\n      request,\n      (_a = parsedResult == null ? void 0 : parsedResult.variables) != null ? _a : {},\n      (_b = parsedResult == null ? void 0 : parsedResult.operationName) != null ? _b : \"\"\n    );\n  }\n  predicate(request, parsedResult) {\n    if (!parsedResult) {\n      return false;\n    }\n    if (!parsedResult.operationName && this.info.operationType !== \"all\") {\n      const publicUrl = getPublicUrlFromRequest(request);\n      devUtils.warn(`Failed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation()\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation      `);\n      return false;\n    }\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint);\n    const hasMatchingOperationType = this.info.operationType === \"all\" || parsedResult.operationType === this.info.operationType;\n    const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(parsedResult.operationName || \"\") : parsedResult.operationName === this.info.operationName;\n    return hasMatchingUrl.matches && hasMatchingOperationType && hasMatchingOperationName;\n  }\n  log(request, response2, parsedRequest) {\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    const requestInfo = (parsedRequest == null ? void 0 : parsedRequest.operationName) ? `${parsedRequest == null ? void 0 : parsedRequest.operationType} ${parsedRequest == null ? void 0 : parsedRequest.operationName}` : `anonymous ${parsedRequest == null ? void 0 : parsedRequest.operationType}`;\n    console.groupCollapsed(\n      devUtils.formatMessage(\"%s %s (%c%s%c)\"),\n      getTimestamp(),\n      `${requestInfo}`,\n      `color:${statusColor}`,\n      `${response2.status} ${response2.statusText}`,\n      \"color:inherit\"\n    );\n    console.log(\"Request:\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response:\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/utils/request/onUnhandledRequest.ts\nvar MAX_MATCH_SCORE = 3;\nvar MAX_SUGGESTION_COUNT = 4;\nvar TYPE_MATCH_DELTA = 0.5;\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce(\n    (groups, handler) => {\n      if (handler instanceof RestHandler) {\n        groups.rest.push(handler);\n      }\n      if (handler instanceof GraphQLHandler) {\n        groups.graphql.push(handler);\n      }\n      return groups;\n    },\n    {\n      rest: [],\n      graphql: []\n    }\n  );\n}\nfunction getRestHandlerScore() {\n  return (request, handler) => {\n    const { path, method } = handler.info;\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n    const hasSameMethod = isStringEqual(request.method, method);\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    const score = js_levenshtein__WEBPACK_IMPORTED_MODULE_10__(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === \"undefined\") {\n      return Infinity;\n    }\n    const { operationType, operationName } = handler.info;\n    if (typeof operationName !== \"string\") {\n      return Infinity;\n    }\n    const hasSameOperationType = parsedQuery.operationType === operationType;\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    const score = js_levenshtein__WEBPACK_IMPORTED_MODULE_10__(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\nfunction getSuggestedHandler(request, handlers, getScore) {\n  const suggestedHandlers = handlers.reduce((suggestions, handler) => {\n    const score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort(([leftScore], [rightScore]) => leftScore - rightScore).filter(([score]) => score <= MAX_MATCH_SCORE).slice(0, MAX_SUGGESTION_COUNT).map(([, handler]) => handler);\n  return suggestedHandlers;\n}\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return `Did you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `  \\u2022 ${handler.info.header}`).join(\"\\n\")}`;\n  }\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`;\n}\nfunction onUnhandledRequest(request, handlers, strategy = \"warn\") {\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));\n  function generateHandlerSuggestion() {\n    const handlerGroups = groupHandlersByType(handlers);\n    const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n    const suggestedHandlers = getSuggestedHandler(\n      request,\n      relevantHandlers,\n      parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore()\n    );\n    return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : \"\";\n  }\n  function generateUnhandledRequestMessage() {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;\n    const handlerSuggestion = generateHandlerSuggestion();\n    const messageTemplate = [\n      `captured a request without a matching request handler:`,\n      `  \\u2022 ${requestHeader}`,\n      handlerSuggestion,\n      `If you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks`\n    ].filter(Boolean);\n    return messageTemplate.join(\"\\n\\n\");\n  }\n  function applyStrategy(strategy2) {\n    const message = generateUnhandledRequestMessage();\n    switch (strategy2) {\n      case \"error\": {\n        devUtils.error(\"Error: %s\", message);\n        throw new Error(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'\n          )\n        );\n      }\n      case \"warn\": {\n        devUtils.warn(\"Warning: %s\", message);\n        break;\n      }\n      case \"bypass\":\n        break;\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy2\n          )\n        );\n    }\n  }\n  if (typeof strategy === \"function\") {\n    strategy(request, {\n      warning: applyStrategy.bind(null, \"warn\"),\n      error: applyStrategy.bind(null, \"error\")\n    });\n    return;\n  }\n  applyStrategy(strategy);\n}\n\n// src/utils/request/readResponseCookies.ts\n\nfunction readResponseCookies(request, response2) {\n  _mswjs_cookies__WEBPACK_IMPORTED_MODULE_6__.store.add({ ...request, url: request.url.toString() }, response2);\n  _mswjs_cookies__WEBPACK_IMPORTED_MODULE_6__.store.persist();\n}\n\n// src/utils/handleRequest.ts\nasync function handleRequest(request, handlers, options, emitter, handleRequestOptions) {\n  var _a, _b, _c, _d, _e, _f;\n  emitter.emit(\"request:start\", request);\n  if (request.headers.get(\"x-msw-bypass\") === \"true\") {\n    emitter.emit(\"request:end\", request);\n    (_a = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _a.call(handleRequestOptions, request);\n    return;\n  }\n  const [lookupError, lookupResult] = await (0,_open_draft_until__WEBPACK_IMPORTED_MODULE_9__.until)(() => {\n    return getResponse(\n      request,\n      handlers,\n      handleRequestOptions == null ? void 0 : handleRequestOptions.resolutionContext\n    );\n  });\n  if (lookupError) {\n    emitter.emit(\"unhandledException\", lookupError, request);\n    throw lookupError;\n  }\n  const { handler, response: response2 } = lookupResult;\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n    emitter.emit(\"request:unhandled\", request);\n    emitter.emit(\"request:end\", request);\n    (_b = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _b.call(handleRequestOptions, request);\n    return;\n  }\n  if (!response2) {\n    devUtils.warn(\n      `Expected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\n\n  \\u2022 %s\n    %s`,\n      response2,\n      handler.info.header,\n      handler.info.callFrame\n    );\n    emitter.emit(\"request:end\", request);\n    (_c = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _c.call(handleRequestOptions, request);\n    return;\n  }\n  if (response2.passthrough) {\n    emitter.emit(\"request:end\", request);\n    (_d = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _d.call(handleRequestOptions, request);\n    return;\n  }\n  readResponseCookies(request, response2);\n  emitter.emit(\"request:match\", request);\n  const requiredLookupResult = lookupResult;\n  const transformedResponse = ((_e = handleRequestOptions == null ? void 0 : handleRequestOptions.transformResponse) == null ? void 0 : _e.call(handleRequestOptions, response2)) || response2;\n  (_f = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponse) == null ? void 0 : _f.call(\n    handleRequestOptions,\n    transformedResponse,\n    requiredLookupResult\n  );\n  emitter.emit(\"request:end\", request);\n  return transformedResponse;\n}\n\n// src/node/SetupServerApi.ts\nvar { bold } = chalk__WEBPACK_IMPORTED_MODULE_1__;\nvar DEFAULT_LISTEN_OPTIONS = {\n  onUnhandledRequest: \"warn\"\n};\nvar SetupServerApi = class extends SetupApi {\n  constructor(interceptors, ...handlers) {\n    super(...handlers);\n    this.interceptor = new _mswjs_interceptors__WEBPACK_IMPORTED_MODULE_3__.BatchInterceptor({\n      name: \"setup-server\",\n      interceptors: interceptors.map((Interceptor2) => new Interceptor2())\n    });\n    this.resolvedOptions = {};\n    this.init();\n  }\n  init() {\n    this.interceptor.on(\"request\", async (request) => {\n      const mockedRequest = new MockedRequest(request.url, {\n        ...request,\n        body: await request.arrayBuffer()\n      });\n      const response2 = await handleRequest(\n        mockedRequest,\n        this.currentHandlers,\n        this.resolvedOptions,\n        this.emitter,\n        {\n          transformResponse(response3) {\n            return {\n              status: response3.status,\n              statusText: response3.statusText,\n              headers: response3.headers.all(),\n              body: response3.body,\n              delay: response3.delay\n            };\n          }\n        }\n      );\n      if (response2) {\n        if (response2.delay) {\n          await new Promise((resolve) => {\n            setTimeout(resolve, response2.delay);\n          });\n        }\n        request.respondWith(response2);\n      }\n      return;\n    });\n    this.interceptor.on(\"response\", (request, response2) => {\n      if (!request.id) {\n        return;\n      }\n      if (response2.headers.get(\"x-powered-by\") === \"msw\") {\n        this.emitter.emit(\"response:mocked\", response2, request.id);\n      } else {\n        this.emitter.emit(\"response:bypass\", response2, request.id);\n      }\n    });\n  }\n  listen(options = {}) {\n    this.resolvedOptions = mergeRight(\n      DEFAULT_LISTEN_OPTIONS,\n      options\n    );\n    this.interceptor.apply();\n    (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(\n      [_mswjs_interceptors__WEBPACK_IMPORTED_MODULE_3__.InterceptorReadyState.APPLYING, _mswjs_interceptors__WEBPACK_IMPORTED_MODULE_3__.InterceptorReadyState.APPLIED].includes(\n        this.interceptor.readyState\n      ),\n      devUtils.formatMessage(\n        'Failed to start \"setupServer\": the interceptor failed to apply. This is likely an issue with the library and you should report it at \"%s\".'\n      ),\n      \"https://github.com/mswjs/msw/issues/new/choose\"\n    );\n  }\n  printHandlers() {\n    const handlers = this.listHandlers();\n    handlers.forEach((handler) => {\n      const { header, callFrame } = handler.info;\n      const pragma = handler.info.hasOwnProperty(\"operationType\") ? \"[graphql]\" : \"[rest]\";\n      console.log(`${bold(`${pragma} ${header}`)}\n  Declaration: ${callFrame}\n`);\n    });\n  }\n  close() {\n    super.dispose();\n    this.interceptor.dispose();\n  }\n};\n\n// src/node/setupServer.ts\n\n\n\nvar setupServer = (...handlers) => {\n  return new SetupServerApi(\n    [_mswjs_interceptors_lib_interceptors_ClientRequest_index_js__WEBPACK_IMPORTED_MODULE_15__.ClientRequestInterceptor, _mswjs_interceptors_lib_interceptors_XMLHttpRequest_index_js__WEBPACK_IMPORTED_MODULE_16__.XMLHttpRequestInterceptor, _mswjs_interceptors_lib_interceptors_fetch_index_js__WEBPACK_IMPORTED_MODULE_17__.FetchInterceptor],\n    ...handlers\n  );\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL21zdy9saWIvbm9kZS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTs7QUFFQTtBQUNzRDtBQUN0RCxpQkFBaUIsOENBQWM7O0FBRS9CO0FBQzBCO0FBQzJCO0FBSXhCOztBQUU3QjtBQUN1QztBQUNROztBQUUvQztBQUNvQztBQUNwQztBQUNBO0FBQ0EsOEJBQThCLGtEQUFNO0FBQ3BDLFlBQVksZ0JBQWdCLEVBQUUsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBTztBQUM5Qiw2QkFBNkIseURBQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0scURBQVM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxrQkFBa0I7QUFDckI7O0FBRUE7QUFDdUM7QUFDQTtBQUNpQjtBQUNvQjtBQUNqQzs7QUFFM0M7QUFDc0M7QUFDdEM7QUFDQSxTQUFTLHlDQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNtRDtBQUNuRDtBQUNBO0FBQ0Esa0JBQWtCLGlFQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRDQUE0QztBQUMxRCw0RkFBNEYsb0JBQW9CO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxrRUFBaUI7QUFDbkQsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBGQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMseUNBQWtCO0FBQ2hFLElBQUksaURBQUs7QUFDVDtBQUNBLFlBQVksaURBQUssT0FBTyw2QkFBNkI7QUFDckQsZ0NBQWdDLE9BQU87QUFDdkMsc0NBQXNDLHNCQUFzQjtBQUM1RCxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSyxHQUFHLE1BQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNpRDs7QUFFakQ7QUFDMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxxQkFBcUIsSUFBSSxpQkFBaUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFNO0FBQ3RCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSx3REFBd0QsSUFBSTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxNQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixzQkFBc0IsaUVBQWU7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QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxREFBVTtBQUNkLE9BQU8sc0VBQXFCLFdBQVcsc0VBQXFCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBLHFCQUFxQixRQUFRLFFBQVEsRUFBRSxPQUFPO0FBQzlDLGlCQUFpQjtBQUNqQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDdUc7QUFDRTtBQUNsQjtBQUN2RjtBQUNBO0FBQ0EsS0FBSyxrSEFBd0IsRUFBRSxvSEFBeUIsRUFBRSxrR0FBZ0I7QUFDMUU7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvbXN3L2xpYi9ub2RlL2luZGV4Lm1qcz9kMzcxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19yZXF1aXJlID0gLyogQF9fUFVSRV9fICovICgoeCkgPT4gdHlwZW9mIHJlcXVpcmUgIT09IFwidW5kZWZpbmVkXCIgPyByZXF1aXJlIDogdHlwZW9mIFByb3h5ICE9PSBcInVuZGVmaW5lZFwiID8gbmV3IFByb3h5KHgsIHtcbiAgZ2V0OiAoYSwgYikgPT4gKHR5cGVvZiByZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiID8gcmVxdWlyZSA6IGEpW2JdXG59KSA6IHgpKGZ1bmN0aW9uKHgpIHtcbiAgaWYgKHR5cGVvZiByZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiKVxuICAgIHJldHVybiByZXF1aXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRocm93IG5ldyBFcnJvcignRHluYW1pYyByZXF1aXJlIG9mIFwiJyArIHggKyAnXCIgaXMgbm90IHN1cHBvcnRlZCcpO1xufSk7XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcblxuLy8gY29uZmlnL3BvbHlmaWxscy1ub2RlLnRzXG5pbXBvcnQgeyBzZXRUaW1lb3V0IGFzIG5vZGVTZXRUaW1lb3V0IH0gZnJvbSBcInRpbWVyc1wiO1xudmFyIHNldFRpbWVvdXQgPSBub2RlU2V0VGltZW91dDtcblxuLy8gc3JjL25vZGUvU2V0dXBTZXJ2ZXJBcGkudHNcbmltcG9ydCBjaGFsayBmcm9tIFwiY2hhbGtcIjtcbmltcG9ydCB7IGludmFyaWFudCBhcyBpbnZhcmlhbnQzIH0gZnJvbSBcIm91dHZhcmlhbnRcIjtcbmltcG9ydCB7XG4gIEJhdGNoSW50ZXJjZXB0b3IsXG4gIEludGVyY2VwdG9yUmVhZHlTdGF0ZVxufSBmcm9tIFwiQG1zd2pzL2ludGVyY2VwdG9yc1wiO1xuXG4vLyBzcmMvU2V0dXBBcGkudHNcbmltcG9ydCB7IGludmFyaWFudCB9IGZyb20gXCJvdXR2YXJpYW50XCI7XG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSBcInN0cmljdC1ldmVudC1lbWl0dGVyXCI7XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9kZXZVdGlscy50c1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSBcIm91dHZhcmlhbnRcIjtcbnZhciBMSUJSQVJZX1BSRUZJWCA9IFwiW01TV11cIjtcbmZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2UobWVzc2FnZSwgLi4ucG9zaXRpb25hbHMpIHtcbiAgY29uc3QgaW50ZXJwb2xhdGVkTWVzc2FnZSA9IGZvcm1hdChtZXNzYWdlLCAuLi5wb3NpdGlvbmFscyk7XG4gIHJldHVybiBgJHtMSUJSQVJZX1BSRUZJWH0gJHtpbnRlcnBvbGF0ZWRNZXNzYWdlfWA7XG59XG5mdW5jdGlvbiB3YXJuKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSB7XG4gIGNvbnNvbGUud2Fybihmb3JtYXRNZXNzYWdlKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSk7XG59XG5mdW5jdGlvbiBlcnJvcihtZXNzYWdlLCAuLi5wb3NpdGlvbmFscykge1xuICBjb25zb2xlLmVycm9yKGZvcm1hdE1lc3NhZ2UobWVzc2FnZSwgLi4ucG9zaXRpb25hbHMpKTtcbn1cbnZhciBkZXZVdGlscyA9IHtcbiAgZm9ybWF0TWVzc2FnZSxcbiAgd2FybixcbiAgZXJyb3Jcbn07XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9waXBlRXZlbnRzLnRzXG5mdW5jdGlvbiBwaXBlRXZlbnRzKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgY29uc3QgcmF3RW1pdCA9IHNvdXJjZS5lbWl0O1xuICBpZiAocmF3RW1pdC5faXNQaXBlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBzb3VyY2UuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50LCAuLi5kYXRhMikge1xuICAgIGRlc3RpbmF0aW9uLmVtaXQoZXZlbnQsIC4uLmRhdGEyKTtcbiAgICByZXR1cm4gcmF3RW1pdC5jYWxsKHRoaXMsIGV2ZW50LCAuLi5kYXRhMik7XG4gIH07XG4gIHNvdXJjZS5lbWl0Ll9pc1BpcGVkID0gdHJ1ZTtcbn1cblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL3RvUmVhZG9ubHlBcnJheS50c1xuZnVuY3Rpb24gdG9SZWFkb25seUFycmF5KHNvdXJjZSkge1xuICBjb25zdCBjbG9uZSA9IFsuLi5zb3VyY2VdO1xuICBPYmplY3QuZnJlZXplKGNsb25lKTtcbiAgcmV0dXJuIGNsb25lO1xufVxuXG4vLyBzcmMvU2V0dXBBcGkudHNcbnZhciBTZXR1cEFwaSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoLi4uaW5pdGlhbEhhbmRsZXJzKSB7XG4gICAgdGhpcy52YWxpZGF0ZUhhbmRsZXJzKC4uLmluaXRpYWxIYW5kbGVycyk7XG4gICAgdGhpcy5pbml0aWFsSGFuZGxlcnMgPSB0b1JlYWRvbmx5QXJyYXkoaW5pdGlhbEhhbmRsZXJzKTtcbiAgICB0aGlzLmN1cnJlbnRIYW5kbGVycyA9IFsuLi5pbml0aWFsSGFuZGxlcnNdO1xuICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgdGhpcy5wdWJsaWNFbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICBwaXBlRXZlbnRzKHRoaXMuZW1pdHRlciwgdGhpcy5wdWJsaWNFbWl0dGVyKTtcbiAgICB0aGlzLmV2ZW50cyA9IHRoaXMuY3JlYXRlTGlmZUN5Y2xlRXZlbnRzKCk7XG4gIH1cbiAgdmFsaWRhdGVIYW5kbGVycyguLi5oYW5kbGVycykge1xuICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICAhQXJyYXkuaXNBcnJheShoYW5kbGVyKSxcbiAgICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICAnRmFpbGVkIHRvIGNvbnN0cnVjdCBcIiVzXCIgZ2l2ZW4gYW4gQXJyYXkgb2YgcmVxdWVzdCBoYW5kbGVycy4gTWFrZSBzdXJlIHlvdSBzcHJlYWQgdGhlIHJlcXVlc3QgaGFuZGxlcnMgd2hlbiBjYWxsaW5nIHRoZSByZXNwZWN0aXZlIHNldHVwIGZ1bmN0aW9uLidcbiAgICAgICAgKSxcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnB1YmxpY0VtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbiAgdXNlKC4uLnJ1bnRpbWVIYW5kbGVycykge1xuICAgIHRoaXMuY3VycmVudEhhbmRsZXJzLnVuc2hpZnQoLi4ucnVudGltZUhhbmRsZXJzKTtcbiAgfVxuICByZXN0b3JlSGFuZGxlcnMoKSB7XG4gICAgdGhpcy5jdXJyZW50SGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgaGFuZGxlci5tYXJrQXNTa2lwcGVkKGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuICByZXNldEhhbmRsZXJzKC4uLm5leHRIYW5kbGVycykge1xuICAgIHRoaXMuY3VycmVudEhhbmRsZXJzID0gbmV4dEhhbmRsZXJzLmxlbmd0aCA+IDAgPyBbLi4ubmV4dEhhbmRsZXJzXSA6IFsuLi50aGlzLmluaXRpYWxIYW5kbGVyc107XG4gIH1cbiAgbGlzdEhhbmRsZXJzKCkge1xuICAgIHJldHVybiB0b1JlYWRvbmx5QXJyYXkodGhpcy5jdXJyZW50SGFuZGxlcnMpO1xuICB9XG4gIGNyZWF0ZUxpZmVDeWNsZUV2ZW50cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb246ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY0VtaXR0ZXIub24oLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlTGlzdGVuZXI6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY0VtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiAoLi4uYXJncykgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyguLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvaXNPYmplY3QudHNcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9tZXJnZVJpZ2h0LnRzXG5mdW5jdGlvbiBtZXJnZVJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyaWdodCkucmVkdWNlKChyZXN1bHQsIFtrZXksIHJpZ2h0VmFsdWVdKSA9PiB7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gcmVzdWx0W2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGVmdFZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHJpZ2h0VmFsdWUpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGxlZnRWYWx1ZS5jb25jYXQocmlnaHRWYWx1ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QobGVmdFZhbHVlKSAmJiBpc09iamVjdChyaWdodFZhbHVlKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZVJpZ2h0KGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXN1bHRba2V5XSA9IHJpZ2h0VmFsdWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgT2JqZWN0LmFzc2lnbih7fSwgbGVmdCkpO1xufVxuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9Nb2NrZWRSZXF1ZXN0LnRzXG5pbXBvcnQgKiBhcyBjb29raWVVdGlsczIgZnJvbSBcImNvb2tpZVwiO1xuaW1wb3J0IHsgc3RvcmUgfSBmcm9tIFwiQG1zd2pzL2Nvb2tpZXNcIjtcbmltcG9ydCB7IElzb21vcnBoaWNSZXF1ZXN0IH0gZnJvbSBcIkBtc3dqcy9pbnRlcmNlcHRvcnNcIjtcbmltcG9ydCB7IGRlY29kZUJ1ZmZlciB9IGZyb20gXCJAbXN3anMvaW50ZXJjZXB0b3JzL2xpYi91dGlscy9idWZmZXJVdGlscy5qc1wiO1xuaW1wb3J0IHsgSGVhZGVycyB9IGZyb20gXCJoZWFkZXJzLXBvbHlmaWxsXCI7XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L2dldFJlcXVlc3RDb29raWVzLnRzXG5pbXBvcnQgKiBhcyBjb29raWVVdGlscyBmcm9tIFwiY29va2llXCI7XG5mdW5jdGlvbiBnZXRBbGxDb29raWVzKCkge1xuICByZXR1cm4gY29va2llVXRpbHMucGFyc2UoZG9jdW1lbnQuY29va2llKTtcbn1cbmZ1bmN0aW9uIGdldFJlcXVlc3RDb29raWVzKHJlcXVlc3QpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgbG9jYXRpb24gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgc3dpdGNoIChyZXF1ZXN0LmNyZWRlbnRpYWxzKSB7XG4gICAgY2FzZSBcInNhbWUtb3JpZ2luXCI6IHtcbiAgICAgIHJldHVybiBsb2NhdGlvbi5vcmlnaW4gPT09IHJlcXVlc3QudXJsLm9yaWdpbiA/IGdldEFsbENvb2tpZXMoKSA6IHt9O1xuICAgIH1cbiAgICBjYXNlIFwiaW5jbHVkZVwiOiB7XG4gICAgICByZXR1cm4gZ2V0QWxsQ29va2llcygpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9qc29uUGFyc2UudHNcbmZ1bmN0aW9uIGpzb25QYXJzZSh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvcGFyc2VNdWx0aXBhcnREYXRhLnRzXG5pbXBvcnQgeyBzdHJpbmdUb0hlYWRlcnMgfSBmcm9tIFwiaGVhZGVycy1wb2x5ZmlsbFwiO1xuZnVuY3Rpb24gcGFyc2VDb250ZW50SGVhZGVycyhoZWFkZXJzU3RyaW5nKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IGhlYWRlcnMgPSBzdHJpbmdUb0hlYWRlcnMoaGVhZGVyc1N0cmluZyk7XG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJ0ZXh0L3BsYWluXCI7XG4gIGNvbnN0IGRpc3Bvc2l0aW9uID0gaGVhZGVycy5nZXQoXCJjb250ZW50LWRpc3Bvc2l0aW9uXCIpO1xuICBpZiAoIWRpc3Bvc2l0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIkNvbnRlbnQtRGlzcG9zaXRpb25cIiBoZWFkZXIgaXMgcmVxdWlyZWQuJyk7XG4gIH1cbiAgY29uc3QgZGlyZWN0aXZlcyA9IGRpc3Bvc2l0aW9uLnNwbGl0KFwiO1wiKS5yZWR1Y2UoKGFjYywgY2h1bmspID0+IHtcbiAgICBjb25zdCBbbmFtZTIsIC4uLnJlc3RdID0gY2h1bmsudHJpbSgpLnNwbGl0KFwiPVwiKTtcbiAgICBhY2NbbmFtZTJdID0gcmVzdC5qb2luKFwiPVwiKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIGNvbnN0IG5hbWUgPSAoX2EgPSBkaXJlY3RpdmVzLm5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zbGljZSgxLCAtMSk7XG4gIGNvbnN0IGZpbGVuYW1lID0gKF9iID0gZGlyZWN0aXZlcy5maWxlbmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnNsaWNlKDEsIC0xKTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIGZpbGVuYW1lLFxuICAgIGNvbnRlbnRUeXBlXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZU11bHRpcGFydERhdGEoZGF0YTIsIGhlYWRlcnMpIHtcbiAgY29uc3QgY29udGVudFR5cGUgPSBoZWFkZXJzID09IG51bGwgPyB2b2lkIDAgOiBoZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgaWYgKCFjb250ZW50VHlwZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgWywgLi4uZGlyZWN0aXZlc10gPSBjb250ZW50VHlwZS5zcGxpdCgvOyAqLyk7XG4gIGNvbnN0IGJvdW5kYXJ5ID0gZGlyZWN0aXZlcy5maWx0ZXIoKGQpID0+IGQuc3RhcnRzV2l0aChcImJvdW5kYXJ5PVwiKSkubWFwKChzKSA9PiBzLnJlcGxhY2UoL15ib3VuZGFyeT0vLCBcIlwiKSlbMF07XG4gIGlmICghYm91bmRhcnkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IGJvdW5kYXJ5UmVnRXhwID0gbmV3IFJlZ0V4cChgLS0rJHtib3VuZGFyeX1gKTtcbiAgY29uc3QgZmllbGRzID0gZGF0YTIuc3BsaXQoYm91bmRhcnlSZWdFeHApLmZpbHRlcigoY2h1bmspID0+IGNodW5rLnN0YXJ0c1dpdGgoXCJcXHJcXG5cIikgJiYgY2h1bmsuZW5kc1dpdGgoXCJcXHJcXG5cIikpLm1hcCgoY2h1bmspID0+IGNodW5rLnRyaW1TdGFydCgpLnJlcGxhY2UoL1xcclxcbiQvLCBcIlwiKSk7XG4gIGlmICghZmllbGRzLmxlbmd0aCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgcGFyc2VkQm9keSA9IHt9O1xuICB0cnkge1xuICAgIGZvciAoY29uc3QgZmllbGQyIG9mIGZpZWxkcykge1xuICAgICAgY29uc3QgW2NvbnRlbnRIZWFkZXJzLCAuLi5yZXN0XSA9IGZpZWxkMi5zcGxpdChcIlxcclxcblxcclxcblwiKTtcbiAgICAgIGNvbnN0IGNvbnRlbnRCb2R5ID0gcmVzdC5qb2luKFwiXFxyXFxuXFxyXFxuXCIpO1xuICAgICAgY29uc3QgeyBjb250ZW50VHlwZTogY29udGVudFR5cGUyLCBmaWxlbmFtZSwgbmFtZSB9ID0gcGFyc2VDb250ZW50SGVhZGVycyhjb250ZW50SGVhZGVycyk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGZpbGVuYW1lID09PSB2b2lkIDAgPyBjb250ZW50Qm9keSA6IG5ldyBGaWxlKFtjb250ZW50Qm9keV0sIGZpbGVuYW1lLCB7IHR5cGU6IGNvbnRlbnRUeXBlMiB9KTtcbiAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VkQm9keVtuYW1lXTtcbiAgICAgIGlmIChwYXJzZWRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHBhcnNlZEJvZHlbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRWYWx1ZSkpIHtcbiAgICAgICAgcGFyc2VkQm9keVtuYW1lXSA9IFsuLi5wYXJzZWRWYWx1ZSwgdmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkQm9keVtuYW1lXSA9IFtwYXJzZWRWYWx1ZSwgdmFsdWVdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkQm9keTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9wYXJzZUJvZHkudHNcbmZ1bmN0aW9uIHBhcnNlQm9keShib2R5MiwgaGVhZGVycykge1xuICB2YXIgX2E7XG4gIGlmICghYm9keTIpIHtcbiAgICByZXR1cm4gYm9keTI7XG4gIH1cbiAgY29uc3QgY29udGVudFR5cGUgPSAoKF9hID0gaGVhZGVycyA9PSBudWxsID8gdm9pZCAwIDogaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikpID09IG51bGwgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKSB8fCBcIlwiO1xuICBjb25zdCBoYXNNdWx0aXBhcnRDb250ZW50ID0gY29udGVudFR5cGUuc3RhcnRzV2l0aChcIm11bHRpcGFydC9mb3JtLWRhdGFcIik7XG4gIGlmIChoYXNNdWx0aXBhcnRDb250ZW50ICYmIHR5cGVvZiBib2R5MiAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBwYXJzZU11bHRpcGFydERhdGEoYm9keTIudG9TdHJpbmcoKSwgaGVhZGVycykgfHwgYm9keTI7XG4gIH1cbiAgY29uc3QgaGFzSnNvbkNvbnRlbnQgPSBjb250ZW50VHlwZS5pbmNsdWRlcyhcImpzb25cIik7XG4gIGlmIChoYXNKc29uQ29udGVudCAmJiB0eXBlb2YgYm9keTIgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4ganNvblBhcnNlKGJvZHkyLnRvU3RyaW5nKCkpIHx8IGJvZHkyO1xuICB9XG4gIHJldHVybiBib2R5Mjtcbn1cblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL2lzU3RyaW5nRXF1YWwudHNcbmZ1bmN0aW9uIGlzU3RyaW5nRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkge1xuICByZXR1cm4gYWN0dWFsLnRvTG93ZXJDYXNlKCkgPT09IGV4cGVjdGVkLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L01vY2tlZFJlcXVlc3QudHNcbnZhciBNb2NrZWRSZXF1ZXN0ID0gY2xhc3MgZXh0ZW5kcyBJc29tb3JwaGljUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yKHVybCwgaW5pdCA9IHt9KSB7XG4gICAgc3VwZXIodXJsLCBpbml0KTtcbiAgICBpZiAoaW5pdC5pZCkge1xuICAgICAgdGhpcy5pZCA9IGluaXQuaWQ7XG4gICAgfVxuICAgIHRoaXMuY2FjaGUgPSBpbml0LmNhY2hlIHx8IFwiZGVmYXVsdFwiO1xuICAgIHRoaXMuZGVzdGluYXRpb24gPSBpbml0LmRlc3RpbmF0aW9uIHx8IFwiXCI7XG4gICAgdGhpcy5pbnRlZ3JpdHkgPSBpbml0LmludGVncml0eSB8fCBcIlwiO1xuICAgIHRoaXMua2VlcGFsaXZlID0gaW5pdC5rZWVwYWxpdmUgfHwgZmFsc2U7XG4gICAgdGhpcy5tb2RlID0gaW5pdC5tb2RlIHx8IFwiY29yc1wiO1xuICAgIHRoaXMucHJpb3JpdHkgPSBpbml0LnByaW9yaXR5IHx8IFwiYXV0b1wiO1xuICAgIHRoaXMucmVkaXJlY3QgPSBpbml0LnJlZGlyZWN0IHx8IFwiZm9sbG93XCI7XG4gICAgdGhpcy5yZWZlcnJlciA9IGluaXQucmVmZXJyZXIgfHwgXCJcIjtcbiAgICB0aGlzLnJlZmVycmVyUG9saWN5ID0gaW5pdC5yZWZlcnJlclBvbGljeSB8fCBcIm5vLXJlZmVycmVyXCI7XG4gICAgdGhpcy5jb29raWVzID0gaW5pdC5jb29raWVzIHx8IHRoaXMuZ2V0Q29va2llcygpO1xuICB9XG4gIGdldCBib2R5KCkge1xuICAgIGNvbnN0IHRleHQyID0gZGVjb2RlQnVmZmVyKHRoaXNbXCJfYm9keVwiXSk7XG4gICAgY29uc3QgYm9keTIgPSBwYXJzZUJvZHkodGV4dDIsIHRoaXMuaGVhZGVycyk7XG4gICAgaWYgKGlzU3RyaW5nRXF1YWwodGhpcy5tZXRob2QsIFwiR0VUXCIpICYmIGJvZHkyID09PSBcIlwiKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gYm9keTI7XG4gIH1cbiAgcGFzc3Rocm91Z2goKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogMTAxLFxuICAgICAgc3RhdHVzVGV4dDogXCJDb250aW51ZVwiLFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoKSxcbiAgICAgIGJvZHk6IG51bGwsXG4gICAgICBwYXNzdGhyb3VnaDogdHJ1ZSxcbiAgICAgIG9uY2U6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBnZXRDb29raWVzKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXF1ZXN0Q29va2llc1N0cmluZyA9IHRoaXMuaGVhZGVycy5nZXQoXCJjb29raWVcIik7XG4gICAgY29uc3Qgb3duQ29va2llcyA9IHJlcXVlc3RDb29raWVzU3RyaW5nID8gY29va2llVXRpbHMyLnBhcnNlKHJlcXVlc3RDb29raWVzU3RyaW5nKSA6IHt9O1xuICAgIHN0b3JlLmh5ZHJhdGUoKTtcbiAgICBjb25zdCBjb29raWVzRnJvbVN0b3JlID0gQXJyYXkuZnJvbShcbiAgICAgIChfYSA9IHN0b3JlLmdldCh7IC4uLnRoaXMsIHVybDogdGhpcy51cmwuaHJlZiB9KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmVudHJpZXMoKVxuICAgICkucmVkdWNlKChjb29raWVzLCBbbmFtZSwgeyB2YWx1ZSB9XSkgPT4ge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oY29va2llcywgeyBbbmFtZS50cmltKCldOiB2YWx1ZSB9KTtcbiAgICB9LCB7fSk7XG4gICAgY29uc3QgY29va2llc0Zyb21Eb2N1bWVudCA9IGdldFJlcXVlc3RDb29raWVzKHRoaXMpO1xuICAgIGNvbnN0IGZvcndhcmRlZENvb2tpZXMgPSB7XG4gICAgICAuLi5jb29raWVzRnJvbURvY3VtZW50LFxuICAgICAgLi4uY29va2llc0Zyb21TdG9yZVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZvcndhcmRlZENvb2tpZXMpKSB7XG4gICAgICB0aGlzLmhlYWRlcnMuYXBwZW5kKFwiY29va2llXCIsIGAke25hbWV9PSR7dmFsdWV9YCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5mb3J3YXJkZWRDb29raWVzLFxuICAgICAgLi4ub3duQ29va2llc1xuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9oYW5kbGVSZXF1ZXN0LnRzXG5pbXBvcnQgeyB1bnRpbCB9IGZyb20gXCJAb3Blbi1kcmFmdC91bnRpbFwiO1xuXG4vLyBzcmMvdXRpbHMvZ2V0UmVzcG9uc2UudHNcbnZhciBnZXRSZXNwb25zZSA9IGFzeW5jIChyZXF1ZXN0LCBoYW5kbGVycywgcmVzb2x1dGlvbkNvbnRleHQpID0+IHtcbiAgY29uc3QgcmVsZXZhbnRIYW5kbGVycyA9IGhhbmRsZXJzLmZpbHRlcigoaGFuZGxlcikgPT4ge1xuICAgIHJldHVybiBoYW5kbGVyLnRlc3QocmVxdWVzdCwgcmVzb2x1dGlvbkNvbnRleHQpO1xuICB9KTtcbiAgaWYgKHJlbGV2YW50SGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIHJlc3BvbnNlOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlbGV2YW50SGFuZGxlcnMucmVkdWNlKGFzeW5jIChleGVjdXRpb25SZXN1bHQsIGhhbmRsZXIpID0+IHtcbiAgICBjb25zdCBwcmV2aW91c1Jlc3VsdHMgPSBhd2FpdCBleGVjdXRpb25SZXN1bHQ7XG4gICAgaWYgKCEhKHByZXZpb3VzUmVzdWx0cyA9PSBudWxsID8gdm9pZCAwIDogcHJldmlvdXNSZXN1bHRzLnJlc3BvbnNlKSkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGlvblJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IGhhbmRsZXIucnVuKHJlcXVlc3QsIHJlc29sdXRpb25Db250ZXh0KTtcbiAgICBpZiAocmVzdWx0MiA9PT0gbnVsbCB8fCByZXN1bHQyLmhhbmRsZXIuc2hvdWxkU2tpcCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghcmVzdWx0Mi5yZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVxdWVzdDogcmVzdWx0Mi5yZXF1ZXN0LFxuICAgICAgICBoYW5kbGVyOiByZXN1bHQyLmhhbmRsZXIsXG4gICAgICAgIHJlc3BvbnNlOiB2b2lkIDAsXG4gICAgICAgIHBhcnNlZFJlc3VsdDogcmVzdWx0Mi5wYXJzZWRSZXN1bHRcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChyZXN1bHQyLnJlc3BvbnNlLm9uY2UpIHtcbiAgICAgIGhhbmRsZXIubWFya0FzU2tpcHBlZCh0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH0sIFByb21pc2UucmVzb2x2ZShudWxsKSk7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIHJlc3BvbnNlOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaGFuZGxlcjogcmVzdWx0LmhhbmRsZXIsXG4gICAgcHVibGljUmVxdWVzdDogcmVzdWx0LnJlcXVlc3QsXG4gICAgcGFyc2VkUmVxdWVzdDogcmVzdWx0LnBhcnNlZFJlc3VsdCxcbiAgICByZXNwb25zZTogcmVzdWx0LnJlc3BvbnNlXG4gIH07XG59O1xuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9vblVuaGFuZGxlZFJlcXVlc3QudHNcbmltcG9ydCBnZXRTdHJpbmdNYXRjaFNjb3JlIGZyb20gXCJqcy1sZXZlbnNodGVpblwiO1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvcGFyc2VHcmFwaFFMUmVxdWVzdC50c1xuaW1wb3J0IHsgcGFyc2UgYXMgcGFyc2UzIH0gZnJvbSBcImdyYXBocWxcIjtcblxuLy8gc3JjL3V0aWxzL3JlcXVlc3QvZ2V0UHVibGljVXJsRnJvbVJlcXVlc3QudHNcbnZhciBnZXRQdWJsaWNVcmxGcm9tUmVxdWVzdCA9IChyZXF1ZXN0KSA9PiB7XG4gIHJldHVybiByZXF1ZXN0LnJlZmVycmVyLnN0YXJ0c1dpdGgocmVxdWVzdC51cmwub3JpZ2luKSA/IHJlcXVlc3QudXJsLnBhdGhuYW1lIDogbmV3IFVSTChcbiAgICByZXF1ZXN0LnVybC5wYXRobmFtZSxcbiAgICBgJHtyZXF1ZXN0LnVybC5wcm90b2NvbH0vLyR7cmVxdWVzdC51cmwuaG9zdH1gXG4gICkuaHJlZjtcbn07XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9wYXJzZUdyYXBoUUxSZXF1ZXN0LnRzXG5mdW5jdGlvbiBwYXJzZURvY3VtZW50Tm9kZShub2RlKSB7XG4gIHZhciBfYTtcbiAgY29uc3Qgb3BlcmF0aW9uRGVmID0gbm9kZS5kZWZpbml0aW9ucy5maW5kKChkZWYpID0+IHtcbiAgICByZXR1cm4gZGVmLmtpbmQgPT09IFwiT3BlcmF0aW9uRGVmaW5pdGlvblwiO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBvcGVyYXRpb25UeXBlOiBvcGVyYXRpb25EZWYgPT0gbnVsbCA/IHZvaWQgMCA6IG9wZXJhdGlvbkRlZi5vcGVyYXRpb24sXG4gICAgb3BlcmF0aW9uTmFtZTogKF9hID0gb3BlcmF0aW9uRGVmID09IG51bGwgPyB2b2lkIDAgOiBvcGVyYXRpb25EZWYubmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVF1ZXJ5KHF1ZXJ5KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgYXN0ID0gcGFyc2UzKHF1ZXJ5KTtcbiAgICByZXR1cm4gcGFyc2VEb2N1bWVudE5vZGUoYXN0KTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgcmV0dXJuIGVycm9yMjtcbiAgfVxufVxuZnVuY3Rpb24gZXh0cmFjdE11bHRpcGFydFZhcmlhYmxlcyh2YXJpYWJsZXMsIG1hcCwgZmlsZXMpIHtcbiAgY29uc3Qgb3BlcmF0aW9ucyA9IHsgdmFyaWFibGVzIH07XG4gIGZvciAoY29uc3QgW2tleSwgcGF0aEFycmF5XSBvZiBPYmplY3QuZW50cmllcyhtYXApKSB7XG4gICAgaWYgKCEoa2V5IGluIGZpbGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBHaXZlbiBmaWxlcyBkbyBub3QgaGF2ZSBhIGtleSAnJHtrZXl9JyAuYCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZG90UGF0aCBvZiBwYXRoQXJyYXkpIHtcbiAgICAgIGNvbnN0IFtsYXN0UGF0aCwgLi4ucmV2ZXJzZWRQYXRoc10gPSBkb3RQYXRoLnNwbGl0KFwiLlwiKS5yZXZlcnNlKCk7XG4gICAgICBjb25zdCBwYXRocyA9IHJldmVyc2VkUGF0aHMucmV2ZXJzZSgpO1xuICAgICAgbGV0IHRhcmdldCA9IG9wZXJhdGlvbnM7XG4gICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgaWYgKCEocGF0aCBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9wZXJ0eSAnJHtwYXRoc30nIGlzIG5vdCBpbiBvcGVyYXRpb25zLmApO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IHRhcmdldFtwYXRoXTtcbiAgICAgIH1cbiAgICAgIHRhcmdldFtsYXN0UGF0aF0gPSBmaWxlc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3BlcmF0aW9ucy52YXJpYWJsZXM7XG59XG5mdW5jdGlvbiBnZXRHcmFwaFFMSW5wdXQocmVxdWVzdCkge1xuICB2YXIgX2EsIF9iO1xuICBzd2l0Y2ggKHJlcXVlc3QubWV0aG9kKSB7XG4gICAgY2FzZSBcIkdFVFwiOiB7XG4gICAgICBjb25zdCBxdWVyeSA9IHJlcXVlc3QudXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJxdWVyeVwiKTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHJlcXVlc3QudXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ2YXJpYWJsZXNcIikgfHwgXCJcIjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICB2YXJpYWJsZXM6IGpzb25QYXJzZSh2YXJpYWJsZXMpXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiUE9TVFwiOiB7XG4gICAgICBpZiAoKF9hID0gcmVxdWVzdC5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2EucXVlcnkpIHtcbiAgICAgICAgY29uc3QgeyBxdWVyeSwgdmFyaWFibGVzIH0gPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcXVlcnksXG4gICAgICAgICAgdmFyaWFibGVzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoKF9iID0gcmVxdWVzdC5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2Iub3BlcmF0aW9ucykge1xuICAgICAgICBjb25zdCB7IG9wZXJhdGlvbnMsIG1hcCwgLi4uZmlsZXMgfSA9IHJlcXVlc3QuYm9keTtcbiAgICAgICAgY29uc3QgcGFyc2VkT3BlcmF0aW9ucyA9IGpzb25QYXJzZShcbiAgICAgICAgICBvcGVyYXRpb25zXG4gICAgICAgICkgfHwge307XG4gICAgICAgIGlmICghcGFyc2VkT3BlcmF0aW9ucy5xdWVyeSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZE1hcCA9IGpzb25QYXJzZShtYXAgfHwgXCJcIikgfHwge307XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHBhcnNlZE9wZXJhdGlvbnMudmFyaWFibGVzID8gZXh0cmFjdE11bHRpcGFydFZhcmlhYmxlcyhcbiAgICAgICAgICBwYXJzZWRPcGVyYXRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgICBwYXJzZWRNYXAsXG4gICAgICAgICAgZmlsZXNcbiAgICAgICAgKSA6IHt9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHF1ZXJ5OiBwYXJzZWRPcGVyYXRpb25zLnF1ZXJ5LFxuICAgICAgICAgIHZhcmlhYmxlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlR3JhcGhRTFJlcXVlc3QocmVxdWVzdCkge1xuICBjb25zdCBpbnB1dCA9IGdldEdyYXBoUUxJbnB1dChyZXF1ZXN0KTtcbiAgaWYgKCFpbnB1dCB8fCAhaW5wdXQucXVlcnkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IHsgcXVlcnksIHZhcmlhYmxlcyB9ID0gaW5wdXQ7XG4gIGNvbnN0IHBhcnNlZFJlc3VsdCA9IHBhcnNlUXVlcnkocXVlcnkpO1xuICBpZiAocGFyc2VkUmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBjb25zdCByZXF1ZXN0UHVibGljVXJsID0gZ2V0UHVibGljVXJsRnJvbVJlcXVlc3QocmVxdWVzdCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgJ0ZhaWxlZCB0byBpbnRlcmNlcHQgYSBHcmFwaFFMIHJlcXVlc3QgdG8gXCIlcyAlc1wiOiBjYW5ub3QgcGFyc2UgcXVlcnkuIFNlZSB0aGUgZXJyb3IgbWVzc2FnZSBmcm9tIHRoZSBwYXJzZXIgYmVsb3cuXFxuXFxuJXMnLFxuICAgICAgICByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgcmVxdWVzdFB1YmxpY1VybCxcbiAgICAgICAgcGFyc2VkUmVzdWx0Lm1lc3NhZ2VcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgb3BlcmF0aW9uVHlwZTogcGFyc2VkUmVzdWx0Lm9wZXJhdGlvblR5cGUsXG4gICAgb3BlcmF0aW9uTmFtZTogcGFyc2VkUmVzdWx0Lm9wZXJhdGlvbk5hbWUsXG4gICAgdmFyaWFibGVzXG4gIH07XG59XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS9zdGF0dXNlc0AyLjAuMS9ub2RlX21vZHVsZXMvc3RhdHVzZXMvY29kZXMuanNvblxudmFyIGNvZGVzX2RlZmF1bHQgPSB7XG4gIFwiMTAwXCI6IFwiQ29udGludWVcIixcbiAgXCIxMDFcIjogXCJTd2l0Y2hpbmcgUHJvdG9jb2xzXCIsXG4gIFwiMTAyXCI6IFwiUHJvY2Vzc2luZ1wiLFxuICBcIjEwM1wiOiBcIkVhcmx5IEhpbnRzXCIsXG4gIFwiMjAwXCI6IFwiT0tcIixcbiAgXCIyMDFcIjogXCJDcmVhdGVkXCIsXG4gIFwiMjAyXCI6IFwiQWNjZXB0ZWRcIixcbiAgXCIyMDNcIjogXCJOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvblwiLFxuICBcIjIwNFwiOiBcIk5vIENvbnRlbnRcIixcbiAgXCIyMDVcIjogXCJSZXNldCBDb250ZW50XCIsXG4gIFwiMjA2XCI6IFwiUGFydGlhbCBDb250ZW50XCIsXG4gIFwiMjA3XCI6IFwiTXVsdGktU3RhdHVzXCIsXG4gIFwiMjA4XCI6IFwiQWxyZWFkeSBSZXBvcnRlZFwiLFxuICBcIjIyNlwiOiBcIklNIFVzZWRcIixcbiAgXCIzMDBcIjogXCJNdWx0aXBsZSBDaG9pY2VzXCIsXG4gIFwiMzAxXCI6IFwiTW92ZWQgUGVybWFuZW50bHlcIixcbiAgXCIzMDJcIjogXCJGb3VuZFwiLFxuICBcIjMwM1wiOiBcIlNlZSBPdGhlclwiLFxuICBcIjMwNFwiOiBcIk5vdCBNb2RpZmllZFwiLFxuICBcIjMwNVwiOiBcIlVzZSBQcm94eVwiLFxuICBcIjMwN1wiOiBcIlRlbXBvcmFyeSBSZWRpcmVjdFwiLFxuICBcIjMwOFwiOiBcIlBlcm1hbmVudCBSZWRpcmVjdFwiLFxuICBcIjQwMFwiOiBcIkJhZCBSZXF1ZXN0XCIsXG4gIFwiNDAxXCI6IFwiVW5hdXRob3JpemVkXCIsXG4gIFwiNDAyXCI6IFwiUGF5bWVudCBSZXF1aXJlZFwiLFxuICBcIjQwM1wiOiBcIkZvcmJpZGRlblwiLFxuICBcIjQwNFwiOiBcIk5vdCBGb3VuZFwiLFxuICBcIjQwNVwiOiBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiLFxuICBcIjQwNlwiOiBcIk5vdCBBY2NlcHRhYmxlXCIsXG4gIFwiNDA3XCI6IFwiUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIixcbiAgXCI0MDhcIjogXCJSZXF1ZXN0IFRpbWVvdXRcIixcbiAgXCI0MDlcIjogXCJDb25mbGljdFwiLFxuICBcIjQxMFwiOiBcIkdvbmVcIixcbiAgXCI0MTFcIjogXCJMZW5ndGggUmVxdWlyZWRcIixcbiAgXCI0MTJcIjogXCJQcmVjb25kaXRpb24gRmFpbGVkXCIsXG4gIFwiNDEzXCI6IFwiUGF5bG9hZCBUb28gTGFyZ2VcIixcbiAgXCI0MTRcIjogXCJVUkkgVG9vIExvbmdcIixcbiAgXCI0MTVcIjogXCJVbnN1cHBvcnRlZCBNZWRpYSBUeXBlXCIsXG4gIFwiNDE2XCI6IFwiUmFuZ2UgTm90IFNhdGlzZmlhYmxlXCIsXG4gIFwiNDE3XCI6IFwiRXhwZWN0YXRpb24gRmFpbGVkXCIsXG4gIFwiNDE4XCI6IFwiSSdtIGEgVGVhcG90XCIsXG4gIFwiNDIxXCI6IFwiTWlzZGlyZWN0ZWQgUmVxdWVzdFwiLFxuICBcIjQyMlwiOiBcIlVucHJvY2Vzc2FibGUgRW50aXR5XCIsXG4gIFwiNDIzXCI6IFwiTG9ja2VkXCIsXG4gIFwiNDI0XCI6IFwiRmFpbGVkIERlcGVuZGVuY3lcIixcbiAgXCI0MjVcIjogXCJUb28gRWFybHlcIixcbiAgXCI0MjZcIjogXCJVcGdyYWRlIFJlcXVpcmVkXCIsXG4gIFwiNDI4XCI6IFwiUHJlY29uZGl0aW9uIFJlcXVpcmVkXCIsXG4gIFwiNDI5XCI6IFwiVG9vIE1hbnkgUmVxdWVzdHNcIixcbiAgXCI0MzFcIjogXCJSZXF1ZXN0IEhlYWRlciBGaWVsZHMgVG9vIExhcmdlXCIsXG4gIFwiNDUxXCI6IFwiVW5hdmFpbGFibGUgRm9yIExlZ2FsIFJlYXNvbnNcIixcbiAgXCI1MDBcIjogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIixcbiAgXCI1MDFcIjogXCJOb3QgSW1wbGVtZW50ZWRcIixcbiAgXCI1MDJcIjogXCJCYWQgR2F0ZXdheVwiLFxuICBcIjUwM1wiOiBcIlNlcnZpY2UgVW5hdmFpbGFibGVcIixcbiAgXCI1MDRcIjogXCJHYXRld2F5IFRpbWVvdXRcIixcbiAgXCI1MDVcIjogXCJIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZFwiLFxuICBcIjUwNlwiOiBcIlZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzXCIsXG4gIFwiNTA3XCI6IFwiSW5zdWZmaWNpZW50IFN0b3JhZ2VcIixcbiAgXCI1MDhcIjogXCJMb29wIERldGVjdGVkXCIsXG4gIFwiNTA5XCI6IFwiQmFuZHdpZHRoIExpbWl0IEV4Y2VlZGVkXCIsXG4gIFwiNTEwXCI6IFwiTm90IEV4dGVuZGVkXCIsXG4gIFwiNTExXCI6IFwiTmV0d29yayBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiXG59O1xuXG4vLyBzcmMvY29udGV4dC9zdGF0dXMudHNcbnZhciBzdGF0dXMgPSAoc3RhdHVzQ29kZSwgc3RhdHVzVGV4dCkgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIHJlcy5zdGF0dXMgPSBzdGF0dXNDb2RlO1xuICAgIHJlcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCB8fCBjb2Rlc19kZWZhdWx0W1N0cmluZyhzdGF0dXNDb2RlKV07XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L3NldC50c1xuaW1wb3J0IHsgb2JqZWN0VG9IZWFkZXJzIH0gZnJvbSBcImhlYWRlcnMtcG9seWZpbGxcIjtcbmZ1bmN0aW9uIHNldCguLi5hcmdzKSB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgY29uc3QgW25hbWUsIHZhbHVlXSA9IGFyZ3M7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXMuaGVhZGVycy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gb2JqZWN0VG9IZWFkZXJzKG5hbWUpO1xuICAgICAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZTIsIG5hbWUyKSA9PiB7XG4gICAgICAgIHJlcy5oZWFkZXJzLmFwcGVuZChuYW1lMiwgdmFsdWUyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xufVxuXG4vLyBzcmMvY29udGV4dC9jb29raWUudHNcbmltcG9ydCAqIGFzIGNvb2tpZVV0aWxzMyBmcm9tIFwiY29va2llXCI7XG52YXIgY29va2llID0gKG5hbWUsIHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgY29uc3Qgc2VyaWFsaXplZENvb2tpZSA9IGNvb2tpZVV0aWxzMy5zZXJpYWxpemUobmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIHJlcy5oZWFkZXJzLmFwcGVuZChcIlNldC1Db29raWVcIiwgc2VyaWFsaXplZENvb2tpZSk7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZG9jdW1lbnQuY29va2llID0gc2VyaWFsaXplZENvb2tpZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L2JvZHkudHNcbnZhciBib2R5ID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgcmVzLmJvZHkgPSB2YWx1ZTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQvanNvbi50c1xudmFyIGpzb24gPSAoYm9keTIpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICByZXMuaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgIHJlcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keTIpO1xuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dC9kYXRhLnRzXG52YXIgZGF0YSA9IChwYXlsb2FkKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgY29uc3QgcHJldkJvZHkgPSBqc29uUGFyc2UocmVzLmJvZHkpIHx8IHt9O1xuICAgIGNvbnN0IG5leHRCb2R5ID0gbWVyZ2VSaWdodChwcmV2Qm9keSwgeyBkYXRhOiBwYXlsb2FkIH0pO1xuICAgIHJldHVybiBqc29uKG5leHRCb2R5KShyZXMpO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQvZXh0ZW5zaW9ucy50c1xudmFyIGV4dGVuc2lvbnMgPSAocGF5bG9hZCkgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIGNvbnN0IHByZXZCb2R5ID0ganNvblBhcnNlKHJlcy5ib2R5KSB8fCB7fTtcbiAgICBjb25zdCBuZXh0Qm9keSA9IG1lcmdlUmlnaHQocHJldkJvZHksIHsgZXh0ZW5zaW9uczogcGF5bG9hZCB9KTtcbiAgICByZXR1cm4ganNvbihuZXh0Qm9keSkocmVzKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L2RlbGF5LnRzXG5pbXBvcnQgeyBpc05vZGVQcm9jZXNzIH0gZnJvbSBcImlzLW5vZGUtcHJvY2Vzc1wiO1xudmFyIFNFVF9USU1FT1VUX01BWF9BTExPV0VEX0lOVCA9IDIxNDc0ODM2NDc7XG52YXIgTUlOX1NFUlZFUl9SRVNQT05TRV9USU1FID0gMTAwO1xudmFyIE1BWF9TRVJWRVJfUkVTUE9OU0VfVElNRSA9IDQwMDtcbnZhciBOT0RFX1NFUlZFUl9SRVNQT05TRV9USU1FID0gNTtcbnZhciBnZXRSYW5kb21TZXJ2ZXJSZXNwb25zZVRpbWUgPSAoKSA9PiB7XG4gIGlmIChpc05vZGVQcm9jZXNzKCkpIHtcbiAgICByZXR1cm4gTk9ERV9TRVJWRVJfUkVTUE9OU0VfVElNRTtcbiAgfVxuICByZXR1cm4gTWF0aC5mbG9vcihcbiAgICBNYXRoLnJhbmRvbSgpICogKE1BWF9TRVJWRVJfUkVTUE9OU0VfVElNRSAtIE1JTl9TRVJWRVJfUkVTUE9OU0VfVElNRSkgKyBNSU5fU0VSVkVSX1JFU1BPTlNFX1RJTUVcbiAgKTtcbn07XG52YXIgZGVsYXkgPSAoZHVyYXRpb25Pck1vZGUpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICBsZXQgZGVsYXlUaW1lO1xuICAgIGlmICh0eXBlb2YgZHVyYXRpb25Pck1vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHN3aXRjaCAoZHVyYXRpb25Pck1vZGUpIHtcbiAgICAgICAgY2FzZSBcImluZmluaXRlXCI6IHtcbiAgICAgICAgICBkZWxheVRpbWUgPSBTRVRfVElNRU9VVF9NQVhfQUxMT1dFRF9JTlQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJlYWxcIjoge1xuICAgICAgICAgIGRlbGF5VGltZSA9IGdldFJhbmRvbVNlcnZlclJlc3BvbnNlVGltZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGRlbGF5IGEgcmVzcG9uc2U6IHVua25vd24gZGVsYXkgbW9kZSBcIiR7ZHVyYXRpb25Pck1vZGV9XCIuIFBsZWFzZSBtYWtlIHN1cmUgeW91IHByb3ZpZGUgb25lIG9mIHRoZSBzdXBwb3J0ZWQgbW9kZXMgKFwicmVhbFwiLCBcImluZmluaXRlXCIpIG9yIGEgbnVtYmVyIHRvIFwiY3R4LmRlbGF5XCIuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbk9yTW9kZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZGVsYXlUaW1lID0gZ2V0UmFuZG9tU2VydmVyUmVzcG9uc2VUaW1lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkdXJhdGlvbk9yTW9kZSA+IFNFVF9USU1FT1VUX01BWF9BTExPV0VEX0lOVCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBkZWxheSBhIHJlc3BvbnNlOiBwcm92aWRlZCBkZWxheSBkdXJhdGlvbiAoJHtkdXJhdGlvbk9yTW9kZX0pIGV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCBkdXJhdGlvbiBmb3IgXCJzZXRUaW1lb3V0XCIgKCR7U0VUX1RJTUVPVVRfTUFYX0FMTE9XRURfSU5UfSkuIFRoaXMgd2lsbCBjYXVzZSB0aGUgcmVzcG9uc2UgdG8gYmUgcmV0dXJuZWQgaW1tZWRpYXRlbHkuIFBsZWFzZSB1c2UgYSBudW1iZXIgd2l0aGluIHRoZSBhbGxvd2VkIHJhbmdlIHRvIGRlbGF5IHRoZSByZXNwb25zZSBieSBleGFjdCBkdXJhdGlvbiwgb3IgY29uc2lkZXIgdGhlIFwiaW5maW5pdGVcIiBkZWxheSBtb2RlIHRvIGRlbGF5IHRoZSByZXNwb25zZSBpbmRlZmluaXRlbHkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVsYXlUaW1lID0gZHVyYXRpb25Pck1vZGU7XG4gICAgfVxuICAgIHJlcy5kZWxheSA9IGRlbGF5VGltZTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQvZXJyb3JzLnRzXG52YXIgZXJyb3JzID0gKGVycm9yc0xpc3QpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICBpZiAoZXJyb3JzTGlzdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBjb25zdCBwcmV2Qm9keSA9IGpzb25QYXJzZShyZXMuYm9keSkgfHwge307XG4gICAgY29uc3QgbmV4dEJvZHkgPSBtZXJnZVJpZ2h0KHByZXZCb2R5LCB7IGVycm9yczogZXJyb3JzTGlzdCB9KTtcbiAgICByZXR1cm4ganNvbihuZXh0Qm9keSkocmVzKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L2ZldGNoLnRzXG5pbXBvcnQgeyBpc05vZGVQcm9jZXNzIGFzIGlzTm9kZVByb2Nlc3MyIH0gZnJvbSBcImlzLW5vZGUtcHJvY2Vzc1wiO1xuaW1wb3J0IHsgSGVhZGVycyBhcyBIZWFkZXJzMiB9IGZyb20gXCJoZWFkZXJzLXBvbHlmaWxsXCI7XG52YXIgdXNlRmV0Y2ggPSBpc05vZGVQcm9jZXNzMigpID8gKGlucHV0LCBpbml0KSA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IF9fdG9FU00oX19yZXF1aXJlKFwibm9kZS1mZXRjaFwiKSkpLnRoZW4oXG4gICh7IGRlZmF1bHQ6IG5vZGVGZXRjaCB9KSA9PiBub2RlRmV0Y2goaW5wdXQsIGluaXQpXG4pIDogZ2xvYmFsVGhpcy5mZXRjaDtcbnZhciBhdWdtZW50UmVxdWVzdEluaXQgPSAocmVxdWVzdEluaXQpID0+IHtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzMihyZXF1ZXN0SW5pdC5oZWFkZXJzKTtcbiAgaGVhZGVycy5zZXQoXCJ4LW1zdy1ieXBhc3NcIiwgXCJ0cnVlXCIpO1xuICByZXR1cm4ge1xuICAgIC4uLnJlcXVlc3RJbml0LFxuICAgIGhlYWRlcnM6IGhlYWRlcnMuYWxsKClcbiAgfTtcbn07XG52YXIgY3JlYXRlRmV0Y2hSZXF1ZXN0UGFyYW1ldGVycyA9IChpbnB1dCkgPT4ge1xuICBjb25zdCB7IGJvZHk6IGJvZHkyLCBtZXRob2QgfSA9IGlucHV0O1xuICBjb25zdCByZXF1ZXN0UGFyYW1ldGVycyA9IHtcbiAgICAuLi5pbnB1dCxcbiAgICBib2R5OiB2b2lkIDBcbiAgfTtcbiAgaWYgKFtcIkdFVFwiLCBcIkhFQURcIl0uaW5jbHVkZXMobWV0aG9kKSkge1xuICAgIHJldHVybiByZXF1ZXN0UGFyYW1ldGVycztcbiAgfVxuICBpZiAodHlwZW9mIGJvZHkyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBib2R5MiA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgYm9keTIgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmVxdWVzdFBhcmFtZXRlcnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkyKTtcbiAgfSBlbHNlIHtcbiAgICByZXF1ZXN0UGFyYW1ldGVycy5ib2R5ID0gYm9keTI7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3RQYXJhbWV0ZXJzO1xufTtcbnZhciBmZXRjaCA9IChpbnB1dCwgcmVxdWVzdEluaXQgPSB7fSkgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHVzZUZldGNoKGlucHV0LCBhdWdtZW50UmVxdWVzdEluaXQocmVxdWVzdEluaXQpKTtcbiAgfVxuICBjb25zdCByZXF1ZXN0UGFyYW1ldGVycyA9IGNyZWF0ZUZldGNoUmVxdWVzdFBhcmFtZXRlcnMoaW5wdXQpO1xuICBjb25zdCBkZXJpdmVkUmVxdWVzdEluaXQgPSBhdWdtZW50UmVxdWVzdEluaXQocmVxdWVzdFBhcmFtZXRlcnMpO1xuICByZXR1cm4gdXNlRmV0Y2goaW5wdXQudXJsLmhyZWYsIGRlcml2ZWRSZXF1ZXN0SW5pdCk7XG59O1xuXG4vLyBzcmMvY29udGV4dC90ZXh0LnRzXG52YXIgdGV4dCA9IChib2R5MikgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIHJlcy5oZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQvcGxhaW5cIik7XG4gICAgcmVzLmJvZHkgPSBib2R5MjtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQveG1sLnRzXG52YXIgeG1sID0gKGJvZHkyKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgcmVzLmhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwidGV4dC94bWxcIik7XG4gICAgcmVzLmJvZHkgPSBib2R5MjtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLy8gc3JjL3V0aWxzL2xvZ2dpbmcvZ2V0U3RhdHVzQ29kZUNvbG9yLnRzXG5mdW5jdGlvbiBnZXRTdGF0dXNDb2RlQ29sb3Ioc3RhdHVzMikge1xuICBpZiAoc3RhdHVzMiA8IDMwMCkge1xuICAgIHJldHVybiBcIiM2OUFCMzJcIiAvKiBTdWNjZXNzICovO1xuICB9XG4gIGlmIChzdGF0dXMyIDwgNDAwKSB7XG4gICAgcmV0dXJuIFwiI0YwQkI0QlwiIC8qIFdhcm5pbmcgKi87XG4gIH1cbiAgcmV0dXJuIFwiI0U5NUY1RFwiIC8qIERhbmdlciAqLztcbn1cblxuLy8gc3JjL3V0aWxzL2xvZ2dpbmcvZ2V0VGltZXN0YW1wLnRzXG5mdW5jdGlvbiBnZXRUaW1lc3RhbXAoKSB7XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gIHJldHVybiBbbm93LmdldEhvdXJzKCksIG5vdy5nZXRNaW51dGVzKCksIG5vdy5nZXRTZWNvbmRzKCldLm1hcChTdHJpbmcpLm1hcCgoY2h1bmspID0+IGNodW5rLnNsaWNlKDAsIDIpKS5tYXAoKGNodW5rKSA9PiBjaHVuay5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCI6XCIpO1xufVxuXG4vLyBzcmMvdXRpbHMvbG9nZ2luZy9wcmVwYXJlUmVxdWVzdC50c1xuZnVuY3Rpb24gcHJlcGFyZVJlcXVlc3QocmVxdWVzdCkge1xuICByZXR1cm4ge1xuICAgIC4uLnJlcXVlc3QsXG4gICAgYm9keTogcmVxdWVzdC5ib2R5LFxuICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycy5hbGwoKVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMvbG9nZ2luZy9wcmVwYXJlUmVzcG9uc2UudHNcbmltcG9ydCB7IG9iamVjdFRvSGVhZGVycyBhcyBvYmplY3RUb0hlYWRlcnMyIH0gZnJvbSBcImhlYWRlcnMtcG9seWZpbGxcIjtcbmZ1bmN0aW9uIHByZXBhcmVSZXNwb25zZShyZXMpIHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gb2JqZWN0VG9IZWFkZXJzMihyZXMuaGVhZGVycyk7XG4gIGNvbnN0IHBhcnNlZEJvZHkgPSBwYXJzZUJvZHkocmVzLmJvZHksIHJlc3BvbnNlSGVhZGVycyk7XG4gIHJldHVybiB7XG4gICAgLi4ucmVzLFxuICAgIGJvZHk6IHBhcnNlZEJvZHlcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL21hdGNoaW5nL21hdGNoUmVxdWVzdFVybC50c1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwicGF0aC10by1yZWdleHBcIjtcbmltcG9ydCB7IGdldENsZWFuVXJsIH0gZnJvbSBcIkBtc3dqcy9pbnRlcmNlcHRvcnMvbGliL3V0aWxzL2dldENsZWFuVXJsLmpzXCI7XG5cbi8vIHNyYy91dGlscy91cmwvY2xlYW5VcmwudHNcbnZhciBSRURVTkRBTlRfQ0hBUkFDVEVSU19FWFAgPSAvW1xcP3wjXS4qJC9nO1xuZnVuY3Rpb24gZ2V0U2VhcmNoUGFyYW1zKHBhdGgpIHtcbiAgcmV0dXJuIG5ldyBVUkwoYC8ke3BhdGh9YCwgXCJodHRwOi8vbG9jYWxob3N0XCIpLnNlYXJjaFBhcmFtcztcbn1cbmZ1bmN0aW9uIGNsZWFuVXJsKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZShSRURVTkRBTlRfQ0hBUkFDVEVSU19FWFAsIFwiXCIpO1xufVxuXG4vLyBzcmMvdXRpbHMvdXJsL2lzQWJzb2x1dGVVcmwudHNcbmZ1bmN0aW9uIGlzQWJzb2x1dGVVcmwodXJsKSB7XG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn1cblxuLy8gc3JjL3V0aWxzL3VybC9nZXRBYnNvbHV0ZVVybC50c1xuZnVuY3Rpb24gZ2V0QWJzb2x1dGVVcmwocGF0aCwgYmFzZVVybCkge1xuICBpZiAoaXNBYnNvbHV0ZVVybChwYXRoKSkge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCIqXCIpKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgY29uc3Qgb3JpZ2luID0gYmFzZVVybCB8fCB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuYmFzZVVSSTtcbiAgcmV0dXJuIG9yaWdpbiA/IGRlY29kZVVSSShuZXcgVVJMKGVuY29kZVVSSShwYXRoKSwgb3JpZ2luKS5ocmVmKSA6IHBhdGg7XG59XG5cbi8vIHNyYy91dGlscy9tYXRjaGluZy9ub3JtYWxpemVQYXRoLnRzXG5mdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhdGgsIGJhc2VVcmwpIHtcbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBjb25zdCBtYXliZUFic29sdXRlVXJsID0gZ2V0QWJzb2x1dGVVcmwocGF0aCwgYmFzZVVybCk7XG4gIHJldHVybiBjbGVhblVybChtYXliZUFic29sdXRlVXJsKTtcbn1cblxuLy8gc3JjL3V0aWxzL21hdGNoaW5nL21hdGNoUmVxdWVzdFVybC50c1xuZnVuY3Rpb24gY29lcmNlUGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoXG4gICAgLyhbOmEtekEtWl8tXSopKFxcKnsxLDJ9KSsvZyxcbiAgICAoXywgcGFyYW1ldGVyTmFtZSwgd2lsZGNhcmQpID0+IHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBcIiguKilcIjtcbiAgICAgIGlmICghcGFyYW1ldGVyTmFtZSkge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbWV0ZXJOYW1lLnN0YXJ0c1dpdGgoXCI6XCIpID8gYCR7cGFyYW1ldGVyTmFtZX0ke3dpbGRjYXJkfWAgOiBgJHtwYXJhbWV0ZXJOYW1lfSR7ZXhwcmVzc2lvbn1gO1xuICAgIH1cbiAgKS5yZXBsYWNlKC8oW15cXC9dKSg6KSg/PVxcZCspLywgXCIkMVxcXFwkMlwiKS5yZXBsYWNlKC9eKFteXFwvXSspKDopKD89XFwvXFwvKS8sIFwiJDFcXFxcJDJcIik7XG59XG5mdW5jdGlvbiBtYXRjaFJlcXVlc3RVcmwodXJsLCBwYXRoLCBiYXNlVXJsKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplUGF0aChwYXRoLCBiYXNlVXJsKTtcbiAgY29uc3QgY2xlYW5QYXRoID0gdHlwZW9mIG5vcm1hbGl6ZWRQYXRoID09PSBcInN0cmluZ1wiID8gY29lcmNlUGF0aChub3JtYWxpemVkUGF0aCkgOiBub3JtYWxpemVkUGF0aDtcbiAgY29uc3QgY2xlYW5VcmwyID0gZ2V0Q2xlYW5VcmwodXJsKTtcbiAgY29uc3QgcmVzdWx0ID0gbWF0Y2goY2xlYW5QYXRoLCB7IGRlY29kZTogZGVjb2RlVVJJQ29tcG9uZW50IH0pKGNsZWFuVXJsMik7XG4gIGNvbnN0IHBhcmFtcyA9IHJlc3VsdCAmJiByZXN1bHQucGFyYW1zIHx8IHt9O1xuICByZXR1cm4ge1xuICAgIG1hdGNoZXM6IHJlc3VsdCAhPT0gZmFsc2UsXG4gICAgcGFyYW1zXG4gIH07XG59XG5cbi8vIHNyYy9oYW5kbGVycy9SZXF1ZXN0SGFuZGxlci50c1xuaW1wb3J0IHsgSGVhZGVycyBhcyBIZWFkZXJzNCB9IGZyb20gXCJoZWFkZXJzLXBvbHlmaWxsXCI7XG5cbi8vIHNyYy9yZXNwb25zZS50c1xuaW1wb3J0IHsgSGVhZGVycyBhcyBIZWFkZXJzMyB9IGZyb20gXCJoZWFkZXJzLXBvbHlmaWxsXCI7XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9jb21wb3NlLnRzXG5mdW5jdGlvbiBjb21wb3NlKC4uLmZucykge1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gZm5zLnJlZHVjZVJpZ2h0KChsZWZ0Rm4sIHJpZ2h0Rm4pID0+IHtcbiAgICAgIHJldHVybiBsZWZ0Rm4gaW5zdGFuY2VvZiBQcm9taXNlID8gUHJvbWlzZS5yZXNvbHZlKGxlZnRGbikudGhlbihyaWdodEZuKSA6IHJpZ2h0Rm4obGVmdEZuKTtcbiAgICB9LCBhcmdzWzBdKTtcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL05ldHdvcmtFcnJvci50c1xudmFyIE5ldHdvcmtFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJOZXR3b3JrRXJyb3JcIjtcbiAgfVxufTtcblxuLy8gc3JjL3Jlc3BvbnNlLnRzXG52YXIgZGVmYXVsdFJlc3BvbnNlID0ge1xuICBzdGF0dXM6IDIwMCxcbiAgc3RhdHVzVGV4dDogXCJPS1wiLFxuICBib2R5OiBudWxsLFxuICBkZWxheTogMCxcbiAgb25jZTogZmFsc2UsXG4gIHBhc3N0aHJvdWdoOiBmYWxzZVxufTtcbnZhciBkZWZhdWx0UmVzcG9uc2VUcmFuc2Zvcm1lcnMgPSBbXTtcbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlQ29tcG9zaXRpb24ocmVzcG9uc2VPdmVycmlkZXMsIGRlZmF1bHRUcmFuc2Zvcm1lcnMgPSBkZWZhdWx0UmVzcG9uc2VUcmFuc2Zvcm1lcnMpIHtcbiAgcmV0dXJuIGFzeW5jICguLi50cmFuc2Zvcm1lcnMpID0+IHtcbiAgICBjb25zdCBpbml0aWFsUmVzcG9uc2UgPSBPYmplY3QuYXNzaWduKFxuICAgICAge30sXG4gICAgICBkZWZhdWx0UmVzcG9uc2UsXG4gICAgICB7XG4gICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzMyh7XG4gICAgICAgICAgXCJ4LXBvd2VyZWQtYnlcIjogXCJtc3dcIlxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNlT3ZlcnJpZGVzXG4gICAgKTtcbiAgICBjb25zdCByZXNvbHZlZFRyYW5zZm9ybWVycyA9IFtcbiAgICAgIC4uLmRlZmF1bHRUcmFuc2Zvcm1lcnMsXG4gICAgICAuLi50cmFuc2Zvcm1lcnNcbiAgICBdLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCByZXNvbHZlZFJlc3BvbnNlID0gcmVzb2x2ZWRUcmFuc2Zvcm1lcnMubGVuZ3RoID4gMCA/IGNvbXBvc2UoLi4ucmVzb2x2ZWRUcmFuc2Zvcm1lcnMpKGluaXRpYWxSZXNwb25zZSkgOiBpbml0aWFsUmVzcG9uc2U7XG4gICAgcmV0dXJuIHJlc29sdmVkUmVzcG9uc2U7XG4gIH07XG59XG52YXIgcmVzcG9uc2UgPSBPYmplY3QuYXNzaWduKGNyZWF0ZVJlc3BvbnNlQ29tcG9zaXRpb24oKSwge1xuICBvbmNlOiBjcmVhdGVSZXNwb25zZUNvbXBvc2l0aW9uKHsgb25jZTogdHJ1ZSB9KSxcbiAgbmV0d29ya0Vycm9yKG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKG1lc3NhZ2UpO1xuICB9XG59KTtcblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL2dldENhbGxGcmFtZS50c1xudmFyIFNPVVJDRV9GUkFNRSA9IC9bXFwvXFxcXF1tc3dbXFwvXFxcXF1zcmNbXFwvXFxcXF0oLispLztcbnZhciBCVUlMRF9GUkFNRSA9IC8obm9kZV9tb2R1bGVzKT9bXFwvXFxcXF1saWJbXFwvXFxcXF0odW1kfGVzbXxpaWVmfGNqcylbXFwvXFxcXF18XlteXFwvXFxcXF0qJC87XG5mdW5jdGlvbiBnZXRDYWxsRnJhbWUoZXJyb3IyKSB7XG4gIGNvbnN0IHN0YWNrID0gZXJyb3IyLnN0YWNrO1xuICBpZiAoIXN0YWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZyYW1lcyA9IHN0YWNrLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDEpO1xuICBjb25zdCBkZWNsYXJhdGlvbkZyYW1lID0gZnJhbWVzLmZpbmQoKGZyYW1lKSA9PiB7XG4gICAgcmV0dXJuICEoU09VUkNFX0ZSQU1FLnRlc3QoZnJhbWUpIHx8IEJVSUxEX0ZSQU1FLnRlc3QoZnJhbWUpKTtcbiAgfSk7XG4gIGlmICghZGVjbGFyYXRpb25GcmFtZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkZWNsYXJhdGlvblBhdGggPSBkZWNsYXJhdGlvbkZyYW1lLnJlcGxhY2UoL1xccyphdCBbXigpXSpcXCgoW14pXSspXFwpLywgXCIkMVwiKS5yZXBsYWNlKC9eQC8sIFwiXCIpO1xuICByZXR1cm4gZGVjbGFyYXRpb25QYXRoO1xufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvaXNJdGVyYWJsZS50c1xuZnVuY3Rpb24gaXNJdGVyYWJsZShmbikge1xuICBpZiAoIWZuKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgZm5bU3ltYm9sLml0ZXJhdG9yXSA9PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8vIHNyYy9oYW5kbGVycy9SZXF1ZXN0SGFuZGxlci50c1xudmFyIGRlZmF1bHRDb250ZXh0ID0ge1xuICBzdGF0dXMsXG4gIHNldCxcbiAgZGVsYXksXG4gIGZldGNoXG59O1xudmFyIFJlcXVlc3RIYW5kbGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5zaG91bGRTa2lwID0gZmFsc2U7XG4gICAgdGhpcy5jdHggPSBvcHRpb25zLmN0eCB8fCBkZWZhdWx0Q29udGV4dDtcbiAgICB0aGlzLnJlc29sdmVyID0gb3B0aW9ucy5yZXNvbHZlcjtcbiAgICBjb25zdCBjYWxsRnJhbWUgPSBnZXRDYWxsRnJhbWUobmV3IEVycm9yKCkpO1xuICAgIHRoaXMuaW5mbyA9IHtcbiAgICAgIC4uLm9wdGlvbnMuaW5mbyxcbiAgICAgIGNhbGxGcmFtZVxuICAgIH07XG4gIH1cbiAgcGFyc2UoX3JlcXVlc3QsIF9yZXNvbHV0aW9uQ29udGV4dCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRlc3QocmVxdWVzdCwgcmVzb2x1dGlvbkNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGhpcy5wYXJzZShyZXF1ZXN0LCByZXNvbHV0aW9uQ29udGV4dCksXG4gICAgICByZXNvbHV0aW9uQ29udGV4dFxuICAgICk7XG4gIH1cbiAgZ2V0UHVibGljUmVxdWVzdChyZXF1ZXN0LCBfcGFyc2VkUmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cbiAgbWFya0FzU2tpcHBlZChzaG91bGRTa2lwID0gdHJ1ZSkge1xuICAgIHRoaXMuc2hvdWxkU2tpcCA9IHNob3VsZFNraXA7XG4gIH1cbiAgYXN5bmMgcnVuKHJlcXVlc3QsIHJlc29sdXRpb25Db250ZXh0KSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkU2tpcCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFJlc3VsdCA9IHRoaXMucGFyc2UocmVxdWVzdCwgcmVzb2x1dGlvbkNvbnRleHQpO1xuICAgIGNvbnN0IHNob3VsZEludGVyY2VwdCA9IHRoaXMucHJlZGljYXRlKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHBhcnNlZFJlc3VsdCxcbiAgICAgIHJlc29sdXRpb25Db250ZXh0XG4gICAgKTtcbiAgICBpZiAoIXNob3VsZEludGVyY2VwdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY1JlcXVlc3QgPSB0aGlzLmdldFB1YmxpY1JlcXVlc3QocmVxdWVzdCwgcGFyc2VkUmVzdWx0KTtcbiAgICBjb25zdCBleGVjdXRlUmVzb2x2ZXIgPSB0aGlzLndyYXBSZXNvbHZlcih0aGlzLnJlc29sdmVyKTtcbiAgICBjb25zdCBtb2NrZWRSZXNwb25zZSA9IGF3YWl0IGV4ZWN1dGVSZXNvbHZlcihcbiAgICAgIHB1YmxpY1JlcXVlc3QsXG4gICAgICByZXNwb25zZSxcbiAgICAgIHRoaXMuY3R4XG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVFeGVjdXRpb25SZXN1bHQoXG4gICAgICBwYXJzZWRSZXN1bHQsXG4gICAgICBwdWJsaWNSZXF1ZXN0LFxuICAgICAgbW9ja2VkUmVzcG9uc2VcbiAgICApO1xuICB9XG4gIHdyYXBSZXNvbHZlcihyZXNvbHZlcikge1xuICAgIHJldHVybiBhc3luYyAocmVxLCByZXMsIGN0eCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXNvbHZlckdlbmVyYXRvciB8fCBhd2FpdCByZXNvbHZlcihyZXEsIHJlcywgY3R4KTtcbiAgICAgIGlmIChpc0l0ZXJhYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gcmVzdWx0W1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCk7XG4gICAgICAgIGNvbnN0IG5leHRSZXNwb25zZSA9IGF3YWl0IHZhbHVlO1xuICAgICAgICBpZiAoIW5leHRSZXNwb25zZSAmJiBkb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZXJHZW5lcmF0b3JSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJlc29sdmVyR2VuZXJhdG9yKSB7XG4gICAgICAgICAgdGhpcy5yZXNvbHZlckdlbmVyYXRvciA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc29sdmVyR2VuZXJhdG9yUmVzdWx0ID0gbmV4dFJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gbmV4dFJlc3BvbnNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG4gIGNyZWF0ZUV4ZWN1dGlvblJlc3VsdChwYXJzZWRSZXN1bHQsIHJlcXVlc3QsIHJlc3BvbnNlMikge1xuICAgIHJldHVybiB7XG4gICAgICBoYW5kbGVyOiB0aGlzLFxuICAgICAgcGFyc2VkUmVzdWx0OiBwYXJzZWRSZXN1bHQgfHwgbnVsbCxcbiAgICAgIHJlcXVlc3QsXG4gICAgICByZXNwb25zZTogcmVzcG9uc2UyIHx8IG51bGxcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvaGFuZGxlcnMvUmVzdEhhbmRsZXIudHNcbnZhciByZXN0Q29udGV4dCA9IHtcbiAgLi4uZGVmYXVsdENvbnRleHQsXG4gIGNvb2tpZSxcbiAgYm9keSxcbiAgdGV4dCxcbiAganNvbixcbiAgeG1sXG59O1xudmFyIFJlc3RSZXF1ZXN0ID0gY2xhc3MgZXh0ZW5kcyBNb2NrZWRSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IocmVxdWVzdCwgcGFyYW1zKSB7XG4gICAgc3VwZXIocmVxdWVzdC51cmwsIHtcbiAgICAgIC4uLnJlcXVlc3QsXG4gICAgICBib2R5OiByZXF1ZXN0W1wiX2JvZHlcIl1cbiAgICB9KTtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLmlkID0gcmVxdWVzdC5pZDtcbiAgfVxufTtcbnZhciBSZXN0SGFuZGxlciA9IGNsYXNzIGV4dGVuZHMgUmVxdWVzdEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihtZXRob2QsIHBhdGgsIHJlc29sdmVyKSB7XG4gICAgc3VwZXIoe1xuICAgICAgaW5mbzoge1xuICAgICAgICBoZWFkZXI6IGAke21ldGhvZH0gJHtwYXRofWAsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG1ldGhvZFxuICAgICAgfSxcbiAgICAgIGN0eDogcmVzdENvbnRleHQsXG4gICAgICByZXNvbHZlclxuICAgIH0pO1xuICAgIHRoaXMuY2hlY2tSZWR1bmRhbnRRdWVyeVBhcmFtZXRlcnMoKTtcbiAgfVxuICBjaGVja1JlZHVuZGFudFF1ZXJ5UGFyYW1ldGVycygpIHtcbiAgICBjb25zdCB7IG1ldGhvZCwgcGF0aCB9ID0gdGhpcy5pbmZvO1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGNsZWFuVXJsKHBhdGgpO1xuICAgIGlmICh1cmwgPT09IHBhdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gZ2V0U2VhcmNoUGFyYW1zKHBhdGgpO1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gW107XG4gICAgc2VhcmNoUGFyYW1zLmZvckVhY2goKF8sIHBhcmFtTmFtZSkgPT4ge1xuICAgICAgcXVlcnlQYXJhbXMucHVzaChwYXJhbU5hbWUpO1xuICAgIH0pO1xuICAgIGRldlV0aWxzLndhcm4oXG4gICAgICBgRm91bmQgYSByZWR1bmRhbnQgdXNhZ2Ugb2YgcXVlcnkgcGFyYW1ldGVycyBpbiB0aGUgcmVxdWVzdCBoYW5kbGVyIFVSTCBmb3IgXCIke21ldGhvZH0gJHtwYXRofVwiLiBQbGVhc2UgbWF0Y2ggYWdhaW5zdCBhIHBhdGggaW5zdGVhZCBhbmQgYWNjZXNzIHF1ZXJ5IHBhcmFtZXRlcnMgaW4gdGhlIHJlc3BvbnNlIHJlc29sdmVyIGZ1bmN0aW9uIHVzaW5nIFwicmVxLnVybC5zZWFyY2hQYXJhbXNcIi5gXG4gICAgKTtcbiAgfVxuICBwYXJzZShyZXF1ZXN0LCByZXNvbHV0aW9uQ29udGV4dCkge1xuICAgIHJldHVybiBtYXRjaFJlcXVlc3RVcmwoXG4gICAgICByZXF1ZXN0LnVybCxcbiAgICAgIHRoaXMuaW5mby5wYXRoLFxuICAgICAgcmVzb2x1dGlvbkNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc29sdXRpb25Db250ZXh0LmJhc2VVcmxcbiAgICApO1xuICB9XG4gIGdldFB1YmxpY1JlcXVlc3QocmVxdWVzdCwgcGFyc2VkUmVzdWx0KSB7XG4gICAgcmV0dXJuIG5ldyBSZXN0UmVxdWVzdChyZXF1ZXN0LCBwYXJzZWRSZXN1bHQucGFyYW1zIHx8IHt9KTtcbiAgfVxuICBwcmVkaWNhdGUocmVxdWVzdCwgcGFyc2VkUmVzdWx0KSB7XG4gICAgY29uc3QgbWF0Y2hlc01ldGhvZCA9IHRoaXMuaW5mby5tZXRob2QgaW5zdGFuY2VvZiBSZWdFeHAgPyB0aGlzLmluZm8ubWV0aG9kLnRlc3QocmVxdWVzdC5tZXRob2QpIDogaXNTdHJpbmdFcXVhbCh0aGlzLmluZm8ubWV0aG9kLCByZXF1ZXN0Lm1ldGhvZCk7XG4gICAgcmV0dXJuIG1hdGNoZXNNZXRob2QgJiYgcGFyc2VkUmVzdWx0Lm1hdGNoZXM7XG4gIH1cbiAgbG9nKHJlcXVlc3QsIHJlc3BvbnNlMikge1xuICAgIGNvbnN0IHB1YmxpY1VybCA9IGdldFB1YmxpY1VybEZyb21SZXF1ZXN0KHJlcXVlc3QpO1xuICAgIGNvbnN0IGxvZ2dlZFJlcXVlc3QgPSBwcmVwYXJlUmVxdWVzdChyZXF1ZXN0KTtcbiAgICBjb25zdCBsb2dnZWRSZXNwb25zZSA9IHByZXBhcmVSZXNwb25zZShyZXNwb25zZTIpO1xuICAgIGNvbnN0IHN0YXR1c0NvbG9yID0gZ2V0U3RhdHVzQ29kZUNvbG9yKHJlc3BvbnNlMi5zdGF0dXMpO1xuICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXG4gICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFwiJXMgJXMgJXMgKCVjJXMlYylcIiksXG4gICAgICBnZXRUaW1lc3RhbXAoKSxcbiAgICAgIHJlcXVlc3QubWV0aG9kLFxuICAgICAgcHVibGljVXJsLFxuICAgICAgYGNvbG9yOiR7c3RhdHVzQ29sb3J9YCxcbiAgICAgIGAke3Jlc3BvbnNlMi5zdGF0dXN9ICR7cmVzcG9uc2UyLnN0YXR1c1RleHR9YCxcbiAgICAgIFwiY29sb3I6aW5oZXJpdFwiXG4gICAgKTtcbiAgICBjb25zb2xlLmxvZyhcIlJlcXVlc3RcIiwgbG9nZ2VkUmVxdWVzdCk7XG4gICAgY29uc29sZS5sb2coXCJIYW5kbGVyOlwiLCB0aGlzKTtcbiAgICBjb25zb2xlLmxvZyhcIlJlc3BvbnNlXCIsIGxvZ2dlZFJlc3BvbnNlKTtcbiAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb250ZXh0L2ZpZWxkLnRzXG5pbXBvcnQgeyBpbnZhcmlhbnQgYXMgaW52YXJpYW50MiB9IGZyb20gXCJvdXR2YXJpYW50XCI7XG52YXIgZmllbGQgPSAoZmllbGROYW1lLCBmaWVsZFZhbHVlKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgdmFsaWRhdGVGaWVsZE5hbWUoZmllbGROYW1lKTtcbiAgICBjb25zdCBwcmV2Qm9keSA9IGpzb25QYXJzZShyZXMuYm9keSkgfHwge307XG4gICAgY29uc3QgbmV4dEJvZHkgPSBtZXJnZVJpZ2h0KHByZXZCb2R5LCB7IFtmaWVsZE5hbWVdOiBmaWVsZFZhbHVlIH0pO1xuICAgIHJldHVybiBqc29uKG5leHRCb2R5KShyZXMpO1xuICB9O1xufTtcbmZ1bmN0aW9uIHZhbGlkYXRlRmllbGROYW1lKGZpZWxkTmFtZSkge1xuICBpbnZhcmlhbnQyKFxuICAgIGZpZWxkTmFtZS50cmltKCkgIT09IFwiXCIsXG4gICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgIFwiRmFpbGVkIHRvIHNldCBhIGN1c3RvbSBmaWVsZCBvbiBhIEdyYXBoUUwgcmVzcG9uc2U6IGZpZWxkIG5hbWUgY2Fubm90IGJlIGVtcHR5LlwiXG4gICAgKVxuICApO1xuICBpbnZhcmlhbnQyKFxuICAgIGZpZWxkTmFtZSAhPT0gXCJkYXRhXCIsXG4gICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICdGYWlsZWQgdG8gc2V0IGEgY3VzdG9tIFwiJXNcIiBmaWVsZCBvbiBhIG1vY2tlZCBHcmFwaFFMIHJlc3BvbnNlOiBmb3JiaWRkZW4gZmllbGQgbmFtZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgXCJjdHguZGF0YSgpXCIgaW5zdGVhZD8nLFxuICAgICAgZmllbGROYW1lXG4gICAgKVxuICApO1xuICBpbnZhcmlhbnQyKFxuICAgIGZpZWxkTmFtZSAhPT0gXCJlcnJvcnNcIixcbiAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgJ0ZhaWxlZCB0byBzZXQgYSBjdXN0b20gXCIlc1wiIGZpZWxkIG9uIGEgbW9ja2VkIEdyYXBoUUwgcmVzcG9uc2U6IGZvcmJpZGRlbiBmaWVsZCBuYW1lLiBEaWQgeW91IG1lYW4gdG8gY2FsbCBcImN0eC5lcnJvcnMoKVwiIGluc3RlYWQ/JyxcbiAgICAgIGZpZWxkTmFtZVxuICAgIClcbiAgKTtcbiAgaW52YXJpYW50MihcbiAgICBmaWVsZE5hbWUgIT09IFwiZXh0ZW5zaW9uc1wiLFxuICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAnRmFpbGVkIHRvIHNldCBhIGN1c3RvbSBcIiVzXCIgZmllbGQgb24gYSBtb2NrZWQgR3JhcGhRTCByZXNwb25zZTogZm9yYmlkZGVuIGZpZWxkIG5hbWUuIERpZCB5b3UgbWVhbiB0byBjYWxsIFwiY3R4LmV4dGVuc2lvbnMoKVwiIGluc3RlYWQ/JyxcbiAgICAgIGZpZWxkTmFtZVxuICAgIClcbiAgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL3RyeUNhdGNoLnRzXG5mdW5jdGlvbiB0cnlDYXRjaChmbiwgb25FeGNlcHRpb24pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBmbigpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yMikge1xuICAgIG9uRXhjZXB0aW9uID09IG51bGwgPyB2b2lkIDAgOiBvbkV4Y2VwdGlvbihlcnJvcjIpO1xuICB9XG59XG5cbi8vIHNyYy9oYW5kbGVycy9HcmFwaFFMSGFuZGxlci50c1xudmFyIGdyYXBocWxDb250ZXh0ID0ge1xuICAuLi5kZWZhdWx0Q29udGV4dCxcbiAgZGF0YSxcbiAgZXh0ZW5zaW9ucyxcbiAgZXJyb3JzLFxuICBjb29raWUsXG4gIGZpZWxkXG59O1xuZnVuY3Rpb24gaXNEb2N1bWVudE5vZGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBcImtpbmRcIiBpbiB2YWx1ZSAmJiBcImRlZmluaXRpb25zXCIgaW4gdmFsdWU7XG59XG52YXIgR3JhcGhRTFJlcXVlc3QgPSBjbGFzcyBleHRlbmRzIE1vY2tlZFJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvcihyZXF1ZXN0LCB2YXJpYWJsZXMsIG9wZXJhdGlvbk5hbWUpIHtcbiAgICBzdXBlcihyZXF1ZXN0LnVybCwge1xuICAgICAgLi4ucmVxdWVzdCxcbiAgICAgIGJvZHk6IHJlcXVlc3RbXCJfYm9keVwiXVxuICAgIH0pO1xuICAgIHRoaXMudmFyaWFibGVzID0gdmFyaWFibGVzO1xuICAgIHRoaXMub3BlcmF0aW9uTmFtZSA9IG9wZXJhdGlvbk5hbWU7XG4gIH1cbn07XG52YXIgR3JhcGhRTEhhbmRsZXIgPSBjbGFzcyBleHRlbmRzIFJlcXVlc3RIYW5kbGVyIHtcbiAgY29uc3RydWN0b3Iob3BlcmF0aW9uVHlwZSwgb3BlcmF0aW9uTmFtZSwgZW5kcG9pbnQsIHJlc29sdmVyKSB7XG4gICAgbGV0IHJlc29sdmVkT3BlcmF0aW9uTmFtZSA9IG9wZXJhdGlvbk5hbWU7XG4gICAgaWYgKGlzRG9jdW1lbnROb2RlKG9wZXJhdGlvbk5hbWUpKSB7XG4gICAgICBjb25zdCBwYXJzZWROb2RlID0gcGFyc2VEb2N1bWVudE5vZGUob3BlcmF0aW9uTmFtZSk7XG4gICAgICBpZiAocGFyc2VkTm9kZS5vcGVyYXRpb25UeXBlICE9PSBvcGVyYXRpb25UeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRmFpbGVkIHRvIGNyZWF0ZSBhIEdyYXBoUUwgaGFuZGxlcjogcHJvdmlkZWQgYSBEb2N1bWVudE5vZGUgd2l0aCBhIG1pc21hdGNoZWQgb3BlcmF0aW9uIHR5cGUgKGV4cGVjdGVkIFwiJHtvcGVyYXRpb25UeXBlfVwiLCBidXQgZ290IFwiJHtwYXJzZWROb2RlLm9wZXJhdGlvblR5cGV9XCIpLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghcGFyc2VkTm9kZS5vcGVyYXRpb25OYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRmFpbGVkIHRvIGNyZWF0ZSBhIEdyYXBoUUwgaGFuZGxlcjogcHJvdmlkZWQgYSBEb2N1bWVudE5vZGUgd2l0aCBubyBvcGVyYXRpb24gbmFtZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXNvbHZlZE9wZXJhdGlvbk5hbWUgPSBwYXJzZWROb2RlLm9wZXJhdGlvbk5hbWU7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlciA9IG9wZXJhdGlvblR5cGUgPT09IFwiYWxsXCIgPyBgJHtvcGVyYXRpb25UeXBlfSAob3JpZ2luOiAke2VuZHBvaW50LnRvU3RyaW5nKCl9KWAgOiBgJHtvcGVyYXRpb25UeXBlfSAke3Jlc29sdmVkT3BlcmF0aW9uTmFtZX0gKG9yaWdpbjogJHtlbmRwb2ludC50b1N0cmluZygpfSlgO1xuICAgIHN1cGVyKHtcbiAgICAgIGluZm86IHtcbiAgICAgICAgaGVhZGVyLFxuICAgICAgICBvcGVyYXRpb25UeXBlLFxuICAgICAgICBvcGVyYXRpb25OYW1lOiByZXNvbHZlZE9wZXJhdGlvbk5hbWVcbiAgICAgIH0sXG4gICAgICBjdHg6IGdyYXBocWxDb250ZXh0LFxuICAgICAgcmVzb2x2ZXJcbiAgICB9KTtcbiAgICB0aGlzLmVuZHBvaW50ID0gZW5kcG9pbnQ7XG4gIH1cbiAgcGFyc2UocmVxdWVzdCkge1xuICAgIHJldHVybiB0cnlDYXRjaChcbiAgICAgICgpID0+IHBhcnNlR3JhcGhRTFJlcXVlc3QocmVxdWVzdCksXG4gICAgICAoZXJyb3IyKSA9PiBjb25zb2xlLmVycm9yKGVycm9yMi5tZXNzYWdlKVxuICAgICk7XG4gIH1cbiAgZ2V0UHVibGljUmVxdWVzdChyZXF1ZXN0LCBwYXJzZWRSZXN1bHQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBuZXcgR3JhcGhRTFJlcXVlc3QoXG4gICAgICByZXF1ZXN0LFxuICAgICAgKF9hID0gcGFyc2VkUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRSZXN1bHQudmFyaWFibGVzKSAhPSBudWxsID8gX2EgOiB7fSxcbiAgICAgIChfYiA9IHBhcnNlZFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkUmVzdWx0Lm9wZXJhdGlvbk5hbWUpICE9IG51bGwgPyBfYiA6IFwiXCJcbiAgICApO1xuICB9XG4gIHByZWRpY2F0ZShyZXF1ZXN0LCBwYXJzZWRSZXN1bHQpIHtcbiAgICBpZiAoIXBhcnNlZFJlc3VsdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXBhcnNlZFJlc3VsdC5vcGVyYXRpb25OYW1lICYmIHRoaXMuaW5mby5vcGVyYXRpb25UeXBlICE9PSBcImFsbFwiKSB7XG4gICAgICBjb25zdCBwdWJsaWNVcmwgPSBnZXRQdWJsaWNVcmxGcm9tUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgIGRldlV0aWxzLndhcm4oYEZhaWxlZCB0byBpbnRlcmNlcHQgYSBHcmFwaFFMIHJlcXVlc3QgYXQgXCIke3JlcXVlc3QubWV0aG9kfSAke3B1YmxpY1VybH1cIjogYW5vbnltb3VzIEdyYXBoUUwgb3BlcmF0aW9ucyBhcmUgbm90IHN1cHBvcnRlZC5cblxuQ29uc2lkZXIgbmFtaW5nIHRoaXMgb3BlcmF0aW9uIG9yIHVzaW5nIFwiZ3JhcGhxbC5vcGVyYXRpb24oKVwiIHJlcXVlc3QgaGFuZGxlciB0byBpbnRlcmNlcHQgR3JhcGhRTCByZXF1ZXN0cyByZWdhcmRsZXNzIG9mIHRoZWlyIG9wZXJhdGlvbiBuYW1lL3R5cGUuIFJlYWQgbW9yZTogaHR0cHM6Ly9tc3dqcy5pby9kb2NzL2FwaS9ncmFwaHFsL29wZXJhdGlvbiAgICAgIGApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBoYXNNYXRjaGluZ1VybCA9IG1hdGNoUmVxdWVzdFVybChyZXF1ZXN0LnVybCwgdGhpcy5lbmRwb2ludCk7XG4gICAgY29uc3QgaGFzTWF0Y2hpbmdPcGVyYXRpb25UeXBlID0gdGhpcy5pbmZvLm9wZXJhdGlvblR5cGUgPT09IFwiYWxsXCIgfHwgcGFyc2VkUmVzdWx0Lm9wZXJhdGlvblR5cGUgPT09IHRoaXMuaW5mby5vcGVyYXRpb25UeXBlO1xuICAgIGNvbnN0IGhhc01hdGNoaW5nT3BlcmF0aW9uTmFtZSA9IHRoaXMuaW5mby5vcGVyYXRpb25OYW1lIGluc3RhbmNlb2YgUmVnRXhwID8gdGhpcy5pbmZvLm9wZXJhdGlvbk5hbWUudGVzdChwYXJzZWRSZXN1bHQub3BlcmF0aW9uTmFtZSB8fCBcIlwiKSA6IHBhcnNlZFJlc3VsdC5vcGVyYXRpb25OYW1lID09PSB0aGlzLmluZm8ub3BlcmF0aW9uTmFtZTtcbiAgICByZXR1cm4gaGFzTWF0Y2hpbmdVcmwubWF0Y2hlcyAmJiBoYXNNYXRjaGluZ09wZXJhdGlvblR5cGUgJiYgaGFzTWF0Y2hpbmdPcGVyYXRpb25OYW1lO1xuICB9XG4gIGxvZyhyZXF1ZXN0LCByZXNwb25zZTIsIHBhcnNlZFJlcXVlc3QpIHtcbiAgICBjb25zdCBsb2dnZWRSZXF1ZXN0ID0gcHJlcGFyZVJlcXVlc3QocmVxdWVzdCk7XG4gICAgY29uc3QgbG9nZ2VkUmVzcG9uc2UgPSBwcmVwYXJlUmVzcG9uc2UocmVzcG9uc2UyKTtcbiAgICBjb25zdCBzdGF0dXNDb2xvciA9IGdldFN0YXR1c0NvZGVDb2xvcihyZXNwb25zZTIuc3RhdHVzKTtcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IChwYXJzZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRSZXF1ZXN0Lm9wZXJhdGlvbk5hbWUpID8gYCR7cGFyc2VkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkUmVxdWVzdC5vcGVyYXRpb25UeXBlfSAke3BhcnNlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcnNlZFJlcXVlc3Qub3BlcmF0aW9uTmFtZX1gIDogYGFub255bW91cyAke3BhcnNlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcnNlZFJlcXVlc3Qub3BlcmF0aW9uVHlwZX1gO1xuICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXG4gICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFwiJXMgJXMgKCVjJXMlYylcIiksXG4gICAgICBnZXRUaW1lc3RhbXAoKSxcbiAgICAgIGAke3JlcXVlc3RJbmZvfWAsXG4gICAgICBgY29sb3I6JHtzdGF0dXNDb2xvcn1gLFxuICAgICAgYCR7cmVzcG9uc2UyLnN0YXR1c30gJHtyZXNwb25zZTIuc3RhdHVzVGV4dH1gLFxuICAgICAgXCJjb2xvcjppbmhlcml0XCJcbiAgICApO1xuICAgIGNvbnNvbGUubG9nKFwiUmVxdWVzdDpcIiwgbG9nZ2VkUmVxdWVzdCk7XG4gICAgY29uc29sZS5sb2coXCJIYW5kbGVyOlwiLCB0aGlzKTtcbiAgICBjb25zb2xlLmxvZyhcIlJlc3BvbnNlOlwiLCBsb2dnZWRSZXNwb25zZSk7XG4gICAgY29uc29sZS5ncm91cEVuZCgpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9vblVuaGFuZGxlZFJlcXVlc3QudHNcbnZhciBNQVhfTUFUQ0hfU0NPUkUgPSAzO1xudmFyIE1BWF9TVUdHRVNUSU9OX0NPVU5UID0gNDtcbnZhciBUWVBFX01BVENIX0RFTFRBID0gMC41O1xuZnVuY3Rpb24gZ3JvdXBIYW5kbGVyc0J5VHlwZShoYW5kbGVycykge1xuICByZXR1cm4gaGFuZGxlcnMucmVkdWNlKFxuICAgIChncm91cHMsIGhhbmRsZXIpID0+IHtcbiAgICAgIGlmIChoYW5kbGVyIGluc3RhbmNlb2YgUmVzdEhhbmRsZXIpIHtcbiAgICAgICAgZ3JvdXBzLnJlc3QucHVzaChoYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYW5kbGVyIGluc3RhbmNlb2YgR3JhcGhRTEhhbmRsZXIpIHtcbiAgICAgICAgZ3JvdXBzLmdyYXBocWwucHVzaChoYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cHM7XG4gICAgfSxcbiAgICB7XG4gICAgICByZXN0OiBbXSxcbiAgICAgIGdyYXBocWw6IFtdXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gZ2V0UmVzdEhhbmRsZXJTY29yZSgpIHtcbiAgcmV0dXJuIChyZXF1ZXN0LCBoYW5kbGVyKSA9PiB7XG4gICAgY29uc3QgeyBwYXRoLCBtZXRob2QgfSA9IGhhbmRsZXIuaW5mbztcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBtZXRob2QgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgY29uc3QgaGFzU2FtZU1ldGhvZCA9IGlzU3RyaW5nRXF1YWwocmVxdWVzdC5tZXRob2QsIG1ldGhvZCk7XG4gICAgY29uc3QgbWV0aG9kU2NvcmVEZWx0YSA9IGhhc1NhbWVNZXRob2QgPyBUWVBFX01BVENIX0RFTFRBIDogMDtcbiAgICBjb25zdCByZXF1ZXN0UHVibGljVXJsID0gZ2V0UHVibGljVXJsRnJvbVJlcXVlc3QocmVxdWVzdCk7XG4gICAgY29uc3Qgc2NvcmUgPSBnZXRTdHJpbmdNYXRjaFNjb3JlKHJlcXVlc3RQdWJsaWNVcmwsIHBhdGgpO1xuICAgIHJldHVybiBzY29yZSAtIG1ldGhvZFNjb3JlRGVsdGE7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRHcmFwaFFMSGFuZGxlclNjb3JlKHBhcnNlZFF1ZXJ5KSB7XG4gIHJldHVybiAoXywgaGFuZGxlcikgPT4ge1xuICAgIGlmICh0eXBlb2YgcGFyc2VkUXVlcnkub3BlcmF0aW9uTmFtZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICBjb25zdCB7IG9wZXJhdGlvblR5cGUsIG9wZXJhdGlvbk5hbWUgfSA9IGhhbmRsZXIuaW5mbztcbiAgICBpZiAodHlwZW9mIG9wZXJhdGlvbk5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgY29uc3QgaGFzU2FtZU9wZXJhdGlvblR5cGUgPSBwYXJzZWRRdWVyeS5vcGVyYXRpb25UeXBlID09PSBvcGVyYXRpb25UeXBlO1xuICAgIGNvbnN0IG9wZXJhdGlvblR5cGVTY29yZURlbHRhID0gaGFzU2FtZU9wZXJhdGlvblR5cGUgPyBUWVBFX01BVENIX0RFTFRBIDogMDtcbiAgICBjb25zdCBzY29yZSA9IGdldFN0cmluZ01hdGNoU2NvcmUocGFyc2VkUXVlcnkub3BlcmF0aW9uTmFtZSwgb3BlcmF0aW9uTmFtZSk7XG4gICAgcmV0dXJuIHNjb3JlIC0gb3BlcmF0aW9uVHlwZVNjb3JlRGVsdGE7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRTdWdnZXN0ZWRIYW5kbGVyKHJlcXVlc3QsIGhhbmRsZXJzLCBnZXRTY29yZSkge1xuICBjb25zdCBzdWdnZXN0ZWRIYW5kbGVycyA9IGhhbmRsZXJzLnJlZHVjZSgoc3VnZ2VzdGlvbnMsIGhhbmRsZXIpID0+IHtcbiAgICBjb25zdCBzY29yZSA9IGdldFNjb3JlKHJlcXVlc3QsIGhhbmRsZXIpO1xuICAgIHJldHVybiBzdWdnZXN0aW9ucy5jb25jYXQoW1tzY29yZSwgaGFuZGxlcl1dKTtcbiAgfSwgW10pLnNvcnQoKFtsZWZ0U2NvcmVdLCBbcmlnaHRTY29yZV0pID0+IGxlZnRTY29yZSAtIHJpZ2h0U2NvcmUpLmZpbHRlcigoW3Njb3JlXSkgPT4gc2NvcmUgPD0gTUFYX01BVENIX1NDT1JFKS5zbGljZSgwLCBNQVhfU1VHR0VTVElPTl9DT1VOVCkubWFwKChbLCBoYW5kbGVyXSkgPT4gaGFuZGxlcik7XG4gIHJldHVybiBzdWdnZXN0ZWRIYW5kbGVycztcbn1cbmZ1bmN0aW9uIGdldFN1Z2dlc3RlZEhhbmRsZXJzTWVzc2FnZShoYW5kbGVycykge1xuICBpZiAoaGFuZGxlcnMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBgRGlkIHlvdSBtZWFuIHRvIHJlcXVlc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVzb3VyY2VzIGluc3RlYWQ/XG5cbiR7aGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBgICBcXHUyMDIyICR7aGFuZGxlci5pbmZvLmhlYWRlcn1gKS5qb2luKFwiXFxuXCIpfWA7XG4gIH1cbiAgcmV0dXJuIGBEaWQgeW91IG1lYW4gdG8gcmVxdWVzdCBcIiR7aGFuZGxlcnNbMF0uaW5mby5oZWFkZXJ9XCIgaW5zdGVhZD9gO1xufVxuZnVuY3Rpb24gb25VbmhhbmRsZWRSZXF1ZXN0KHJlcXVlc3QsIGhhbmRsZXJzLCBzdHJhdGVneSA9IFwid2FyblwiKSB7XG4gIGNvbnN0IHBhcnNlZEdyYXBoUUxRdWVyeSA9IHRyeUNhdGNoKCgpID0+IHBhcnNlR3JhcGhRTFJlcXVlc3QocmVxdWVzdCkpO1xuICBmdW5jdGlvbiBnZW5lcmF0ZUhhbmRsZXJTdWdnZXN0aW9uKCkge1xuICAgIGNvbnN0IGhhbmRsZXJHcm91cHMgPSBncm91cEhhbmRsZXJzQnlUeXBlKGhhbmRsZXJzKTtcbiAgICBjb25zdCByZWxldmFudEhhbmRsZXJzID0gcGFyc2VkR3JhcGhRTFF1ZXJ5ID8gaGFuZGxlckdyb3Vwcy5ncmFwaHFsIDogaGFuZGxlckdyb3Vwcy5yZXN0O1xuICAgIGNvbnN0IHN1Z2dlc3RlZEhhbmRsZXJzID0gZ2V0U3VnZ2VzdGVkSGFuZGxlcihcbiAgICAgIHJlcXVlc3QsXG4gICAgICByZWxldmFudEhhbmRsZXJzLFxuICAgICAgcGFyc2VkR3JhcGhRTFF1ZXJ5ID8gZ2V0R3JhcGhRTEhhbmRsZXJTY29yZShwYXJzZWRHcmFwaFFMUXVlcnkpIDogZ2V0UmVzdEhhbmRsZXJTY29yZSgpXG4gICAgKTtcbiAgICByZXR1cm4gc3VnZ2VzdGVkSGFuZGxlcnMubGVuZ3RoID4gMCA/IGdldFN1Z2dlc3RlZEhhbmRsZXJzTWVzc2FnZShzdWdnZXN0ZWRIYW5kbGVycykgOiBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVW5oYW5kbGVkUmVxdWVzdE1lc3NhZ2UoKSB7XG4gICAgY29uc3QgcHVibGljVXJsID0gZ2V0UHVibGljVXJsRnJvbVJlcXVlc3QocmVxdWVzdCk7XG4gICAgY29uc3QgcmVxdWVzdEhlYWRlciA9IHBhcnNlZEdyYXBoUUxRdWVyeSA/IGAke3BhcnNlZEdyYXBoUUxRdWVyeS5vcGVyYXRpb25UeXBlfSAke3BhcnNlZEdyYXBoUUxRdWVyeS5vcGVyYXRpb25OYW1lfSAoJHtyZXF1ZXN0Lm1ldGhvZH0gJHtwdWJsaWNVcmx9KWAgOiBgJHtyZXF1ZXN0Lm1ldGhvZH0gJHtwdWJsaWNVcmx9YDtcbiAgICBjb25zdCBoYW5kbGVyU3VnZ2VzdGlvbiA9IGdlbmVyYXRlSGFuZGxlclN1Z2dlc3Rpb24oKTtcbiAgICBjb25zdCBtZXNzYWdlVGVtcGxhdGUgPSBbXG4gICAgICBgY2FwdHVyZWQgYSByZXF1ZXN0IHdpdGhvdXQgYSBtYXRjaGluZyByZXF1ZXN0IGhhbmRsZXI6YCxcbiAgICAgIGAgIFxcdTIwMjIgJHtyZXF1ZXN0SGVhZGVyfWAsXG4gICAgICBoYW5kbGVyU3VnZ2VzdGlvbixcbiAgICAgIGBJZiB5b3Ugc3RpbGwgd2lzaCB0byBpbnRlcmNlcHQgdGhpcyB1bmhhbmRsZWQgcmVxdWVzdCwgcGxlYXNlIGNyZWF0ZSBhIHJlcXVlc3QgaGFuZGxlciBmb3IgaXQuXG5SZWFkIG1vcmU6IGh0dHBzOi8vbXN3anMuaW8vZG9jcy9nZXR0aW5nLXN0YXJ0ZWQvbW9ja3NgXG4gICAgXS5maWx0ZXIoQm9vbGVhbik7XG4gICAgcmV0dXJuIG1lc3NhZ2VUZW1wbGF0ZS5qb2luKFwiXFxuXFxuXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5U3RyYXRlZ3koc3RyYXRlZ3kyKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGdlbmVyYXRlVW5oYW5kbGVkUmVxdWVzdE1lc3NhZ2UoKTtcbiAgICBzd2l0Y2ggKHN0cmF0ZWd5Mikge1xuICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgZGV2VXRpbHMuZXJyb3IoXCJFcnJvcjogJXNcIiwgbWVzc2FnZSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAgICAgJ0Nhbm5vdCBieXBhc3MgYSByZXF1ZXN0IHdoZW4gdXNpbmcgdGhlIFwiZXJyb3JcIiBzdHJhdGVneSBmb3IgdGhlIFwib25VbmhhbmRsZWRSZXF1ZXN0XCIgb3B0aW9uLidcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjYXNlIFwid2FyblwiOiB7XG4gICAgICAgIGRldlV0aWxzLndhcm4oXCJXYXJuaW5nOiAlc1wiLCBtZXNzYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYnlwYXNzXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgICAnRmFpbGVkIHRvIHJlYWN0IHRvIGFuIHVuaGFuZGxlZCByZXF1ZXN0OiB1bmtub3duIHN0cmF0ZWd5IFwiJXNcIi4gUGxlYXNlIHByb3ZpZGUgb25lIG9mIHRoZSBzdXBwb3J0ZWQgc3RyYXRlZ2llcyAoXCJieXBhc3NcIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIikgb3IgYSBjdXN0b20gY2FsbGJhY2sgZnVuY3Rpb24gYXMgdGhlIHZhbHVlIG9mIHRoZSBcIm9uVW5oYW5kbGVkUmVxdWVzdFwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgc3RyYXRlZ3kyXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHN0cmF0ZWd5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBzdHJhdGVneShyZXF1ZXN0LCB7XG4gICAgICB3YXJuaW5nOiBhcHBseVN0cmF0ZWd5LmJpbmQobnVsbCwgXCJ3YXJuXCIpLFxuICAgICAgZXJyb3I6IGFwcGx5U3RyYXRlZ3kuYmluZChudWxsLCBcImVycm9yXCIpXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFwcGx5U3RyYXRlZ3koc3RyYXRlZ3kpO1xufVxuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9yZWFkUmVzcG9uc2VDb29raWVzLnRzXG5pbXBvcnQgeyBzdG9yZSBhcyBzdG9yZTIgfSBmcm9tIFwiQG1zd2pzL2Nvb2tpZXNcIjtcbmZ1bmN0aW9uIHJlYWRSZXNwb25zZUNvb2tpZXMocmVxdWVzdCwgcmVzcG9uc2UyKSB7XG4gIHN0b3JlMi5hZGQoeyAuLi5yZXF1ZXN0LCB1cmw6IHJlcXVlc3QudXJsLnRvU3RyaW5nKCkgfSwgcmVzcG9uc2UyKTtcbiAgc3RvcmUyLnBlcnNpc3QoKTtcbn1cblxuLy8gc3JjL3V0aWxzL2hhbmRsZVJlcXVlc3QudHNcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3QocmVxdWVzdCwgaGFuZGxlcnMsIG9wdGlvbnMsIGVtaXR0ZXIsIGhhbmRsZVJlcXVlc3RPcHRpb25zKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0OnN0YXJ0XCIsIHJlcXVlc3QpO1xuICBpZiAocmVxdWVzdC5oZWFkZXJzLmdldChcIngtbXN3LWJ5cGFzc1wiKSA9PT0gXCJ0cnVlXCIpIHtcbiAgICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0OmVuZFwiLCByZXF1ZXN0KTtcbiAgICAoX2EgPSBoYW5kbGVSZXF1ZXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUmVxdWVzdE9wdGlvbnMub25QYXNzdGhyb3VnaFJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChoYW5kbGVSZXF1ZXN0T3B0aW9ucywgcmVxdWVzdCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IFtsb29rdXBFcnJvciwgbG9va3VwUmVzdWx0XSA9IGF3YWl0IHVudGlsKCgpID0+IHtcbiAgICByZXR1cm4gZ2V0UmVzcG9uc2UoXG4gICAgICByZXF1ZXN0LFxuICAgICAgaGFuZGxlcnMsXG4gICAgICBoYW5kbGVSZXF1ZXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUmVxdWVzdE9wdGlvbnMucmVzb2x1dGlvbkNvbnRleHRcbiAgICApO1xuICB9KTtcbiAgaWYgKGxvb2t1cEVycm9yKSB7XG4gICAgZW1pdHRlci5lbWl0KFwidW5oYW5kbGVkRXhjZXB0aW9uXCIsIGxvb2t1cEVycm9yLCByZXF1ZXN0KTtcbiAgICB0aHJvdyBsb29rdXBFcnJvcjtcbiAgfVxuICBjb25zdCB7IGhhbmRsZXIsIHJlc3BvbnNlOiByZXNwb25zZTIgfSA9IGxvb2t1cFJlc3VsdDtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgb25VbmhhbmRsZWRSZXF1ZXN0KHJlcXVlc3QsIGhhbmRsZXJzLCBvcHRpb25zLm9uVW5oYW5kbGVkUmVxdWVzdCk7XG4gICAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDp1bmhhbmRsZWRcIiwgcmVxdWVzdCk7XG4gICAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDplbmRcIiwgcmVxdWVzdCk7XG4gICAgKF9iID0gaGFuZGxlUmVxdWVzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVJlcXVlc3RPcHRpb25zLm9uUGFzc3Rocm91Z2hSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoaGFuZGxlUmVxdWVzdE9wdGlvbnMsIHJlcXVlc3QpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXJlc3BvbnNlMikge1xuICAgIGRldlV0aWxzLndhcm4oXG4gICAgICBgRXhwZWN0ZWQgcmVzcG9uc2UgcmVzb2x2ZXIgdG8gcmV0dXJuIGEgbW9ja2VkIHJlc3BvbnNlIE9iamVjdCwgYnV0IGdvdCAlcy4gVGhlIG9yaWdpbmFsIHJlc3BvbnNlIGlzIGdvaW5nIHRvIGJlIHVzZWQgaW5zdGVhZC5cblxuICBcXHUyMDIyICVzXG4gICAgJXNgLFxuICAgICAgcmVzcG9uc2UyLFxuICAgICAgaGFuZGxlci5pbmZvLmhlYWRlcixcbiAgICAgIGhhbmRsZXIuaW5mby5jYWxsRnJhbWVcbiAgICApO1xuICAgIGVtaXR0ZXIuZW1pdChcInJlcXVlc3Q6ZW5kXCIsIHJlcXVlc3QpO1xuICAgIChfYyA9IGhhbmRsZVJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVSZXF1ZXN0T3B0aW9ucy5vblBhc3N0aHJvdWdoUmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKGhhbmRsZVJlcXVlc3RPcHRpb25zLCByZXF1ZXN0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHJlc3BvbnNlMi5wYXNzdGhyb3VnaCkge1xuICAgIGVtaXR0ZXIuZW1pdChcInJlcXVlc3Q6ZW5kXCIsIHJlcXVlc3QpO1xuICAgIChfZCA9IGhhbmRsZVJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVSZXF1ZXN0T3B0aW9ucy5vblBhc3N0aHJvdWdoUmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZC5jYWxsKGhhbmRsZVJlcXVlc3RPcHRpb25zLCByZXF1ZXN0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVhZFJlc3BvbnNlQ29va2llcyhyZXF1ZXN0LCByZXNwb25zZTIpO1xuICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0Om1hdGNoXCIsIHJlcXVlc3QpO1xuICBjb25zdCByZXF1aXJlZExvb2t1cFJlc3VsdCA9IGxvb2t1cFJlc3VsdDtcbiAgY29uc3QgdHJhbnNmb3JtZWRSZXNwb25zZSA9ICgoX2UgPSBoYW5kbGVSZXF1ZXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUmVxdWVzdE9wdGlvbnMudHJhbnNmb3JtUmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZS5jYWxsKGhhbmRsZVJlcXVlc3RPcHRpb25zLCByZXNwb25zZTIpKSB8fCByZXNwb25zZTI7XG4gIChfZiA9IGhhbmRsZVJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVSZXF1ZXN0T3B0aW9ucy5vbk1vY2tlZFJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2YuY2FsbChcbiAgICBoYW5kbGVSZXF1ZXN0T3B0aW9ucyxcbiAgICB0cmFuc2Zvcm1lZFJlc3BvbnNlLFxuICAgIHJlcXVpcmVkTG9va3VwUmVzdWx0XG4gICk7XG4gIGVtaXR0ZXIuZW1pdChcInJlcXVlc3Q6ZW5kXCIsIHJlcXVlc3QpO1xuICByZXR1cm4gdHJhbnNmb3JtZWRSZXNwb25zZTtcbn1cblxuLy8gc3JjL25vZGUvU2V0dXBTZXJ2ZXJBcGkudHNcbnZhciB7IGJvbGQgfSA9IGNoYWxrO1xudmFyIERFRkFVTFRfTElTVEVOX09QVElPTlMgPSB7XG4gIG9uVW5oYW5kbGVkUmVxdWVzdDogXCJ3YXJuXCJcbn07XG52YXIgU2V0dXBTZXJ2ZXJBcGkgPSBjbGFzcyBleHRlbmRzIFNldHVwQXBpIHtcbiAgY29uc3RydWN0b3IoaW50ZXJjZXB0b3JzLCAuLi5oYW5kbGVycykge1xuICAgIHN1cGVyKC4uLmhhbmRsZXJzKTtcbiAgICB0aGlzLmludGVyY2VwdG9yID0gbmV3IEJhdGNoSW50ZXJjZXB0b3Ioe1xuICAgICAgbmFtZTogXCJzZXR1cC1zZXJ2ZXJcIixcbiAgICAgIGludGVyY2VwdG9yczogaW50ZXJjZXB0b3JzLm1hcCgoSW50ZXJjZXB0b3IyKSA9PiBuZXcgSW50ZXJjZXB0b3IyKCkpXG4gICAgfSk7XG4gICAgdGhpcy5yZXNvbHZlZE9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuICBpbml0KCkge1xuICAgIHRoaXMuaW50ZXJjZXB0b3Iub24oXCJyZXF1ZXN0XCIsIGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICBjb25zdCBtb2NrZWRSZXF1ZXN0ID0gbmV3IE1vY2tlZFJlcXVlc3QocmVxdWVzdC51cmwsIHtcbiAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAgYm9keTogYXdhaXQgcmVxdWVzdC5hcnJheUJ1ZmZlcigpXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlMiA9IGF3YWl0IGhhbmRsZVJlcXVlc3QoXG4gICAgICAgIG1vY2tlZFJlcXVlc3QsXG4gICAgICAgIHRoaXMuY3VycmVudEhhbmRsZXJzLFxuICAgICAgICB0aGlzLnJlc29sdmVkT3B0aW9ucyxcbiAgICAgICAgdGhpcy5lbWl0dGVyLFxuICAgICAgICB7XG4gICAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2UocmVzcG9uc2UzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlMy5zdGF0dXMsXG4gICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlMy5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZTMuaGVhZGVycy5hbGwoKSxcbiAgICAgICAgICAgICAgYm9keTogcmVzcG9uc2UzLmJvZHksXG4gICAgICAgICAgICAgIGRlbGF5OiByZXNwb25zZTMuZGVsYXlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlMikge1xuICAgICAgICBpZiAocmVzcG9uc2UyLmRlbGF5KSB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgcmVzcG9uc2UyLmRlbGF5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0LnJlc3BvbmRXaXRoKHJlc3BvbnNlMik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSk7XG4gICAgdGhpcy5pbnRlcmNlcHRvci5vbihcInJlc3BvbnNlXCIsIChyZXF1ZXN0LCByZXNwb25zZTIpID0+IHtcbiAgICAgIGlmICghcmVxdWVzdC5pZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVzcG9uc2UyLmhlYWRlcnMuZ2V0KFwieC1wb3dlcmVkLWJ5XCIpID09PSBcIm1zd1wiKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KFwicmVzcG9uc2U6bW9ja2VkXCIsIHJlc3BvbnNlMiwgcmVxdWVzdC5pZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdChcInJlc3BvbnNlOmJ5cGFzc1wiLCByZXNwb25zZTIsIHJlcXVlc3QuaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGxpc3RlbihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnJlc29sdmVkT3B0aW9ucyA9IG1lcmdlUmlnaHQoXG4gICAgICBERUZBVUxUX0xJU1RFTl9PUFRJT05TLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgdGhpcy5pbnRlcmNlcHRvci5hcHBseSgpO1xuICAgIGludmFyaWFudDMoXG4gICAgICBbSW50ZXJjZXB0b3JSZWFkeVN0YXRlLkFQUExZSU5HLCBJbnRlcmNlcHRvclJlYWR5U3RhdGUuQVBQTElFRF0uaW5jbHVkZXMoXG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3IucmVhZHlTdGF0ZVxuICAgICAgKSxcbiAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICdGYWlsZWQgdG8gc3RhcnQgXCJzZXR1cFNlcnZlclwiOiB0aGUgaW50ZXJjZXB0b3IgZmFpbGVkIHRvIGFwcGx5LiBUaGlzIGlzIGxpa2VseSBhbiBpc3N1ZSB3aXRoIHRoZSBsaWJyYXJ5IGFuZCB5b3Ugc2hvdWxkIHJlcG9ydCBpdCBhdCBcIiVzXCIuJ1xuICAgICAgKSxcbiAgICAgIFwiaHR0cHM6Ly9naXRodWIuY29tL21zd2pzL21zdy9pc3N1ZXMvbmV3L2Nob29zZVwiXG4gICAgKTtcbiAgfVxuICBwcmludEhhbmRsZXJzKCkge1xuICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5saXN0SGFuZGxlcnMoKTtcbiAgICBoYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICBjb25zdCB7IGhlYWRlciwgY2FsbEZyYW1lIH0gPSBoYW5kbGVyLmluZm87XG4gICAgICBjb25zdCBwcmFnbWEgPSBoYW5kbGVyLmluZm8uaGFzT3duUHJvcGVydHkoXCJvcGVyYXRpb25UeXBlXCIpID8gXCJbZ3JhcGhxbF1cIiA6IFwiW3Jlc3RdXCI7XG4gICAgICBjb25zb2xlLmxvZyhgJHtib2xkKGAke3ByYWdtYX0gJHtoZWFkZXJ9YCl9XG4gIERlY2xhcmF0aW9uOiAke2NhbGxGcmFtZX1cbmApO1xuICAgIH0pO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLmludGVyY2VwdG9yLmRpc3Bvc2UoKTtcbiAgfVxufTtcblxuLy8gc3JjL25vZGUvc2V0dXBTZXJ2ZXIudHNcbmltcG9ydCB7IENsaWVudFJlcXVlc3RJbnRlcmNlcHRvciB9IGZyb20gXCJAbXN3anMvaW50ZXJjZXB0b3JzL2xpYi9pbnRlcmNlcHRvcnMvQ2xpZW50UmVxdWVzdC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgWE1MSHR0cFJlcXVlc3RJbnRlcmNlcHRvciB9IGZyb20gXCJAbXN3anMvaW50ZXJjZXB0b3JzL2xpYi9pbnRlcmNlcHRvcnMvWE1MSHR0cFJlcXVlc3QvaW5kZXguanNcIjtcbmltcG9ydCB7IEZldGNoSW50ZXJjZXB0b3IgfSBmcm9tIFwiQG1zd2pzL2ludGVyY2VwdG9ycy9saWIvaW50ZXJjZXB0b3JzL2ZldGNoL2luZGV4LmpzXCI7XG52YXIgc2V0dXBTZXJ2ZXIgPSAoLi4uaGFuZGxlcnMpID0+IHtcbiAgcmV0dXJuIG5ldyBTZXR1cFNlcnZlckFwaShcbiAgICBbQ2xpZW50UmVxdWVzdEludGVyY2VwdG9yLCBYTUxIdHRwUmVxdWVzdEludGVyY2VwdG9yLCBGZXRjaEludGVyY2VwdG9yXSxcbiAgICAuLi5oYW5kbGVyc1xuICApO1xufTtcbmV4cG9ydCB7XG4gIFNldHVwU2VydmVyQXBpLFxuICBzZXR1cFNlcnZlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/msw/lib/node/index.mjs\n");

/***/ })

};
;