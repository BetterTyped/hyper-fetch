---
sidebar_position: 7
title: Dispatcher
sidebar_label: Dispatcher
---

[Read the API Reference Â»](/api/core/Classes/Dispatcher.mdx)

In order to provide advanced features and fetching modes like retries, deduplication, queueing, canceling etc. It can
catalog the requests providing unique IDs, tracking the lifecycle and triggering the requests at the right time and in
the right way.

Every request in the dispatcher is stored in the queue structure. This allows us to perform many operations (e.g.
stopping, pausing, or starting) on the dispatched requests. However, this does not mean that all requests will be sent
individually; there are multiple dispatching modes available, which you can read about in the
[dispatching modes](#dispatching-modes) section.

---

:::tip Purpose

1. Orchestrates request flow and lifecycle
2. Can retry, deduplicate, manage offline mode and more
3. Allow to pause and resume requests or queue groups
4. Bridges adapter, cache and managers functionality

:::

---

## How it works

Each request triggered with `send()` unlike the `exec()` method goes through the whole lifecycle in the library. First
we check for the mode of execution is it concurrent, queued, cancelable or deduplicated - based on this we will know
what to do with this or previous requests. Next we add the request to the queue which is a group of requests with the
same `queryKey`. Once request is picked from the queue to be triggered, we assign him the `requestId` and execute it in
adapter of our choice. From this point we trigger whole lifecycle including retries, offline handling, request and
response events. At the end we remove successful or not - request from the queue, pass the data to cache for handling
state.

#### Two instances

There are two dispatcher instances in the Client class: one for querying and one for mutation requests. This was
designed for configuration reasons and gives you much more flexibility. So the way how you mutate the data can vary from
the way you query for data. For example you may set some different default settings for each dispatchers.

## QueryKey

The `queryKey` is a unique identifier for the request queues. It is used in propagation and reception of request events
on a given queue and in management of incoming and outgoing requests. Each detected unique `queryKey` creates isolated
queue array. By default keys are auto-generated from the request's endpoint, url params, but you can still add the key
manually when setting the Request or generic generator.

```tsx
const getUser = client.createRequest()({
  method: "GET",
  endpoint: "/users/:userId",
});

// highlight-start
const queryKey = getUser.queryKey; // "/users/:userId"
const queryKeyWithParams = getUser.setParams({ userId: 1 }).queryKey; // "/users/1"
const queryKeyWithQueryParams = getUser.setQueryParams({ page: 1 }).queryKey; // "/users/:userId"
// highlight-end
```

### Custom queryKey

You can also set a custom query key:

```tsx
import { client } from "./api";

const getUser = client.createRequest()({
  method: "GET",
  endpoint: "/users/:userId",
  queryKey: "CUSTOM_QUERY_KEY",
});

// highlight-start
console.log(getUser.queryKey); // "CUSTOM_QUERY_KEY"
// highlight-end
```

### Generic queryKey

You can also set a generic query key:

```tsx
import { client } from "./api";

// highlight-start
client.setQueryKeyMapper((request) => {
  if (request.requestOptions.endpoint === "/users/:userId") {
    return `CUSTOM_QUERY_KEY_${request.params?.userId || "unknown"}`;
  }
});
// highlight-end

const getUser = client.createRequest()({
  method: "GET",
  endpoint: "/users/:userId",
});

// highlight-start
console.log(getUser.setParams({ userId: 1 }).queryKey); // "CUSTOM_QUERY_KEY_1"
// highlight-end
```

---

## RequestId

**`requestId`** is autogenerated by the dispatchers when a request is being executed. It is unique around single
instance of Client, we do not guarantee it being unique between Clients. It's used when we need exact communication with
the dispatcher - for example if we need to listen for particular request events or removing it.

---

## Available methods

<ShowMore>

(@import core Dispatcher type=methods&display=table)

</ShowMore>

<LinkCard
  type="api"
  title="Detailed Dispatcher API Methods"
  description="Explore all available methods, their parameters, and return values for the Dispatcher class."
  to="/docs/api/core/Classes/Dispatcher.mdx#methods"
/>

---

## Features

Here is a list of features that the dispatcher provides:

1. ### Retrying

One of features that the dispatcher provides is retrying requests that failed. It can retry requests that failed and
keep waiting for the successful result.

Below is an example of how to set the request to retry and set the time between attempts. It will resolve the response
promise on success

or after the last retry attempt.

```tsx
const getUser = client.createRequest()({
  method: "GET",
  endpoint: "/users/:userId",
  retry: 5,
  retryTime: 3000,
});

const response = await getUser.send();
```

2. ### Queues

Dispatchers stores requests in queues. Thank to this we have more and better control over the request flow. With this
kind of flexibility we are able to `stop()`, `pause()`, and `start()` requests execution. We can apply this rule to
single request of the whole queues (we have new queue for each unique `queryKey`).

:::note What is the difference between `stop()` and `pause()`?

We have two methods for stopping Dispatcher queues - `stop()` and `pause()`. Stop will cancel the currently ongoing and
all of the queued requests(but it do not remove it from the queue, so it can be processed again) at the moment of
triggering it to prevent all data-exchange. However `pause()` do not cancel the ongoing request so you can gracefully
stop the processing and make sure that other requests will not be executed until we start it again.

:::

#### Start

When your queue is stopped, you can use the `start()` to resume data-exchange.

```tsx live title="Start request queue" size=md
// Requests will be stopped
client.fetchDispatcher.stop(getUser.queryKey);

// Trigger the request
getUser.send();

setTimeout(() => {
  // Start the request
  client.fetchDispatcher.start(getUser.queryKey);
}, 2000);
```

#### Pause

To pause requests, just use the `pause()` method on the Dispatcher.

```tsx
// To pause the queue
// highlight-next-line
client.fetchDispatcher.pause("queryKey");
```

:::warning Pausing individual request

You cannot `pause()` the individual requests, it can only be stopped.

:::

```tsx live  title="Pausing request queue" size=md
// Trigger the request
getUser.send();

setTimeout(() => {
  // Pause the queue, this will complete the in-progress request and hold all others
  client.fetchDispatcher.pause(getUser.queryKey);
}, 500);

setTimeout(() => {
  // Trigger another request, that will be stopped
  getUser.send();
}, 1000);

// Start the queue
setTimeout(() => {
  client.fetchDispatcher.start(getUser.queryKey);
}, 4000);
```

#### Stop

To stop requests use the `stop()` method to stop the queue. It will cancel the in-progress request and hold all others.

```tsx
// To stop the queue
// highlight-next-line
client.fetchDispatcher.stop("queryKey");
```

```tsx live title="Stopping request queue" size=md
// Trigger the request
getUser.send();

setTimeout(() => {
  // Stop the queue, this will cancel the in-progress request and hold all others
  client.fetchDispatcher.stop(getUser.queryKey);
}, 500);

setTimeout(() => {
  // Trigger another request, that will be stopped
  getUser.send();
}, 1000);

// Start the queue, will resume the in-progress request and allow the others to be sent
setTimeout(() => {
  client.fetchDispatcher.start(getUser.queryKey);
}, 4000);
```

You can also stop the individual request with the `stopRequest()` method. It will cancel the request and remove it from
the queue.

```tsx
// To stop individual request
// highlight-next-line
client.fetchDispatcher.stopRequest("queryKey", "requestId");
```

```tsx live title="Stopping individual request" size=md
let getUserRequestId = "";

// Trigger the request
getUser.send({
  onBeforeSent: ({ requestId }) => {
    getUserRequestId = requestId;
  },
});

// Trigger another request
getUser.send();

// Stop individual request
setTimeout(() => {
  client.fetchDispatcher.stopRequest(getUser.queryKey, getUserRequestId);
}, 1000);

// Start stopped request
setTimeout(() => {
  client.fetchDispatcher.startRequest(getUser.queryKey, getUserRequestId);
}, 3000);
```

3. ### Offline

When the connection is lost, the queue is stopped and the failed or interrupted requests will wait for the connection to
recover to be triggered again. This prevents data loss and allows us to leverage cache abilities.

```tsx live  title=Offline handling
// Simulate the connection loss
client.appManager.setOnline(false);

// Trigger the request being offline
getUser.send();

// Return back online and the request will be resumed
setTimeout(() => {
  client.appManager.setOnline(true);
}, 2000);
```

To **disable offline mode** you can set the request offline option to false.

```ts
const newRequest = client.createClient()({
  endpoint: "/request"
  // highlight-next-line
  offline: false
})
```

---

## Modes

Every dispatcher queue has several modes that can be selected by request props.

### Concurrent

When using this mode, requests are not limited in any way; they can all be called at any time, all at once. This is the
default mode for requests.

Enable this mode by setting the request `queued` prop to false.

```tsx live
import { getUser } from "./api";

// First request
getUser.send();

// Second request
getUser.send();
```

### Deduplication

Deduplication optimizes the data exchange with the server. If we ask the server for the same data twice at the same time
with different requests, this mode will perform one call and propagate the request to both sources.

Enable this mode by setting the request `deduplication` prop to true.

```tsx live size=lg
import { getUser } from "./api";

const getUserDeduplicated = getUser.setDeduplicate(true);

// First request
const request1 = getUserDeduplicated.send();

// Second request (Deduplicated - it will never be triggered)
const request2 = getUserDeduplicated.send();

setTimeout(async () => {
  // Third request (Deduplicated - it will never be triggered)
  const request3 = getUserDeduplicated.send();

  // Responses logs
  const [response1, response2, response3] = await Promise.all([request1, request2, request3]);

  console.log(response1);
  console.log(response2);
  console.log(response3);
}, 500);

// Wait for the requests to be resolved
```

### Cancelable

Cancelable mode avoids race-conditioning when multiple requests are sent simultaneously but only the last request
matters. This mode is ideal for paginated lists of data, i.e. where only a single page needs to be shown regardless if
the user is triggering new requests with rapidly changing pagination.

Enable this mode by setting the request `cancelable` prop to true.

```tsx live size=md
import { getUser } from "./api";

const getUserCancelable = getUser.setCancelable(true);

// First request
getUserCancelable.send();

setTimeout(() => {
  // Second request
  getUserCancelable.send();
}, 500);
```

### Queued

This mode is ideal for a `one-by-one` sending solution. It allows you to combine requests into one ordered list that
will be resolved one item at a time. In this mode, you can `start`, `stop`, or `pause` the entire queue.

Enable this mode by setting the request `queued` prop to true.

```tsx live size=md
import { postFile } from "./api";

const postFileQueued = postFile.setQueued(true);

// First request
postFileQueued.send();
postFileQueued.send();
postFileQueued.send();
```

---
