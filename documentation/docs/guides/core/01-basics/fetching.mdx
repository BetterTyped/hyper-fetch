---
sidebar_position: 1
title: Guide - Fetching
sidebar_label: Fetching
---

# Fetching

Fetching is the process of executing a request to communicate with a server. In Hyper-Fetch, this is primarily done
using the `send` method on a request instance. This guide will walk you through the various ways to dispatch requests,
pass data, and handle their lifecycle events.

---

:::secondary What you'll learn

1. How to **fetch data** from a server and handle responses.
2. How to pass **data**, **parameters**, and **query params** to your requests.
3. How to use **lifecycle callbacks** to monitor request states.
4. How to **abort** a request.

:::

---

## Triggering a Request

The most direct way to execute a request is by calling the `send` method on it. This method is asynchronous and returns
a promise that resolves with the request's outcome, including data, error, and status.

Let's start by defining a request to fetch a user.

```ts
// import { client } from "client"; // Assumed client setup

const getUser = client.createRequest<{ response: { id: number; name: string } }>()({
  endpoint: "/users/:userId",
  method: "GET",
});
```

Now, we can dispatch it. The `send` method returns a rich object with details about the response.

```ts live
// In a real app, you would import 'getUser'
// import { getUser } from "./requests";

async function fetchUser() {
  const requestWithParams = getUser.setParams({ userId: 1 });

  // highlight-start
  // Execute the request and destructure the response
  const { data, error, isSuccess, status } = await requestWithParams.send();
  // highlight-end

  if (isSuccess) {
    console.log(`Request successful with status ${status}!`);
    console.log("User data:", data);
  } else {
    console.error(`Request failed with status ${status}.`, error);
  }
}

fetchUser();
```

### Response Object

The `send` method resolves with an object containing the following properties:

(@import core ResponseType type=returns)

---

## Passing Data to Requests

Hyper-Fetch provides flexible ways to pass data, parameters, and query parameters to your requests.

### 1. Using Setter Methods

You can use methods like `setData`, `setParams`, and `setQueryParams` to prepare a request before sending it. This is
useful for building up a request in multiple steps or based on dynamic conditions.

```ts
const updateUser = client.createRequest<{
  response: { id: number; name: string };
  payload: { name: string };
}>()({
  endpoint: "/users/:userId",
  method: "PUT",
});

const preparedRequest = updateUser.setParams({ userId: 1 }).setData({ name: "New Name" });

const { data } = await preparedRequest.send();
```

### 2. Passing Data Directly to `send`

For a more direct approach, you can pass data, params, and query params as an object to the `send` method. This is often
cleaner and more readable for simple requests.

```ts live
// In a real app, you would import a pre-configured request
const postData = client.createRequest()({
  endpoint: "/posts",
  method: "POST",
});

async function createPost() {
  const { data, error } = await postData.send({
    // highlight-start
    data: { title: "New Post", content: "..." },
    queryParams: { authorId: 5 },
    // highlight-end
  });

  if (data) {
    console.log("Post created:", data);
  } else {
    console.error("Failed to create post:", error);
  }
}

createPost();
```

---

## Aborting a Request

You can abort a request using the native `AbortController`. Simply create a controller and pass its `signal` to the
`send` method. This is useful for canceling requests that are no longer needed, for example, when a user navigates away
from a component.

```ts live
const getUserRequest = client.createRequest()({
  endpoint: "/users/1",
  method: "GET",
});

async function fetchOrAbort() {
  const controller = new AbortController();

  setTimeout(() => {
    // Abort the request after 50ms
    controller.abort();
  }, 50);

  console.log("Fetching user...");
  const { isAborted, error } = await getUserRequest.send({
    // Pass the signal to the send method
    signal: controller.signal,
  });

  if (isAborted) {
    console.log("Request was aborted.", error.message);
  }
}

fetchOrAbort();
```

---

## Request Lifecycle Callbacks

The `send` method allows you to hook into the entire lifecycle of a request, from the moment it's about to be sent until
it's finished. This is powerful for side-effects like showing loading indicators, logging, or performance monitoring.

All callbacks are optional and can be passed directly to the `send` method. Each callback receives the request instance
and its `requestId` as arguments.

```ts
const { data, error } = await someRequest.send({
  // Called right before the request is sent
  onBeforeSent: ({ request, requestId }) => {
    console.log(`Request ${requestId} is about to be sent.`);
  },
  // Called when the request starts
  onStart: ({ request, requestId }) => {
    console.log(`Request ${requestId} has started.`);
    // Ideal for showing a loading spinner
  },
  // Called on upload progress
  onUploadProgress: ({ progress, total, loaded }) => {
    console.log(`Upload progress: ${progress}% (${loaded} / ${total} bytes)`);
  },
  // Called on download progress
  onDownloadProgress: ({ progress, total, loaded }) => {
    console.log(`Download progress: ${progress}% (${loaded} / ${total} bytes)`);
  },
  // Called upon receiving a response, whether success or error
  onResponse: ({ response, request, requestId }) => {
    console.log(`Request ${requestId} finished with status: ${response.status}`);
  },
  // Called only on a successful response
  onSuccess: ({ response, request, requestId }) => {
    console.log(`Request ${requestId} succeeded with data:`, response.data);
  },
  // Called only on a failed response
  onError: ({ error, request, requestId }) => {
    console.error(`Request ${requestId} failed with error:`, error);
  },
  // Called when the request is aborted
  onAbort: ({ error, request, requestId }) => {
    console.warn(`Request ${requestId} was aborted.`, error.message);
  },
  // Called when the request is finished, regardless of outcome
  onFinished: ({ response, error, request, requestId }) => {
    console.log(`Request ${requestId} has finished.`);
    // Ideal for hiding a loading spinner
  },
});
```

Here is a live example demonstrating a few of these callbacks:

```ts live
const getUserRequest = client.createRequest()({
  endpoint: "/users/1",
  method: "GET",
});

async function fetchUserWithCallbacks() {
  console.log("Fetching user...");

  const { data } = await getUserRequest.send({
    onStart: () => {
      console.log("Fetching user started...");
    },
    onSuccess: ({ response }) => {
      console.log("User data received:", response.data);
    },
    onFinished: () => {
      console.log("...request finished.");
    },
  });
}

fetchUserWithCallbacks();
```

---

:::success Congratulations!

You've learned the fundamentals of dispatching requests with Hyper-Fetch!

- You can execute any request by calling its **`send`** method, which returns a rich response object.
- You can pass data to a request using **setter methods** or directly within the **`send`** method's options.
- You can abort a request using an **`AbortController`**'s `signal`.
- You can use **lifecycle callbacks** for handling side-effects during a request's journey.

:::
