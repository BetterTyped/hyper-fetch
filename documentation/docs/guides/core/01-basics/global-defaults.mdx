---
sidebar_position: 10
title: Guide - Global Defaults
sidebar_label: Global Defaults
---

# Global Defaults

Setting global defaults for your requests is a powerful way to streamline your application's data-fetching layer. It
allows you to define common configurations in one place, reducing boilerplate code and ensuring consistency across your
app. Hyper-Fetch provides flexible mechanisms to set dynamic default options and customize how requests are identified.

---

:::secondary What you'll learn

1.  How to set **global default options** that apply to all requests.
2.  How to create **dynamic default configurations** based on request properties like the HTTP method.
3.  Why and how to customize **request keys** for features like caching and request aborting.

:::

---

## Setting Default Request Options

Adding global configurations can significantly streamline your application setup. For maximum flexibility, especially in
larger applications, Hyper-Fetch allows you to add global configs through a callback function. This function receives
the request's details, enabling you to apply different defaults based on its properties, like the HTTP method.

Global configurations are overridden by options set on individual requests. This means you can set a sensible default
and still customize behavior for specific cases.

The main method for this is `client.setRequestDefaultOptions`.

### Example

Let's configure a client to have different defaults for `GET` requests versus other methods like `POST` or `PUT`. For
`GET` requests, we'll enable deduplication and caching with a short stale time. For other requests, we'll disable
caching to ensure mutations are always sent to the server.

```typescript live
// import { createClient } from "@hyper-fetch/core"

// This client is available in the live environment
// const client = createClient({ url: "..." });

client.setRequestDefaultOptions((request) => {
  if (request.method === "GET") {
    return {
      // highlight-start
      deduplicate: true, // Prevents identical GET requests from being sent simultaneously
      staleTime: 1000 * 60 * 5, // 5 minutes
      retry: 3, // Retry failed requests up to 3 times
      // highlight-end
    };
  }

  return {
    // highlight-start
    deduplicate: false,
    cache: false, // Don't cache mutations
    retry: 0,
    // highlight-end
  };
});

// Create a request to see the defaults in action
const getUser = client.createRequest()({
  method: "GET",
  endpoint: "/users/:userId",
});

// All instances of getUser will now have the default options for GET requests.
// You can still override them:
const getImportantUser = getUser.setOptions({
  retry: 5, // Override the default retry count
});

console.log("Default GET options:", client.getRequestDefaultOptions(getUser));
console.log(
  "Default POST options:",
  client.getRequestDefaultOptions(client.createRequest()({ method: "POST", endpoint: "/users" })),
);
console.log("Overridden options:", client.getRequestDefaultOptions(getImportantUser));
```

---

## Customizing Request Keys

Data and requests within Hyper-Fetch are organized by unique keys. These keys are automatically generated from request
metadata like the endpoint, method, and parameters. They are crucial for features like caching, request deduplication,
and aborting. However, you can customize the key generation logic to fit your specific needs.

You might want to customize keys for:

- **Easier debugging**: Create more readable keys.
- **Specific caching strategies**: Group or isolate cache entries based on custom logic.
- **Integration with other systems**: Align keys with formats used elsewhere in your stack.

Keys must always be a string.

### Key Mapper Methods

Hyper-Fetch provides several methods to override key generation:

- `setQueryKeyMapper`: For keys used in query-like operations.
- `setCacheKeyMapper`: For keys used to store and retrieve cached data.
- `setAbortKeyMapper`: For keys used to identify requests that can be aborted.
- `setEffectKeyMapper`: For keys used by effects to track requests.

### Example

Here's how you can set custom mappers. We'll give each type of key a unique prefix to make them easily distinguishable.

```ts
// highlight-next-line
client.setQueryKeyMapper((request) => `Query__${request.method}__${request.endpoint}`);
// highlight-next-line
client.setCacheKeyMapper((request) => `Cache__${request.method}__${request.endpoint}`);
// highlight-next-line
client.setAbortKeyMapper((request) => `Abort__${request.method}__${request.endpoint}`);
// highlight-next-line
client.setEffectKeyMapper((request) => `Effect__${request.method}__${request.endpoint}`);

const getUsers = client.createRequest()({
  method: "GET",
  endpoint: "/users",
});

// const queryKey = client.getQueryKey(getUsers)
// const cacheKey = client.getCacheKey(getUsers)

// console.log(queryKey) // "Query__GET__/users"
// console.log(cacheKey) // "Cache__GET__/users"
```

---

:::success Congratulations!

You've learned how to centralize and streamline your request configurations in Hyper-Fetch!

- You can set **dynamic global defaults** for all your requests using `setRequestDefaultOptions`.
- You can tailor default behaviors based on **request properties** like the HTTP method.
- You can customize the logic for generating **request keys** to better suit your application's needs.

:::
