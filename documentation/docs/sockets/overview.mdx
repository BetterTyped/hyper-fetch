---
sidebar_position: 1
title: Sockets Overview
sidebar_label: Overview
---

import { LinkCard } from "@site/src/components";

# Overview

> The Sockets module brings real-time, event-driven communication to Hyper Fetch, enabling seamless data exchange over
> persistent connections. Designed for flexibility and type safety, it empowers you to build robust, scalable
> applications with minimal effort.

---

## Why Sockets?

Modern applications often require real-time updates-think chat apps, live dashboards, or collaborative tools. Our
sockets package provides a unified, typesafe API for working with connections like WebSockets, Server-Sent Events (SSE),
while supporting custom adapters for libraries like Firebase Realtime Database.

:::note Our approach

Sockets is built on the same principles as the core Hyper Fetch package: consistency, type safety, and developer
experience. It extends these ideas to the world of real-time data.

:::

---

## Architecture at a Glance

The Sockets module is centered around the `Socket` class, which manages the connection and orchestrates listeners and
emitters. You can:

- Initialize a socket connection
- Create listeners for incoming events
- Create emitters for sending events
- Swap adapters (WebSocket, SSE, or custom)

```tsx
import { Socket } from "@hyper-fetch/sockets";

export const socket = new Socket({
  url: "ws://localhost:3000",
});
```

---

## Typesafe realtime

Handling realtime data exchange such as with WebSockets or Server-Sent Events (SSE) presents unique challenges,
particularly around maintaining type safety as your application grows. The library addresses this by exposing dedicated
Listener and Emitter classes, each with their own explicit types for responses and payloads.

This means that when you use a listener, such as `useChatMessage`, you always know the exact type of data being handled.
Similarly, when emitting data, you have clear expectations for the payload structure.

This approach is especially powerful in projects with multiple listeners and emitters, ensuring type safety and
maintainability even as your application scales.

```tsx
import { socketClient } from "./socket-client";

const chatMessageListener = socketClient.createListener<{ message: string }>({
  url: "/api/chat-message",
});

chatMessageListener.listen({
  // message is type string
  callback: (message) => {
    // message have type ChatMessageType
    console.log(message);
  },
});
```

---

## Event-Driven and Extensible

Sockets exposes all events, making it easy to build custom devtools, analytics, or advanced integrations. The
event-driven approach ensures your app can react to every stage of the connection lifecycle.

### Core Principles

1. **Neutral standard for data exchange**: Works with any backend or protocol supporting open connections.
2. **Composable architecture**: Integrates with existing clients (socket.io, Firebase, etc.) via adapters.
3. **Type safety**: Listeners and emitters are fully typed, reducing runtime errors.
4. **Separation of concerns**: Listeners (receiving) and emitters (sending) are distinct, making logic clear and
   maintainable.
5. **Extensible by design**: Easily add your own adapters or extend existing ones.
6. **Event-driven**: Built for reactive, real-time workflows.

---

## See More

<LinkCard
  type="docs"
  title="Socket Class"
  description="Learn more about the Socket class and its configuration options."
  to="/docs/sockets/socket"
/>
<LinkCard
  type="docs"
  title="Listeners"
  description="How to receive and handle real-time events."
  to="/docs/sockets/listener"
/>
<LinkCard
  type="docs"
  title="Emitters"
  description="How to send events and handle acknowledgements."
  to="/docs/sockets/emitter"
/>
<LinkCard
  type="docs"
  title="Adapters"
  description="Customize or extend socket communication with adapters."
  to="/docs/sockets/adapter"
/>

---

With these building blocks, you're ready to build powerful, real-time features with **Hyper Fetch Sockets**! ðŸŽŠ
