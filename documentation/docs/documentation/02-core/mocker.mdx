---
sidebar_position: 6
title: Mocking
sidebar_label: Mocking
---

## Introduction

**`Request Mocking`** is a feature that allows for stubbing/mocking the response for a given endpoint,
 **keeping the complete request lifecycle and events**.

---

## Initialization

You can mock the response via the `request.setMock` method:

```tsx
const mockedRequest = request.setMock({ data: { test: 1, array: [200, 300, 404] } });
```

This way, the `mockedRequest` will always return the `data` with value `{ test: 1, array: [200, 300, 404] } }`.

---


## Config

The `setMock` method also accepts the `config` object, which allows for tweaking our response.

```tsx
    const request = client
      .createRequest()({ endpoint: "shared-base-endpoint" })
      .setMock({
        data: {mocking: 'is fun'},
        config: {
          responseDelay: 1500,
          status: 200
        },
      });


```
 - `status` -  Sets the response status. This can be a number or a string; the default is `**200**`.
 - `success` - Informs if the request should be successful or not; the default is `**true**`.
 - `responseDelay` -The number of milliseconds to delay the response.
 - `requestSentDuration` and `responseReceivedDuration` - Indicate how long the request/response phase should take in milliseconds.
If their combined total takes longer than provided timeout, each value will be automatically adjusted to last half of the timeout time.


## Usage and use cases

The mocker can be used in a few ways.
1. It can accept an object:
```tsx
const mockedRequest = request.setMock({ data: { test: 1, array: [200, 300, 404] } });  // Always returns data: { test: 1, array: [200, 300, 404]
```
2. It can accept an array of values. In this case, values will be iterated over cyclically and applied each time a request is executed:

```tsx
  request.setMock([
    { data: { data: [1, 2, 3] }, config: { status: 400, success: false } },
    { data: { data: [1, 2, 3] }, config: { status: 200 } },
  ]);

await request.send() // returns  { data: { data: [1, 2, 3] }, config: { status: 400, success: false } }
await request.send() // returns  { data: { data: [1, 2, 3] }, config: { status: 200 } }
await request.send() // returns  { data: { data: [1, 2, 3] }, config: { status: 400, success: false } }
```
3. It also accepts methods that have access to the `request` itself. This allows for dynamic mocking, dependent on the passed arguments during execution:
```tsx
    const mockedRequest = client
      .createRequest()({ endpoint: "/users/:id" })
      .setMock((r) => {
        const { params } = r;
        if (params.id === 11) {
          return { data: [1, 2, 3], config: { status: 222 } };
        }
        return { data: [4, 5, 6] };
      });
```
4. The passed method may be asynchronous:
```tsx
    const mockedRequest = client
      .createRequest<Record<string, any>>()({ endpoint: "users/:id" })
      .setMock(async (r) => {
        if (r?.params?.id === 1) {
          return { data: [1, 2, 3], config: { status: 222 } };
        }
        return { data: [4, 5, 6] };
      });
```
You can also pass a list of functions; the mocker will cycle over them and execute the correct one each time a request is executed.

## Removal

If you need to remove the mocker from a request, use the `removeMock` method:
```tsx
mockedRequest.removeMock();
```

