---
sidebar_position: 1
---

<a class="api-link" href="/api/Hyper-Fetch/Class/FetchBuilder">
  <div class="api-link-title">FetchBuilder</div>
  <div class="api-link-sub-title">Read the API Reference Â»</div>
</a>

---

## Introduction

**`FetchBuilder`** is a class that allows you to configure the connection to the server. It initializes the subsystems
of the entire library - such as queues, caches, interceptors, and allows you to create, based on its settings, commands
necessary to execute requests. In this way, the data and information flow remains locked inside a given builder - it is
isolated and does not affect other builders.

It was designed to be used as a singleton, where the builder helps us create a global structure for making server
requests, without duplicating logic in different parts of the application. In this approach, we can easily create a
solid structure and architecture of our application, which additionally facilitates the maintenance of tests by dividing
the necessary configurations and types.

---

### Purpose

- `Orchestration` of the components and flow of the library
- `Creating commands` to provide global setups and environment
- `Isolation` from other builders and their events

---

### Initialization

```tsx
import { FetchBuilder } from "@better-typed/hyper-fetch";

export const builder = new FetchBuilder({ baseUrl: "http://localhost:3000" });
```

### Setup of defaults

Due to the fact that the components in hyper fetch are created inside the builder, we can set global or default values
for our system on it.

#### Command default setup

We can use the `setCommandConfig` method to specify the defaults for every created command

#### Client request options default setup

We can use the `setRequestConfig` method to specify the defaults for every request. This method is based on the builder
typescript generic which allow you to pass any options you need for your client.

---

### Features

- #### Authentication
- #### Pre-Request Interceptors
- #### Post-Request Interceptors
- #### Query Params
- #### Header Mapper
- #### Payload Mapper

---

### Components

#### [Cache](/api/Hyper-Fetch/Class/Cache)

Handles data storages and persistance. Can be adjusted with options when initializing builder.

---

#### [Client](/api/Hyper-Fetch/Function/fetchClient)

Handles all requests within builder. Can be replaced with `setClient` method.

---

#### [SubmitDispatcher](/api/Hyper-Fetch/Class/Dispatcher)

Handles the mutation requests and queueing. Can be adjusted with options when initializing builder.

---

#### [FetchDispatcher](/api/Hyper-Fetch/Class/Dispatcher)

Handles the fetching requests and queueing. Can be adjusted with options when initializing builder.

---

#### [AppManager](/api/Hyper-Fetch/Class/AppManager)

Handles the app focus and online state. Can be adjusted with options when initializing builder.

---

#### [CommandManager](/api/Hyper-Fetch/Class/CommandManager)

Handles additional events and cancelation of requests. Can be adjusted with options when initializing builder.

---

#### [LoggerManager](/api/Hyper-Fetch/Class/LoggerManager)

Handles the logging systems for debugging. Can be adjusted with options when initializing builder.

<!-- ## Authentication

1. Adding the headers to the request during authentication

```tsx
export const builder = new FetchBuilder({ baseUrl }).onAuth((command) => {
  const state = store.getState();
  const authToken = state.auth.token;

  // Before each command with setting "auth: true" add the Bearer token
  return command.setHeaders({
    ...command.headers,
    Authorization: `Bearer ${authToken}`,
  });
});

export const getUsers = builder.createCommand<{ name: string; email: string }>()({
  method: "GET",
  endpoint: "/users",
  auth: true, // Important!
});
```

2. Refreshing the token

```tsx
export const builder = new FetchBuilder({ baseUrl }).onError(async (res, command) => {
  const status = res[2];
  const refreshToken = localStorage.getItem(REFRESH_TOKEN_STORAGE_FIELD);

  // Check if command has the used value - this will ensure you will not go into infinite loop
  if (!command.used && refreshToken && status === 401) {
    // Prepare the refresh token command
    const postRefreshToken = builder.createCommand<LoginResponse, LoginData>()({
      endpoint: "/refresh-token",
      method: "POST",
    });

    // Call the command to receive new tokens
    const [data] = await postRefreshToken.setData({ refreshToken }).exec();

    if (data) {
      // Safe the new tokens
      localStorage.setItem(TOKEN_STORAGE_FIELD, data.token);
      localStorage.setItem(REFRESH_TOKEN_STORAGE_FIELD, data.refreshToken);
      // Repeat the request
      return command.setUsed(true).send();
    }
  }
  // Return the initial response is something goes wrong
  return res;
});
``` -->

<!--

- connection graph with command and other systems

-->

<!--
## TODOS and examples

- TODO - subsection for Builder -> providing own client (other than XHR) + options
- TODO - subsection for Builder -> providing own cache.
- TODO - subsection for Builder -> section for providing own Manager implementation.
- TODO - subsection for Builder -> section for providing own queues implementation. -->
