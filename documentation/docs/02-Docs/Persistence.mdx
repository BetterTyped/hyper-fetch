---
sidebar_position: 10
---

## Description

**`Persistance`** is possible thanks to setting the appropriate cache or queues storage - which will be able to store
between sessions in the application or its launches. To enable the persistence of data, we must replace the default
storages with the ones we choose, which will meet our requirements - we do not have many requirements here, except for
the type that we accept.

:::note

Persistance storages can handle only json data. Remember that all file objects need to be translated to base64 or other
valid format to match json requirements.

:::

## Cache Persistance

```tsx
export const builder = new FetchBuilder<ServerErrorType>({
  baseUrl: "localhost:3000",
  cache: (instance) =>
    new Cache(instance, {
      storage: peristanceStorage,
    }),
});
```

## Queues Persistance

In the case of persisten queues, there are still a few open topics left in the context of web development. First of all,
it is about synchronization between browser tabs and the introduction of a "leader system" when it comes to having
several channels for data synchronization. Due to the freedom of storage that we can place here and their potential
asynchronicity - we need a few more considerations on how to solve this flow properly.

:::caution

Persistant queues shouldn't be used on the browser. This is due to the many tabs/windows possibility reasons. This way,
we will have multiple builders initialized where the **duplicated** requests will be send.

:::

```tsx
export const builder = new FetchBuilder<ServerErrorType>({
  baseUrl: "localhost:3000",
  fetchQueue: (instance) =>
    new FetchQueue(instance, {
      storage: peristanceStorage,
    }),
});
```

```tsx
export const builder = new FetchBuilder<ServerErrorType>({
  baseUrl: "localhost:3000",
  submitQueue: (instance) =>
    new SubmitQueue(instance, {
      storage: peristanceStorage,
    }),
});
```
