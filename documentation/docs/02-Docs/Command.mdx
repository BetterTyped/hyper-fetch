---
sidebar_position: 2
---

<p class="pagination-nav__item pagination-nav__item--prev">
  <a class="pagination-nav__link" href="/api/Hyper-Fetch/Class/FetchCommand">
    <div class="pagination-nav__sublabel">FetchCommand</div>
    <div class="pagination-nav__label">API Docs Â»</div>
  </a>
</p>

## Description

**`Command`** is a class that contains all information about the request we are going to execute. The strength of the
command is that you can create a kind of dump out of it - thanks to which we can recreate the command later. This
approach allows you to develop a full flow persistance - we can store requests as json (only for persistance) and then
recreate them between sessions.

It contains a large number of methods that allow you to freely manage the data in the command and create a clone of the
command after each use.

:::info

Using method on a command creates a clone of it - `we don't return a reference`!

:::

## Initialization

The command should be initialized from the builder instance, this way we pass a shared reference to the place that
manages communication in the application.

:::caution

We are using currying to achieve auto generated types for the endpoint string. <br /> This solution will be removed once
[https://github.com/microsoft/TypeScript/issues/10571](https://github.com/microsoft/TypeScript/issues/10571) get
resolved.

:::

```tsx
import { FetchBuilder } from "@better-typed/hyper-fetch";

export const builder = new FetchBuilder({ baseUrl: "http://localhost:3000" }).build();

// We create a command which allows to get the users list
export const getUsers = builder.createCommand<{ name: string; email: string }>()({
  method: "GET",
  endpoint: "/users",
});

...

// Usage without queue - simple request
const [user, error, status] = await getUsers.exec()

// Usage with queue - provides cancelation / concurrecny options / queueing
const [user, error, status] = await getUsers.send()
```

For usage with **`React`** checkout our [hooks docs](/docs/React/Overview).

## Identifiers

Each command gets its identifiers - `queueKey` and `cacheKey`. They are needed to determine under which key items will
be cached, queued, or canceled to maintain unity between many different queries.

## Testing

We have access to the inside of the command all the time, so that, with the right approach, we can combine tests and
mocking the response in a way that will allow us to reuse what has been set during development. This way, the tests
respond to changes over time - they are easier to maintain and easier to write.

## Typescript

We can put the main elements of command. This includes `Response`, `Payload`, `Local Error Response`, `Query Params`.

```tsx
const getUsers = builder.createCommand<Response, Payload, Error, QueryParams>()({ endpoint: "/users" });
```

## Caching

We can turn off caching by setting the `cache: false` option while creating command or by it's method.

## Authentication

Authentication will work and trigger the `onAuth` method from the `builder` instance once we set the `auth: true` option
on command.
