---
sidebar_position: 10
---

## Description

**`Persistance`** is possible thanks to setting the appropriate cache or queues storage - which will be able to store
between sessions in the application or its launches. To enable the persistence of data, we must replace the default
storages with the ones we choose, which will meet our requirements - we do not have many requirements here, except for
the type that we accept.

:::note

Persistance storages can handle only json data. Remember that all file objects need to be translated to base64 or other
valid format to match json requirements.

:::

## Cache Persistance

```tsx
export const builder = new Builder<ServerErrorType>({
  baseUrl: "localhost:3000",
  cache: (instance) =>
    new Cache(instance, {
      storage: peristanceStorage,
    }),
});
```

#### Async persistance storages

:::caution

This feature will be coming soon with implementation for hydration of our cache.

:::

## Queues Persistance

In the case of persisten queues, there are still a few open topics left in the context of web development. First of all,
it is about synchronization between browser tabs and the introduction of a "leader system" when it comes to having
several channels for data synchronization. In this case we need to have synchronus data storage to limit the possible
complications.

:::caution

Persistant queues shouldn't be used on the browser. This is due to the many tabs/windows possibility reasons. This way,
we will have multiple builders initialized where the **duplicated** requests will be send.

:::

#### Fetching request persistance

```tsx
export const builder = new Builder<ServerErrorType>({
  baseUrl: "localhost:3000",
  fetchDispatcher: (instance) =>
    new Dispatcher(instance, {
      storage: peristanceStorage,
    }),
});
```

#### Submit request persistance

```tsx
export const builder = new Builder<ServerErrorType>({
  baseUrl: "localhost:3000",
  submitDispatcher: (instance) =>
    new Dispatcher(instance, {
      storage: peristanceStorage,
    }),
});
```
